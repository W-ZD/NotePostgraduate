[{"title":"为 Draw.io 加入基于 Function Plot 的数学函数作图功能","url":"/post/drawio-function-plot-plugin/","content":"\n# 为 Draw.io 加入基于 Function Plot 的数学函数作图功能\n\n<!-- #! https://zhuanlan.zhihu.com/p/495914723 -->\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410000426.png)\n\n这是一个基于 [drawio_chartjs_plugin](https://github.com/nopeslide/drawio_chartjs_plugin) 和 [function-plot](https://mauriciopoppe.github.io/function-plot/) 的项目。\n\n它可以让你的 Draw.io Desktop 软件加上如虎添翼般的 **数学函数作图** 功能。GitHub 地址是：\n\n---\n\nOrangeX4/drawio-function-plot-plugin: Function Plot plugin for Draw.io Desktop.\nhttps://github.com/OrangeX4/drawio-function-plot-plugin\n\n---\n\n<!--more-->\n\n## 使用\n\n**双击** 图形并编辑 JSON 数据，结束编辑之后就会重新渲染出美观的函数图形。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410000510.png)\n\n你可以访问 [Function Plot](https://mauriciopoppe.github.io/function-plot/) 的网站阅读更详细的文档。\n\n[![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410000852.png)](https://mauriciopoppe.github.io/function-plot/)\n\n## 安装\n\n### 1. 为 Drawio Desktop 开启 `unsafe-eval`\n\n因为 `Function Plot` 使用了 `eval()` 函数，但是 `eval()` 函数是被 Electron 的 [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) 即内容安全策略默认禁止的，所以需要找到一种方式将其避开。\n\n首先，找到 drawio desktop 的安装目录，这里会有一个名为 `app.asar` 的文件。\n\n例如，我的 `app.asar` 文件就是位于 `/opt/drawio/resources` 目录里。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410002932.png)\n\n其次，安装 `asar` 工具去解包 `app.asar` 文件。（推荐先备份 `app.asar` 文件)\n\n```sh\n# 安装\nnpm install -g asar\n\n# 解包\nasar extract app.asar src\n```\n\n然后，修改位于 `src/` 目录的 `index.html` 文件，然后在 `'default-src \\'self\\' \\'unsafe-inline\\'` 之后加入 ` \\'unsafe-eval\\'` 字符串。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410003428.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410003458.png)\n\n最后，重新打包 `src\\` 文件夹成 `app.asar` 文件.\n\n```sh\n# 重新打包\nasar pack src app.asar\n```\n\n如果你能正常打开 Drawio，即为修改成功了，否则请将 `app.asar` 文件复原。\n\n\n### 2. 安装插件\n\n- 下载 `function-plot-plugin.webpack.js` 文件，位于 [Releases](https://github.com/OrangeX4/drawio-function-plot-plugin/releases/)。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410004358.png)\n\n- 点击 `Extras`，然后 `Plugins...`。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410004138.png)\n\n- 点击 `Add...`。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410004206.png)\n\n- 点击 `Select File...`。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410004252.png)\n\n- 选择 `function-plot-plugin.webpack.js` 文件，然后点击 `Apply`.\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410004616.png)\n\n- 重启 Drawio，然后你就能愉快地使用这个插件了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410004703.png)\n\n","tags":["VS Code","Markdown","Blog","Hexo","Link Card"],"categories":["Product"]},{"title":"第 7 期、科研作图：写论文、作业时用得到的作图软件","url":"/post/lesson-zero-7/","content":"\n# 第 7 期、科研作图：写论文、作业时用得到的作图软件\n\n<!-- #! https://zhuanlan.zhihu.com/p/496086808 -->\n\n有句老话说得好：「**一图胜千言。**」\n\n仅靠干巴巴的文字，一般很难表达出一些数学或计算机专业的概念，但是一旦通过一副美观简洁的插图将其表示，别人就能很简单地理解这些复杂的概念。\n\n当然，其他理工科类专业也有很多其他插图需求，例如化学科的实验图和分子式图，生物科的细胞结构图、质粒图等等。但是本文主要面向的是计算机类学生，因此这些其他专业的专业化作图会较少涉及，如果对这类图感兴趣，可以看看文末的延展阅读。\n\n计算机类文章常见的插图有以下这些：\n\n- **流程图**：又称程序框图，是表示算法、工作流或流程的一种框图表；\n- **数据图**：用以表现数据的图表，最常见的有柱状图、折线图和散点图；\n- **函数图**：可以算作一种特殊的数据图，但更强调数学上的函数概念；\n- **示意图**：又称原理图，是用抽象的图形符号而非写实的图片表示系统、设备的工作原理及其组件相互关系的简图。我们也常常用其来表示算法和数据结构中的 **数据组织方式**，如二叉树、堆栈等；\n- **电路图**：电路图也可以算成一种原理图，多于数字电路、计算机原理这类课程。\n\n这篇文章不会讲到所有的作图软件，我们偏向于选择「开源」与「免费」的解决方案，并且尽可能地「简单」。除了作图软件之外，这篇文章还会涉及到另外一些与图片或数据可视化有关的软件，具体内容请看文末。\n\n<!--more-->\n\n\n## 一、Draw.io\n\n**Drawio** 是一款 **完全免费** 的作图 App。因为 Drawio 是基于 Web 技术开发的，所以你既可以直接「**在线编辑**」，也可以「下载本地 App」，甚至能够使用 「VS Code 插件」版本的 Drawio。并且 Drawio 是一款开源软件，你可以在 [GitHub](https://github.com/jgraph/drawio) 找到它。\n\n在线编辑地址为：https://app.diagrams.net/\n\n你也可以下载本地 App：https://www.diagrams.net/\n\n类似的收费软件：Visio\n\n**Drawio** 支持画各种各样的图，例如流程图、类图、ER 图、电路图和韦恩图等。当然，我也常常用它来画数据结构和算法中的各类数据组织方式，例如图论算法里的图搜索。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410114054.png)\n\nDrawio 最大的优点是 **清晰易懂，入门简单**。只要简单地扫上一眼，谁都能明白如何使用。并且它拥有着强大的网格对齐功能，对强迫症患者特别友好。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410114625.png)\n\n可以在侧边栏调整「样式」、「文本」和「图形」等多项属性。例如背景颜色、文本大小、位置角度等等内容。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410115335.png)\n\n通过一些额外的插件，例如我做的 [drawio-function-plot-plugin](https://github.com/OrangeX4/drawio-function-plot-plugin) 插件，还可以实现在 Drawio 里画「**数学函数图像**」的效果。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410000426.png)\n\n更详细的内容可以参考 [这篇博客](https://orangex4.cool/post/drawio-function-plot-plugin/)。\n\n\n## 二、GeoGebra\n\n**GeoGebra** 是一款更为强大且用户友好的，可以画数学函数图的数学教学软件，是免费的课堂活动数字工具，可以用于绘图计算，几何作图，白板协作等。\n\n它有着全平台的支持，甚至有移动应用版本，而且完全免费。可以访问他们的官网：https://www.geogebra.org/\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410120012.png)\n\n\n## 三、Excalidraw\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410120458.png)\n\n**Excalidraw** 是一款「**手绘风格**」白板软件，可以用它画出一些精美的手绘风格示意图。并且 Excalidraw 也是一款开源软件，你可以在 [GitHub](https://github.com/excalidraw/excalidraw) 找到它。\n\n在线网址：https://excalidraw.com/\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410121047.png)\n\n\n## 四、Inkscape\n\n**Inkscape** 是一款强大，免费的 **矢量图** 设计软件，适合用来设计一些相对复杂的示意图。Inkscape 同样也是一款开源软件，你可以在 [GitLab](https://gitlab.com/inkscape/inkscape) 上找到它。\n\n下载地址：https://inkscape.org/zh-hans/\n\n类似的收费软件：Adobe Illustrator\n\n[Gilles Castel](https://castel.dev/post/lecture-notes-2/) 写了一篇文章，讲述了他是如何使用 Inkscape 画出许多精美的数学插图。其中一些图片如下：\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410133410.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410133507.png)\n\n\n## 五、PowerPoint\n\n对，你没看错，很多时候你是可以使用 Office 里的 **PowerPoint** 来画图的。和其他软件相比，PowerPoint 最大的优点是没有许多条条框框约束你，可以自己造轮子，细节由自己掌控，学习成本低，个人发挥空间很大。\n\n例如知乎的 [研之成理](https://www.zhihu.com/question/21664179/answer/211732002) 就使用 PowerPoint 画出了效果极佳的杂志封面图。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410123144.png)\n\n但是使用 PowerPoint 来作图带来的自由度也是一把双刃剑。想要画得好的话，需要耗费大量精力，且对使用者的美学素养要求高，不适合需要短时间内出结果的用户。\n\n\n## 六、Matplotlib\n\n**Matplotlib** 是 Python 的标配画图包，可以通过 **编写 Python 代码** 的方式来画「**数据图**」，例如常见的柱状图、折线图和散点图，是 Python 进行数据可视化的必备库。\n\n安装 Matplotlib，你可以选择用 anaconda 或 pip 安装，这里就不过多赘述。\n\n类似的收费软件：Origin、Matlab\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410122125.png)\n\n\n## 七、TikZ 和 Mathcha\n\n**TikZ** 是 LaTeX 的一个绘图宏包，可以使用类似 LaTeX 的命令语法来绘制矢量图。LaTeX 和 TikZ 的关系，可以比作 HTML 与 SVG 的关系。\n\n正因如此，我们 **强烈不推荐** 直接手写 TikZ 源码，可以使用一些编辑器编辑出基础的 TikZ 图形，再对源码修改，以达到微调的效果。\n\n一个比较优秀的编辑器是 [Mathcha](https://www.mathcha.io/editor)，它可以用一种「所示即所得」的方式进行编写文档和绘图，最后输出为 LaTeX 和 TikZ 源码。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410134826.png)\n\n\n## 八、Snipaste\n\n**Snipaste** 并不是一款作图软件，但是它是一个强大的截图、贴图工具。使用它的贴图功能，可以极大地提升你的生产力。\n\n下载地址：https://zh.snipaste.com/\n\nLinux 下的替代品可以使用 **Flameshot 火焰截图**。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410135809.png)\n\n\n## 九、Manim\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410140033.png)\n\n**Manim** 不是一款作图软件，但是它与数据可视化有关。\n\n不知你是否看过 [3blue1brown](https://www.youtube.com/c/3blue1brown) 的数学视频？说实话，视频效果十分惊艳，我对如何实现这种视频效果也挺感兴趣。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220410140226.png)\n\n事实上，3b1b 在 GitHub 上开源了他所使用的 Python 包：[Manim](https://github.com/3b1b/manim)，我们也通过可以通过编写 Python 代码的方式，来实现这种效果的视频。\n\n如果你感兴趣，可以看一看这个 Python 包的 Repo 页面：https://github.com/3b1b/manim\n\n\n## 十、延展阅读\n\n如果你想了解更多这方面的内容，可以看看这些知乎回答。\n\n---\n\n如何在论文中画出漂亮的插图？\nhttps://www.zhihu.com/question/21664179\n\n---\n\n类似的还有。\n\n---\n\n科研画图都用什么软件？\nhttps://www.zhihu.com/question/29557377\n\n---\n\n化学、生物方向常用的画图软件。\n\n---\n\n你在科研中用什么软件作图？能展示一下吗？\nhttps://www.zhihu.com/question/268877581\n\n---\n\n\n## 十六、参考文献\n\n1. 示意图 - Wikipedia - https://zh.wikipedia.org/wiki/%E7%A4%BA%E6%84%8F%E5%9B%BE\n2. 如何在论文中画出漂亮的插图？- https://www.zhihu.com/question/21664179\n3. 科研画图都用什么软件？- https://www.zhihu.com/question/29557377\n4. 如何在论文中画出漂亮的插图？- 研之成理的回答 - https://www.zhihu.com/question/21664179/answer/211732002\n5.你在科研中用什么软件作图？能展示一下吗？- https://www.zhihu.com/question/268877581\n6. mermaid - https://mermaid-js.github.io/mermaid/#/examples\n7. INKSCAPE 自由绘图 - https://inkscape.org/zh-hans/\n8. Excalidraw - Virtual whiteboard for sketching hand-drawn - https://github.com/excalidraw/excalidraw\n9. Drawio - Diagram - https://www.diagrams.net/\n10. Draw.io: Function Plot Plugin - https://github.com/OrangeX4/drawio-function-plot-plugin\n11. GeoGebra - 数学教学软件 - https://www.geogebra.org/\n12. Examples — Matplotlib 3.5.1 documentation - https://matplotlib.org/stable/gallery/index\n13. How I draw figures for my mathematical lecture notes using Inkscape - https://castel.dev/post/lecture-notes-2/\n14. Mathcha Editor - https://www.mathcha.io/editor\n15. Manim - 3b1b - https://github.com/3b1b/manim\n\n\n## 十七、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-7/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 7 期、科研作图：写论文、作业时用得到的作图软件 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-7/\n\n---\n\n","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"第 6 期、写作：基于 VS Code 的 Markdown 写作技术栈","url":"/post/lesson-zero-6/","content":"\n# 第 6 期、写作：基于 VS Code 的 Markdown 写作技术栈\n\n<!-- #! https://zhuanlan.zhihu.com/p/496083303 -->\n\n这期我们来讲讲，如何基于 VS Code 搭建出一套堪称「优秀」的 Markdown 写作技术栈。\n\n内容主要包括以下插件：\n\n- Vscode Icons\n- Markdown Preview Enhanced\n- Markdown All in One\n- Paste Image\n- Image preview\n- CJK Word Handler\n- Word Count CJK\n- HyperSnips for Math\n- Better Markdown & Latex Shortcuts \n- Python Brackets\n- Latex Sympy Calculator\n\n你可以通过安装插件包 `Markdown Notes Pack` 来一键安装这些插件。\n\n并且还会额外讲解 PicGo 图床的使用，以及如何用 Git、GitHub 和 [GitNotes](https://notes.orangex4.cool/) 托管你的笔记。\n\n<!--more-->\n\n## 一、Markdown Notes Pack\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408220610.png)\n\n你可以通过安装插件包 `Markdown Notes Pack` 来一键安装文章中提到的所有插件（除 PicGo 以外）。\n\n\n## 二、Vscode Icons\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedvscode-icons.gif)\n\n用以更友好地显示图标。\n\n\n## 三、Markdown Preview Enhanced\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408222334.png)\n\nMarkdown 渲染的主力，提供了许多强大的功能。\n\n这部分的内容主要摘抄自 [Markdown Preview Enhanced 简介](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/)。\n\n### 1、流程图和时序图\n\nMarkdown Preview Enhanced 可以使用 mermaid 来渲染流程图和时序图。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408222538.png)\n\n你可以查看 [mermaid 文档](https://mermaid-js.github.io/mermaid/#/) 了解更多的内容。\n\n### 2、Code Chunk\n\nMarkdown Preview Enhanced 支持渲染代码的运行结果。就像一个内嵌在 Markdown 的 Jupyter 笔记本一样。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408223003.png)\n\n默认是禁用 Code Chunk 的，并且需要在 VSCode 的插件设置中开启 `enableScriptExecution` 后才能使用。\n\n请小心使用这一功能，因为它有可能造成安全问题，别人有可能会利用这个功能执行 Markdown 文档中的恶意代码。\n\n### 3、自定义 CSS\n\n如果你需要自定义 CSS，可以按下 `Ctrl + Shift + P`，然后运行 `Markdown Preview Enhanced: Customize Css`。\n\n这个操作会打开 `style.less` 文件，你就可以在里面编写样式了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408223550.png)\n\n你也可以切换自带的主题，只需要右键打开 `Preview Theme`，然后选择即可。\n\n### 4、生成目录\n\n你可以使用\n\n```\n[TOC]\n```\n\n语法生成目录。\n\n### 5、输出为 PDF\n\n我们在右侧预览栏右键菜单，选择 **在浏览器中打开**。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220309084552.png)\n\n在浏览器中右键选择 **打印**。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220309084746.png)\n\n就能够「**输出为 PDF**」了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220309084857.png)\n\n\n## 四、Markdown All in One\n\n### 1、快捷键\n\n选中文本，按下 `Ctrl + B` 可以自动加粗。\n\n选中文本，按下 `Ctrl + I` 可以自动意大利体。\n\n### 2、格式化表格\n\n按下 `Shift + Alt + F` 可以格式化表格。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedtable-formatter.gif)\n\n### 3、增强列表编辑\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedfix-marker.gif)\n\n还可以使用 `Alt + C` 开关任务列表。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedcheck-task-list.gif)\n\n\n## 五、Paste Image\n\n用于剪贴板图片本地粘贴。\n\n不过在使用之前，你要做一点小调整：\n\n按下 `Ctrl + ,` 打开设置窗口，输入 `Paste Image Path` 并搜索, 将框内的文本改成 `${currentFileDir}/images`.\n\n![](https://pic2.zhimg.com/80/v2-c35303b43639b37a18b8893e906d7435_720w.png)\n\n设置好之后, 你就可以使用剪贴板粘贴功能了。\n\n按下快捷键 `Ctrl + Alt + V`，就能把图片自动保存到当前目录下，并以正确的格式粘贴到当前的 Markdown 文件中。\n\n这个插件用于本地粘贴，至于上传图床，可以看末尾的 PicGo 介绍。\n\n\n## 六、Image preview\n\n用于预览图片链接对应的图片，包括本地和云端图片。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408225311.png)\n\n\n## 七、CJK Word Handler\n\n用于支持中文分词，和中文符号的识别。\n\n按下 `Ctrl + ,` 打开设置面板，搜索 `CJK Word Handler`，可以设置「以字划分」、「以词划分」、「以句划分」，我个人推荐「以句划分」。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408225505.png)\n\n配置好了之后，就可以很方便地使用 `Ctrl + left` 或 `Ctrl + right` 移动光标了。\n\n\n## 八、Word Count CJK\n\n用于 Markdown 的字数统计。\n\n按下 `Ctrl + ,` 打开设置面板，搜索 `Wordcount_cjk: status bar text template`，可以设置状态栏显示文本，将其更改为 `中文：${cjk}    英文：${en_words}` 即可。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408225927.png)\n\n之后就能在 VS Code 的左下角看见字数统计了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408230033.png)\n\n\n## 九、HyperSnips for Math\n\n在上一期文章「第 5 期、写作：LaTeX 和 Markdown 中的数学公式和 HyperSnips 快捷输入」中我也提到过这个插件。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedwelcome.gif)\n\n不知道你有没有见过这篇文章。\n\n---\n\n机器之心：世界上最好的编辑器Vim：1700多页数学笔记是如何实时完成的\nhttps://zhuanlan.zhihu.com/p/61036165\n\n---\n\n你尝试了一下，然后就被 Vim 和 Latex 给劝退了。但是实际上，VS Code 完全能够替代 Vim，Markdown 在记笔记方面也完全能够替代 Latex。通过 VS Code 插件 HyperSnips for Math，你就可以像用 UtliSnips 一样使用各种神奇的 Snippets。\n\nHyperSnips 是由 [draivin](https://github.com/draivin) 开发的一个插件，致力于在 VS Code 中复原 UtliSnips 的功能。\n\nHyperSnips for Math 是我魔改过后的 HyperSnips，可以更方便地支持 Markdown 和 LaTeX 的数学功能。\n\n顺带一提，你还应该开启在 markdown 下的 **自动补全提示**, 请使用 `Shift + Ctrl + P` 然后输入 `open settings json` 打开配置文件, 然后加入以下部分:\n\n```json\n\"[markdown]\": {\n    \"editor.quickSuggestions\": true\n},\n```\n\n接下来就是简单地介绍一下 HyperSnips 的语法。\n\n先看个 **普通例子**:\n\n```hsnips\nsnippet RR \"R\" iAm\n\\mathbb{R}\nendsnippet\n```\n\n这是一个在数学环境中自动展开的 Snippet, 它有三个标示符 `iAm`, 分别代表 \"在词语内部也会触发\", \"自动展开\" 和 \"数学环境\".\n\n这个例子会在数学环境内, 自动将 `RR` 展开成为 `\\mathbb{R}`, 代表 \"实数\".\n\n再看个 **正则表达式** 的例子:\n\n``` hsnips\nsnippet `((\\d+)|(\\d*)(\\\\)?([A-Za-z]+)((\\^|_)(\\{\\d+\\}|\\d))*)/` \"Fraction no ()\" Am\n\\frac{``rv = m[1]``}{$1}$0\nendsnippet\n```\n\n其中 `rv = m[1]` 是 JavaScript 代码, 表示将正则表达式的第一个组 `m[1]` 输出给 \"返回值\" `rv`, 然后输出出去.\n\n这是一个在数学环境中自动展开的 Snippet, 它有两个标示符 'Am', 分别代表 '自动展开' 和 '数学环境'. 用处是:\n\n```\n1/    --->    \\frac{1}{}\n```\n\n它只会在数学环境 `$...$`, `$$...$$`, `\\(...\\)` 和 `\\[...\\]` 中自动展开。\n\n**还有 `${VISUAL}` 语法:**\n\n```hsnips\nsnippet fr \"frac\" iAm\n\\\\frac{${1:${VISUAL}}}{$2}\nendsnippet\n```\n\n这个语法会保存最近选中的内容 (5 秒内), 然后替换掉 `${VISUAL}` 部分.\n\n每个标志的解释：\n\n- `A`: 自动展开，不设置的话，就需要在自动补全的窗口展示出来后，按 Tab 或 Enter 来选择；\n- `i`: 词内展开，即可以在词语内部展开；\n- `w`: 词外展开，与词内展开相对；\n- `b`: 行首展开，只有在一行的开头，才会展开；\n- `M`: 多行模式，如果不设置，默认只会获取当前行文本，设置了的话就会获取多行文本来检测触发条件；\n- `m`: 数学模式，只会在数学环境 `$...$`, `$$...$$`, `\\(...\\)` 和 `\\[...\\]` 中自动展开。\n\n在 Snippet 的内容体里，可以使用 `$1`、`$2` 和 `${1:placeholder}` 这类的占位符，占位符可以通过 `Tab` 键向后跳转和 `Shift + Tab` 向前跳转。\n\n并且 Snippet 内容体还可以使用 JavaScript 语句，比如上文看见的 `\\frac{``rv = m[1]``}{$1}$0`。\n\n一些有用的变量定义如下：\n\n- `rv`: 返回值，在 Snippet 被触发的时候，会以里面的值替换代码块；\n- `t`: 占位符所包含文本组成的字符串数组，你可以用它来实现一些有趣的动态功能；\n- `m`: 正则表达式匹配组。`m[0]` 是正则表达式匹配到的全部具体内容，`m[1]` 开始就是每个组的具体内容；\n- `w`: 当前打开工作区的 URI 字符串；\n- `path`: 当前打开文件的 URI 字符串。\n\n举两个有趣的例子：\n\n```hsnips\nsnippet box \"Box\" A\n``rv = '┌' + '─'.repeat(t[0].length + 2) + '┐'``\n│ $1 │\n``rv = '└' + '─'.repeat(t[0].length + 2) + '┘'``\nendsnippet\n```\n\n这个例子可以生成一个「盒子」动态包裹住你输入的内容。\n\n```hsnips\nsnippet filename \"Current Filename\"\n``rv = require('path').basename(path)``\nendsnippet\n```\n\n这个例子表明你甚至可以使用 NodeJS 的库函数，进而实现非常强大的功能。你甚至能用 VS Code 的 API。\n\n\n## 十、Better Markdown & Latex Shortcuts\n\n提供了一些比较有用的快捷键，主要针对数学公式。\n\n## 1、单选光标\n\n使用快捷键 `Ctrl + Alt + U` 将光标变为一个。\n\n![single](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU9d8f4514fcbc4aa585e4ec98d177b8fb4.jpg)\n\n## 2、自动转为 aligned 环境\n\n按下 `Shift + Ctrl + Alt + C` 可以将行公式转为 aligned 环境。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/aligned.gif)\n\n## 3、选中快捷键\n\n选中一些文本，然后输入 `{`、`|` 或 `$` 可以囊括输入文本两边。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/set.gif)\n\n## 4、行内复制与移动\n\n### 4.1 复制\n\n使用快捷键 `Shift + Alt + ←` 将选中内容在行内向左复制。\n\n使用快捷键 `Shift + Alt + →` 将选中内容在行内向右复制。\n\n![copy](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedUd043e489d79745469b7cca5bf59a45d63.jpg)\n\n### 4.2 多行复制\n\n按下快捷 `Ctrl + Alt + down` 或者 `Ctrl + D` 变为多光标后，可以用 `Shift + Alt + →` 进行多行复制。\n\n![multicopy](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU8e2d3c2e81264cb4a52d9dd2bab65eb0z.jpg)\n\n### 4.3 移动\n\n使用快捷键 `Alt + ←` 将选中内容在行内向左移动一位，使用快捷键 `Ctrl + Alt + ←` 将选中内容在行内向左移动一个单词。\n\n使用快捷键 `Alt + →` 将选中内容在行内向右移动一位，使用快捷键 `Ctrl + Alt + →` 将选中内容在行内向右移动一个单词。\n\n![move](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU03ce2e8b468c49d4b80f5399c2290ff72.jpg)\n\n\n\n## 十一、Python Brackets\n\n## 1、嵌入括号\n\n快捷键：`Ctrl + ;`\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/python-brackets-nest.gif)\n\n## 2、删除括号内部内容\n\n快捷键：`Ctrl + Shift + Alt + Backspace`\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/python-brackets-remove.gif)\n\n## 2、选中括号内部内容\n\n快捷键：`Ctrl + Shift + Alt + /`\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/python-brackets-select.gif)\n\n\n## 十二、Latex Sympy Calculator\n\n## 1、简介\n\n**Latex Sympy Calculator** 是一款 VS Code 插件，它能够帮助你在 VS Code 写 Latex 或 Markdown 的时候，一键计算 Latex 书写的数学公式。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/Ud246889e25e84421a60a86435e693bfaJ.gif)\n\n**当前支持的功能:**\n\n1. **算术:** 加 (+)，减 (-)，点乘 (·)，叉乘 (×)，除法 (/)，乘方 (^)，绝对值 (|x|)，开方 (√)，虚数 (i)...\n2. **字母表:** 英文字母 a - z，A - Z，希腊字母 α - ω，下标 (x_1)，重音符 (ā)...\n3. **常见函数:** 最大公约数 (gcd)，最小公倍数 (lcm)，下界 (floor)，上届 (ceil)，最大值 (max)，最小值 (min)，取对数 (log)，自然对数 (ln)，指数 (exp)，三角函数 (sin，cos，tan，csc，sec，cot，arcsin，sinh，arsinh)...\n4. **微积分:** 求极限 ($lim_{n\\to\\infty}$)，求导/求微分 ($\\frac{d}{dx}(x^2+x)$)，求积分 ($\\int xdx$)...\n5. **线性代数:** 矩阵 (Matrix)，行列式 (Determinant)，转置 (Transpose)，求逆 (Inverse)，初等变换 (Elementary Transformation)...\n6. **关系符:** 大于 (>)，小于 (<)，大于等于 (≥)，小于等于 (≤)，相等 (=)...\n7. **其他:** 二项式...\n\n当然，实际上还有很多其他的功能，**只要是 Python Sympy 包支持的运算，都可以通过这个插件来实现**。\n\n通过这个插件，你就不再需要一字一句地将 Latex 转译成其他语言，然后用 Matlab 或 MMA 等数学软件进行科学计算了。简单的 **符号推导**，**矩阵运算**，**微积分**，**科学计算**，完全可以利用这个插件来实现。\n\n如果你也在 VS Code 中用 **Latex** 或 **Markdown** 写数学公式，那么这就是你 **必备的 VS Code 科学计算插件**。\n\n[Latex Sympy Calculator 插件的 GitHub 页面](https://github.com/OrangeX4/Latex-Sympy-Calculator)\n\n[latex2sympy2 包的 Github 页面](https://github.com/OrangeX4/latex2sympy)\n\n### 2、环境配置\n\n**安装 Python:**\n\n你可以去 [官网](https://www.python.org/downloads/) 下载 Python3。\n\n如果你是 Windows，而且觉得官网网络连接不稳定，可以去 [软件中心](https://pc.qq.com/detail/5/detail_24685.html) 下载。\n\n如果你是 Mac，可以使用 `brew install python` 安装 Python3。\n\n如果你是 Linux，可以执行以下命令安装 Python3 和 Pip3：\n\n``` sh\nsudo apt install python3\nsudo apt-get install python3-pip\n```\n\n**安装 Flask 和 latex2sympy2 包:**\n\n执行以下命令:\n\n``` sh\npip install latex2sympy2\npip install Flask\n```\n\n如果使用的是 Mac 或 Linux，并且安装失败了，可以尝试用 `pip3` 替代 `pip`。\n\n**检查是否安装成功:**\n\n在命令行中，输入 `python` 进入 **Python 交互环境**，然后输入以下代码:\n\n``` python\nimport latex2sympy2\nimport flask\n```\n\n如果没有报错，就说明安装成功了。\n\n\n### 3、计算 Latex 公式并输出 Latex 结果\n\n你可以选中一段 Latex 公式，然后按下 `Shift + Ctrl + Alt + E` (equal) 获取相应的结果，大概如下：\n\n``` latex\n# 计算前\n\\frac{d}{dx}(x^3+x^2+1)\n\n# 计算后\n\\frac{d}{dx}(x^3+x^2+1) = x \\left(3 x + 2\\right) \n```\n\n你也可以选中一段 Latex 公式，然后按下 `Shift + Ctrl + Alt + R` (replace) 获取相应的结果，这个快捷键与上一个的唯一区别是，它会直接替换掉你选中的公式，大概如下：\n\n``` latex\n# 计算前\n\\frac{d}{dx}(x^3+x^2+1)\n\n# 计算后\nx \\left(3 x + 2\\right) \n```\n\n### 4、因式分解与展开\n\n你可以选中一段文本，然后按下 `Shift + Ctrl + Alt + F` (factor) 来获取这段表达式的因式分解。大概如下：\n\n``` latex\n# Before\nx^{2} + 2 x y + y^{2}\n\n# After\n(x + y)^{2}\n```\n\n你可以选中一段文本，然后按下 `Shift + Ctrl + Alt + X` (expand) 来获取这段表达式的展开。大概如下：\n\n``` latex\n# Before\n(x + y)^{2}\n\n# After\nx^{2} + 2 x y + y^{2}\n```\n\n### 5、计算 Latex 公式并输出数值结果\n\n你可以选中一些文本，并按下 `Shift + Ctrl + Alt + N` (numerical) 来获取当前 Latex 公式的。大概如下：\n\n``` latex\n# 计算前\n\\sqrt{2}\n\n# 计算后\n\\sqrt{2} = 1.41421356237310 \n```\n\n### 6、定义变量\n\n你可以 **定义并赋值** 一个变量。使用 `Shift + Ctrl + Alt + D` (define) 快捷键和类似 `y = x + 1` 的语法实现这个功能。\n\n``` latex\n# 按下 Shift + Ctrl + D 进行变量定义与赋值\ny = x + 1\n\n# Shift + Ctrl + E\n# 计算前\n2y\n# 计算后\n2y = 2 x + 2\n\n# 你可以看出，y 被替换成了 x + 1 来参与计算\n```\n\nPS: 如果你计算的是 `y == x + 1`，它不是变量定义与赋值，它输出的是 `true` 或 `false`，代表着这个等式是否成立。\n\n如果你想查看现有已定义的变量，你可以按下 `Shift + Ctrl + P`，然后输入 `latex-sympy-calculator: Show Current variances` 并运行，然后你就会获取到类似这样的数据：\n\n``` latex\ny = x + 1\nz = 2x\n```\n\n如果你想清除这些已经定义的变量，你可以按下 `Shift + Ctrl + P`，然后输入 `latex-sympy-calculator: Reset Current variances` 并运行。\n\n如果你想要关闭虚数 `i` 的支持，可以按下 `Shift + Ctrl + P`，然后输入 `latex-sympy-calculator: Toggle Complex Number Support For Variances`。\n\n虚数功能类似这样: `x = 1 + 2i`，`\\int \\cos xe^{-ikx}dx`。\n\n### 7、矩阵符号\n\n你可以定义矩阵符号用于矩阵推导。使用 `Shift + Ctrl + Alt + D` (define) 和类似 `X \\in \\mathbb{R}^{n \\times m}` 的语法即可。\n\n``` latex\n# Shift + Ctrl + D\nX \\in \\mathbb{R}^{n \\times m}\n\n# Shift + Ctrl + E\n# 计算前\nX X^{T} X\n# 计算后\nX X^{T} X\n\n# Shift + Ctrl + E\n# 计算前\nX^{-1} X\n# 计算后\nI\n```\n\n### 8、计算 Python 表达式\n\n你可以用快捷键 `Shift + Ctrl + Alt + P` 计算一个 Python 表达式。\n\n**支持所有的 Sympy 和 latex2sympy2 包的功能。**\n\n例如，你可以获取当前已经定义的变量值：\n\n``` python\n# 运算前\nvar['y']\n\n# 运算后\nvar['y'] = x + 1\n```\n\n你可以解方程:\n\n``` python\n# 运算前\nsolve([2 * x - y - 3, 3 * x + y - 7],[x, y])\n\n# 运算后\nsolve([2 * x - y - 3, 3 * x + y - 7],[x, y]) = {x: 2, y: 1}\n```\n\n将 Latex 转成 Sympy 和将 sympy 转成 latex:\n\n``` python\n# Latex to Sympy\nexpr = latex2sympy(r'x^2 + 3x + 1')\n\n# Sympy to Latex\nlatex = latex(expr)\n\n# Latex to Latex\nresult = latex2latex(r'\\frac{d}{dx}(x^3+x^2+1)')\n```\n\n\n## 十三、PicGo 图床\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedpicgo-2.0.gif)\n\nPicGo: 一个用于快速上传图片并获取图片 URL 链接的工具，有着较为完善的生态链。\n\n有三种推荐的使用方式，分别是「GUI 界面」、「命令行」和「VS Code 插件」。\n\n当前 PicGo 支持如下图床，你可以选择其中一种作为使用：\n\n- 七牛图床 v1.0\n- 腾讯云 COS v4\\v5 版本 v1.1 & v1.5.0\n- 又拍云 v1.2.0\n- GitHub v1.5.0\n- SM.MS V2 v2.3.0-beta.0\n- 阿里云 OSS v1.6.0\n- Imgur v1.6.0\n\n当然，你也可以使用一些插件，添加第三方图床。\n\n当前我使用的是「腾讯云 COS」，每个月大概花费几毛钱，胜在稳定，国内访问迅速，且不易丢失。\n\n具体的文档可以看 [这里](https://picgo.github.io/PicGo-Doc/zh/guide/#%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0)。\n\n\n## 十四、GitNotes 托管笔记\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408235806.png)\n\n如果你使用了 Git 和 GitHub 来托管你的笔记，你也许可以考虑也使用 [GitNotes](https://notes.orangex4.cool/)。\n\n如果你将你的笔记上传到了云端，你就可以 **随时随地** 地查看你的笔记，并且可以很方便地 **分享** 给别人。比如，你要看我的笔记，就可以访问这个链接：\n\n[https://notes.orangex4.cool/?git=gitlab](https://notes.orangex4.cool/?git=gitlab)\n\n如果你把你的笔记上传到了 GitHub，你也可以仿照这个格式查看：\n\n[https://notes.orangex4.cool/?git=github&github=typoverflow/note](https://notes.orangex4.cool/?git=github&github=typoverflow/note)\n\n大概格式是: \n\nhttps://notes.orangex4.cool/?git=github&github=<用户名>/<笔记仓库>\n\n你就有了这种效果的笔记。\n\n\n## 十五、延展阅读\n\nMarkdown Preview Enhanced 还支持许多其他有趣的功能，推荐看一看。\n\n---\n\nMarkdown Preview Enhanced 简介\nhttps://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/\n\n---\n\nLatex Sympy Calculator 使用的科学计算包 Sympy。（英文）\n\n---\n\nWelcome to SymPy's documentation\nhttps://docs.sympy.org/latest/index.html\n\n---\n\nPicGo 的使用方法。\n\n---\n\nPicGo 图片上传+管理新体验\nhttps://picgo.github.io/PicGo-Doc/zh/guide/#%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0\n\n---\n\n\n## 十六、参考文献\n\n1. Markdown Preview Enhanced 简介 - https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/\n2. mermaid - Markdownish syntax for generating charts - https://mermaid-js.github.io/mermaid/#/\n3. Welcome to SymPy's documentation - https://docs.sympy.org/latest/index.html\n4. PicGo 图片上传+管理新体验 - https://picgo.github.io/PicGo-Doc/zh/guide/#%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0\n5. Markdown All in One - https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\n6. HyperSnips - https://marketplace.visualstudio.com/items?itemName=draivin.hsnips\n7. Better Markdown & Latex Shortcuts - https://github.com/OrangeX4/Better-Markdown-Latex-Shortcuts\n8. Python Bracket - https://github.com/OrangeX4/Python-Brackets\n9. Latex Sympy Calculator - https://marketplace.visualstudio.com/items?itemName=OrangeX4.latex-sympy-calculator\n10. 如何计算一个用 Latex 书写的数学公式？- https://zhuanlan.zhihu.com/p/411848925\n11. 教程向: 在 VS Code 中用 Markdown 做「数字化」学习笔记 - https://zhuanlan.zhihu.com/p/366596107\n\n\n## 十七、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-6/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 6 期、写作：基于 VS Code 的 Markdown 写作技术栈 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-6/\n\n---\n","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"第 5 期、写作：LaTeX 和 Markdown 中的数学公式和 HyperSnips 快捷输入","url":"/post/lesson-zero-5/","content":"\n# 第 5 期、写作：LaTeX 和 Markdown 中的数学公式和 HyperSnips 快捷输入\n\n<!-- #! https://zhuanlan.zhihu.com/p/496081143 -->\n\n书写「**数学公式**」一直都是写作中的一个难点，使用 Word 之类的软件的时候，往往需要类似 MathType 之类的第三方插件来帮助输入，而且输入效率低下。\n\n如今编写数学公式，「**LaTeX 式数学公式**」已经成为了事实标准，无论是 LaTeX 自身，还是 Markdown，甚至是 Word 里面的使用的 MathType 和 AxMath，事实上都支持 LaTeX 式的语法，其特点是类似 `\\int_a^b xdx` 这样，特殊符号使用以 **反斜杠** 开头的 **命令** 来表示。\n\n然而，直接使用 LaTeX 式的语法来写，输入效率依然很差。但是在使用了 **VS Code** 和 **Markdown**，以及一些 **VS Code 插件** 之后，输入效率会 **大幅提升**，甚至能达到比手写更快的效果。\n\n这一期文章，我们均以在 VS Code 中编辑 Markdown 作为写作环境，介绍 LaTeX 式数学公式的书写方法。当然，这套书写方法在 VS Code 中编写 LaTeX 时也同样适用。\n\n<!--more-->\n\n## 一、常见数学公式编辑解决方法\n\n### 1、Word 流派\n\n初学者刚开始学习如何编辑数学公式时，很容易就会碰到这两款软件。分别是 [MathType](https://www.mathtype.cn/) 和 [AxMath](https://www.amyxun.com/)，它们均可以内嵌到 Word 里。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408150130.png)\n\n- **MathType**：老牌软件，优点是普及率高，使用 Word 编辑数学公式的人基本上都用过 Mathtype，所以兼容性比较好。缺点是界面不美观，使用起来复杂，**正版价格昂贵**，年订阅制，且每年要 338 元。\n- **AxMath**：新创软件，优点是界面清晰，使用简单，与 LaTeX 数学公式互转效果好。但缺点是普及率低，迁移难度大，如果对方电脑里面没有安装 AxMath，就只能以图片形式展示，而不能编辑。**正版价格适中**，买断制，一共 36 元。\n\n说实话，我们 **强烈不建议** 购买这类公式软件。这类公式软件唯一优点就是可以附在 Word 文档里面，并且可以后续继续编辑。\n\n然而，实际上，如果你编辑数学公式的需求 **比较少**，那么可以直接使用下文会提到的 **在线 LaTeX 数学公式编辑器**，不仅支持 **可视化操作**，而且 **完全免费**，能够生成 **多种图片格式** 以供内嵌到 Word 文档中。\n\n如果你编辑数学公式的需求 **比较多**，那为什么不花费一两个小时，学习一下 LaTeX 或 Markdown 中数学公式的编辑方法呢？不仅 **完全免费**，而且 **方便后续编辑**，并且使用 VS Code 及插件之后，**输入效率会高几个数量级**。\n\n### 2、LaTeX 原生\n\n**LaTeX** 原生支持数学公式，再加上 **amsmath 宏包**，就能以清晰美观的方式编辑数学公式。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408152227.png)\n\n### 3、数学公式识别\n\n除了可视化编辑和 LaTeX 式编辑之外，我们还可以考虑 **数学公式识别**。当前数学公式识别做得比较好的是 [Mathpix Snip](https://mathpix.com/).\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408155910.png)\n\n---\n\nMathpix Snip\nhttps://mathpix.com/\n\n---\n\nMathpix Snip 有着 **超高的识别精准度**，甚至能够精准地识别手写的数学公式。\n\n不过它也有缺点，就是收费昂贵。每个人每个月只能免费识别 50 次。可以订阅 pro 版本，每个月 5 美刀，最多能识别 5000 次。\n\n### 4、Web 流派\n\n根据“Atwood’s Law”原则：\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript.\n> \n> 任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。\n\n我们当然也有相应的 JS 库来实现 LaTeX 式数学公式在 **网页上** 的 **渲染**，甚至是 **编辑**。当前常见的渲染库有 [KaTeX](https://katex.org/) 和 [MathJax](https://www.mathjax.org/)。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408154127.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408154200.png)\n\n- **KaTeX**：**小而快** 的数学公式渲染库。因为 KaTeX 将注意力完全投入于将 **标准 LaTeX 数学公式** 渲染成 **HTML 元素**，而不考虑 LaTeX 拓展语法，例如 physics 宏包，也不打算将其渲染成 SVG 等图形，所以渲染速度极快。\n- **MathJax**：**大而全** 的数学公式渲染库。可以将以 **LaTeX**、**MathML** 和 **AsciiMath** 语法书写的数学公式，渲染成 **HTML**、**SVG** 或 **MathML**。并且支持扩展，比如 **physics 宏包** 和 **amsmath 宏包**。\n\n**Markdown** 一般就是使用这两个库其中之一来渲染数学公式的。VS Code 的 **Markdown Preview Enhanced** 可以自由在 KaTex 和 MathJax 之间切换。\n\n我个人常用的是 **KaTeX**，因为它渲染速度快，而且也支持了我需要的所有功能。\n\n除了数学渲染，也有支持 **可视化编辑** 的数学公式库，例如 [MathLive](https://cortexjs.io/mathlive/demo/)。\n\n顺便要提到的是一个 **在线 LaTeX 数学公式编辑器**，它是由 UP 主 [妈咪说](https://www.bilibili.com/video/BV14g4y1q7pb) 借助 **MathJax** 和 **Mathpix 接口** 开发的一个在线工具。使用这个在线网站，就可以避免使用 MathType 和 AxMath 这类收费软件了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408155241.png)\n\n---\n\nLaTeX 公式编辑器\nhttps://www.latexlive.com/home##\n\n---\n\n\n## 三、环境配置\n\n回归正题，我们要讲的是如何使用 VS Code 编辑 Markdown 或 LaTeX 中的数学公式。\n\n我们默认你已经看过「第 3 期、写作：使用 Markdown 记笔记入门」和「第 4 期、写作：TeX、LaTeX 与排版系统」，并且安装好了 **VS Code** 和 **Markdown Preview Enhanced** 插件。\n\n除此之外，你还需要安装 **HyperSnips for Math** 插件，在插件面板搜索安装即可。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408164323.png)\n\n安装完成后，按下快捷键 `Ctrl + Shift + P`，输入命令 `Open Snippets Directory`，就可以打开一个文件夹。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408164736.png)\n\n在该文件夹新建一个文件 `markdown.hsnips`，并将 [OrangeX4's hsnips](https://github.com/OrangeX4/OrangeX4-HyperSnips/blob/main/markdown.hsnips) 里面的内容输入进去，保存，就可以了。\n\n---\n\nOrangeX4's hsnips\nhttps://github.com/OrangeX4/OrangeX4-HyperSnips/blob/main/markdown.hsnips\n\n---\n\n后续要更改这个文件，可以按下快捷键 `Ctrl + Shift + P`，输入命令 `Open Snippets File` 即可打开。\n\n这个插件是用来实现 **自动补全** 和 **自动展开** 的。\n\n例如，\n\n```\nsnippet RR \"R\" iAm\n\\mathbb{R}\nendsnippet\n```\n\n会将数学环境内将 `RR` 自动扩展成 `\\mathbb{R}`，更多详细的语法介绍会放在文末和下一篇博文中。\n\n顺带一提，我的 HyperSnips 的「**设计理念**」是「**不用输入反斜杠**」。如果你用到了反斜杠 `\\`，可以使用 `Open Snippets File` 打开 `.hsnips` 文件，然后 `Ctrl + F` 搜索一下你想要用到的「自动扩展」。\n\n\n## 四、行内公式和行间公式\n\n### 1、Markdown\n\nMarkdown 的行内公式和行间公式语法很简单。\n\n```text\n# 数学公式\n\n行内公式: \n\n单位圆 $x^2+y^2=1$\n\n行间公式:\n\n$$\n\\begin{cases}\nx=\\rho\\cos\\theta \\\\\ny=\\rho\\sin\\theta \\\\\n\\end{cases}\n$$\n```\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408165641.png)\n\n顺带一提，在行内公式前面加上 `\\displaystyle` 可以将行内公式以 **行间公式大小** 展示。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408172028.png)\n\n**HyperSnips 自动扩展**：\n\n行内公式：\n\n```text\nlm  =>  $...$\n```\n\n行间公式：\n\n```text\ndm  =>\n\n$$\n...\n$$\n```\n\n展示模式：\n\n```text\ndis  =>  \\displaystyle\n```\n\nTips：按下 Tab 键可以跳转光标。\n\n### 2、LaTeX\n\nLaTeX 也区分行内公式和行间公式\n\n```latex\n\\documentclass[UTF8]{ctexart}\n\\usepackage{amsthm}\n\\begin{document}\n\n行内公式: \n\n单位圆 $x^2+y^2=1$\n\n行间公式:\n\n% 无编号\n\\[\n  x=\\rho\\cos\\theta\n\\]\n\n% 有编号\n\\begin{equation}\n  y=\\rho\\sin\\theta\n\\end{equation}\n\n\\end{document}\n```\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220408171017.png)\n\n**HyperSnips 自动扩展**：\n\n行内公式：\n\n```text\nlm  =>  $...$\n```\n\n行间公式：\n\n```text\neqt  =>\n\n\\begin{equation}\n  ...\n\\end{equation}\n```\n\nTips：按下 Tab 键可以跳转光标。\n\n\n## 五、具体语法\n\n**注意：不要在公式内写中文**\n\n### 1. 上标和下标\n\n``` latex\n上标 $x^2 + y^{12} = 1$\n\n上标 $x_1 + y_{12} = 1$\n```\n\n![](https://pic2.zhimg.com/80/v2-a527faa78367be526a55992ebfae09f9_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\nxsr  =>  x^{2}\n\nxtp  =>  x^{...}\n\nx1  =>  x_1\n\nxii  =>  x_i\n\nxsb  =>  x_{...}\n```\n\n\n### 2. 分式\n\n``` latex\n较小的行内行分数 $\\frac{1}{2}$\n\n展示型的分式 $\\displaystyle\\frac{x+1}{x-1}$\n```\n\n其中 `\\displaystyle` 用于将行内展示转为块状展示.\n\n![](https://pic1.zhimg.com/80/v2-6068b9817b165318fbb44912601a1450_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\n1/  =>  \\frac{1}{...}\n\n(1 + 2)/  =>  \\frac{(1+2)}{...}\n\n//  =>  \\frac{...}{...}\n```\n\n\n### 3. 根式\n\n``` latex\n开平方 $\\sqrt{2}$\n\n开 $n$ 次方 $\\sqrt[n]{2}$\n```\n\n![](https://pic4.zhimg.com/80/v2-7f43224f74cae008fa950a82252e0903_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\nhsq  =>  \\sqrt{...}\n```\n\n### 4. 空格\n\n数学公式中的 **空格和换行** 都会在编译时 **被忽略**，想要实现「空格」的效果，需要用特别的命令。\n\n``` latex\n紧贴 $a\\!b$\n\n没有空格 $ab$\n\n小空格 $a\\,b$\n\n中等空格 $a\\;b$\n\n大空格 $a\\ b$\n\nquad 空格 $a\\quad b$\n\n两个 quad 空格 $a\\qquad b$\n```\n\n![](https://pic2.zhimg.com/80/v2-3d5d3d55a6cc7fa4108a3d72287ec509_720w.png)\n\n\n### 5. 累加, 累乘和积分\n\n``` latex\n累加 $\\sum_{k=1}^n\\frac{1}{k}  \\quad  \\displaystyle\\sum_{k=1}^n\\frac{1}{k}$\n\n累乘 $\\prod_{k=1}^n\\frac{1}{k}  \\quad  \\displaystyle\\prod_{k=1}^n\\frac{1}{k}$\n\n积分 $\\displaystyle \\int_0^1x{\\rm d}x  \\quad  \\iint_{D_{xy}}  \\quad  \\iiint_{\\Omega_{xyz}}$\n```\n\n![](https://pic2.zhimg.com/80/v2-107c58a00665db46695c759d10926ded_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\nsum  =>  \\sum_{...}\n\nprod  =>  \\prod_{<n=1>}^{<\\infty>} ...\n\nint  =>  \\int\n\ndint  =>  \\int_{<-\\infty>}^{<\\infty>} ... \\mathrm{d}x\n```\n\nTips：按下 Tab 键可以跳转光标。\n\n\n### 6. 括号修饰\n\n用 `\\left` 和 `\\right` 可以让括号适配内部大小\n\n``` latex\n圆括号 $\\displaystyle \\left(\\sum_{k=1}^{n}\\frac{1}{k} \\right)^2$\n\n方括号 $\\displaystyle \\left[\\sum_{k=1}^{n}\\frac{1}{k} \\right]^2$\n\n花括号 $\\displaystyle \\left\\{\\sum_{k=1}^{n}\\frac{1}{k} \\right\\}^2$\n\n尖括号 $\\displaystyle \\left\\langle\\sum_{k=1}^{n}\\frac{1}{k} \\right\\rangle^2$\n```\n\n![](https://pic3.zhimg.com/80/v2-2564e223b37d79424ff60ecf1ee4e5b6_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\n@(  =>  \\left( ... \\right)\n\n@[  =>  \\left[ ... \\right]\n\n@{  =>  \\left\\{ ... \\right\\}\n\n@<  =>  \\left< ... \\right>\n\nset  =>  \\{ ... \\}\n```\n\n### 7. 多行算式对齐\n\n``` latex\n居中:\n\n$$\n\\begin{aligned}\ny &=(x+5)^2-(x+1)^2 \\\\\n&=(x^2+10x+25)-(x^2+2x+1) \\\\\n&=8x+24 \\\\\n\\end{aligned}\n$$\n\n左对齐:\n\n$\n\\begin{aligned}\ny &=(x+5)^2-(x+1)^2 \\\\\n&=(x^2+10x+25)-(x^2+2x+1) \\\\\n&=8x+24 \\\\\n\\end{aligned}\n$\n```\n\n![](https://pic4.zhimg.com/80/v2-2ce4065baebaa934da5963574f65bce7_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\nali  =>\n\\begin{aligned}\n... \\\\\n\\end{aligned}\n```\n\n如果你安装了 `Better Markdown & Latex Shortcuts` 插件，你还可以按下 `Shift + Ctrl + Alt + C` 可以将行公式转为 aligned 环境。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/aligned.gif)\n\n\n### 8. 方程组\n\n``` latex\n$$\n\\begin{cases}\nk_{11}x_1+k_{12}x_2+\\cdots+k_{1n}x_n=b_1 \\\\\nk_{21}x_1+k_{22}x_2+\\cdots+k_{2n}x_n=b_2 \\\\\n\\cdots \\\\\nk_{n1}x_1+k_{n2}x_2+\\cdots+k_{nn}x_n=b_n \\\\\n\\end{cases}\n$$\n```\n\n![](https://pic1.zhimg.com/80/v2-a085a39d41c0af5ded6b328907e662ec_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\ncase  =>\n\\begin{cases}\n... \\\\\n\\end{cases}\n```\n\n### 9. 矩阵\n\n\n``` latex\n矩阵:\n\n$$\n\\begin{pmatrix}\n1 & 1 & \\cdots & 1 \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\end{pmatrix}\n\n\\quad\n\n\\begin{bmatrix}\n1 & 1 & \\cdots & 1 \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\end{bmatrix}\n$$ \n\n行列式: \n\n$$\n\\begin{vmatrix}\n1 & 1 & \\cdots & 1 \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\end{vmatrix}\n$$\n```\n\n![](https://pic3.zhimg.com/80/v2-8f249643b32b0fd0375dc8f8c8b40d86_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\nbmat2  =>  \\begin{bmatrix} ... & ... \\\\ ... & ... \\\\\\end{bmatrix}\n\nvec2  =>  \\begin{pmatrix} ... \\\\ ... \\\\\\end{pmatrix}\n```\n\ntips：按下 Tab 键可以切换到下一个位置。\n\n### 10. 特殊字符\n\n![](https://pic2.zhimg.com/80/v2-842b02c54dd7d8e0571609414e79bdc1_720w.png)\n\n更多特殊符号可以 [上网查询](https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols)\n\n可以搜索 \"Latex 符号表\"\n\n**HyperSnips 自动扩展**：\n\n```text\nalpha  =>  \\alpha\n\nSigma  =>  \\Sigma\n```\n\n\n### 11. 公式编号与引用\n\n``` latex\n$$\nx+2 \\tag{1.2}\n$$\n\n$$\n\\begin{equation}\nx^n+y^n=z^n\n\\end{equation}\n$$\n\n由公式 $(1.2)$ 可得到结论\n```\n\n![](https://pic2.zhimg.com/80/v2-e602d10556b445efba976af2ee0b4209_720w.jpg)\n\n### 12. 零碎的重要语法\n\n* 点乘 `$\\cdot$`, 叉乘 `$\\times$`, 异或 `$\\otimes$`, 直和 `$\\oplus$`, 加减 `$\\pm$`, 复合 `$\\circ$`. \n* 小于等于 `$\\leq$`, 大于等于 `$\\geq$`, 不等 `$\\neq$`, 恒等 `$\\equiv$`, 约等 `$\\approx$`, 等价 `$\\cong$`, 相似 `$\\sim$`, 相似等于 `$\\simeq$`, 点等 `$\\doteq$`.\n* 逻辑与 `$\\land$`, 逻辑或 `$\\lor$`, 逻辑非 `$\\lnot$`, 蕴涵 `$\\to$`, 等价 `$\\leftrightarrow$`.\n* 因为 `$\\because$`, 所以 `$\\therefore$`, 存在 `$\\exist$`, 任意 `$\\forall$`.\n* 左小箭头 `$\\leftarrow$`, 右小箭头 `$\\rightarrow$`, 左大箭头 `$\\Leftarrow$`, 右大箭头 `$\\Rightarrow$`, 右长箭头 `$\\xrightarrow[fgh]{abcde}$`.\n* 属于 `$\\in$`, 包含于 `$\\subset$`, 真包含于 `$\\subseteq$`, 交 `$\\cap$`, 并 `$\\cup$`, 空集 `$\\empty$`\n* 短向量 `$\\vec{x}$`, 长向量 `$\\overrightarrow{AB}$`, 上横线 `$\\overline{p}$`.\n* 无限 `$\\infty$`, 极限 `$\\lim$`, 微分 `${\\rm d}$`, 偏导 `$\\partial$`, 点求导 `$\\dot{y}$`, 点二阶导 `$\\ddot{y}$`, 变化量 `$\\Delta$`, 梯度 `$\\nabla$`.\n* 横省略 `$\\cdots$`, 竖省略 `$\\vdots$`, 斜省略 `$\\ddots$`.\n* 常见函数 `$\\sin$`, `$\\cos$`, `$\\tan$`, `$\\arcsin$`, `$\\arccos$`, `$\\arctan$`, `$\\ln$`, `$\\log$`, `$\\exp$`.\n\n![](https://pic1.zhimg.com/80/v2-1063f781baa2bed9e7ebb32428719650_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```text\n**  =>  \\cdot\nxx  =>  \\times\notimes  =>  \\otimes\n<=  =>  \\le\n!=  =>  \\neq\n==  =>  \\equiv\n~~  =>  \\thickapprox\nsim  =>  \\sim\nland  =>  \\land\nlor  =>  \\lor\nbec  =>  \\because\nthr  =>  \\therefore\nEE  =>  \\exists\nAA  =>  \\forall\ninn  =>  \\in\nsse  =>  \\subseteq\nsqs  =>  \\sqsubseteq\ncap  =>  \\cap\ncup  =>  \\cup\nempty  =>  \\empty\noo  =>  \\infty\nlim  =>  \\lim_{<n> \\to <\\infty>}\ndd  =>  \\mathrm{d}\npart  =>  \\frac{\\partial <V>}{\\partial <x>}\nDelta  =>  \\Delta\nnabla  =>  \\nabla\n...  =>  \\cdots\nsin  =>  \\sin\n```\n\n还有特别重要的数集、向量、矩阵符号：\n\n```text\nRR  =>  \\mathbb{R}\nNN  =>   \\mathbb{N}\ntxt  =>  \\text{...}\nxbar  =>  \\bar{x}\nxhat  =>  \\hat{x}\nxhvec  =>  \\vec{x}\nxhdot  =>  \\dot{x}\nXbb  =>  \\mathbb{X}\nXbs  =>  \\boldsymbol{X}\nXbm  =>  \\bm{X}\nXbf  =>  \\mathbf{X}\nXsf  =>  \\mathsf{X}\nXcal  =>  \\mathcal{X}\nXfrak  =>  \\mathfrak{X}\nXrm  =>  \\mathrm{X}\n```\n\n**注意：不要在公式内写中文**\n\n\n## 六、HyperSnips 介绍\n\n不知道你有没有见过这篇文章。\n\n---\n\n机器之心：世界上最好的编辑器Vim：1700多页数学笔记是如何实时完成的\nhttps://zhuanlan.zhihu.com/p/61036165\n\n---\n\n你尝试了一下，然后就被 Vim 和 Latex 给劝退了。但是实际上，VS Code 完全能够替代 Vim，Markdown 在记笔记方面也完全能够替代 Latex。通过 VS Code 插件 HyperSnips for Math，你就可以像用 UtliSnips 一样使用各种神奇的 Snippets。\n\nHyperSnips 是由 [draivin](https://github.com/draivin) 开发的一个插件，致力于在 VS Code 中复原 UtliSnips 的功能。\n\nHyperSnips for Math 是我魔改过后的 HyperSnips，可以更方便地支持 Markdown 和 LaTeX 的数学功能。\n\n顺带一提，你还应该开启在 markdown 下的 **自动补全提示**, 请使用 `Shift + Ctrl + P` 然后输入 `open settings json` 打开配置文件, 然后加入以下部分:\n\n```json\n\"[markdown]\": {\n    \"editor.quickSuggestions\": true\n},\n```\n\n接下来就是简单地介绍一下 HyperSnips 的语法。\n\n先看个 **普通例子**:\n\n```hsnips\nsnippet RR \"R\" iAm\n\\mathbb{R}\nendsnippet\n```\n\n这是一个在数学环境中自动展开的 Snippet, 它有三个标示符 `iAm`, 分别代表 \"在词语内部也会触发\", \"自动展开\" 和 \"数学环境\".\n\n这个例子会在数学环境内, 自动将 `RR` 展开成为 `\\mathbb{R}`, 代表 \"实数\".\n\n再看个 **正则表达式** 的例子:\n\n``` hsnips\nsnippet `((\\d+)|(\\d*)(\\\\)?([A-Za-z]+)((\\^|_)(\\{\\d+\\}|\\d))*)/` \"Fraction no ()\" Am\n\\frac{``rv = m[1]``}{$1}$0\nendsnippet\n```\n\n其中 `rv = m[1]` 是 JavaScript 代码, 表示将正则表达式的第一个组 `m[1]` 输出给 \"返回值\" `rv`, 然后输出出去.\n\n这是一个在数学环境中自动展开的 Snippet, 它有两个标示符 'Am', 分别代表 '自动展开' 和 '数学环境'. 用处是:\n\n```\n1/    --->    \\frac{1}{}\n```\n\n它只会在数学环境 `$...$`, `$$...$$`, `\\(...\\)` 和 `\\[...\\]` 中自动展开。\n\n**还有 `${VISUAL}` 语法:**\n\n```hsnips\nsnippet fr \"frac\" iAm\n\\\\frac{${1:${VISUAL}}}{$2}\nendsnippet\n```\n\n这个语法会保存最近选中的内容 (5 秒内), 然后替换掉 `${VISUAL}` 部分.\n\n每个标志的解释：\n\n- `A`: 自动展开，不设置的话，就需要在自动补全的窗口展示出来后，按 Tab 或 Enter 来选择；\n- `i`: 词内展开，即可以在词语内部展开；\n- `w`: 词外展开，与词内展开相对；\n- `b`: 行首展开，只有在一行的开头，才会展开；\n- `M`: 多行模式，如果不设置，默认只会获取当前行文本，设置了的话就会获取多行文本来检测触发条件；\n- `m`: 数学模式，只会在数学环境 `$...$`, `$$...$$`, `\\(...\\)` 和 `\\[...\\]` 中自动展开。\n\n在 Snippet 的内容体里，可以使用 `$1`、`$2` 和 `${1:placeholder}` 这类的占位符，占位符可以通过 `Tab` 键向后跳转和 `Shift + Tab` 向前跳转。\n\n并且 Snippet 内容体还可以使用 JavaScript 语句，比如上文看见的 `\\frac{``rv = m[1]``}{$1}$0`。\n\n一些有用的变量定义如下：\n\n- `rv`: 返回值，在 Snippet 被触发的时候，会以里面的值替换代码块；\n- `t`: 占位符所包含文本组成的字符串数组，你可以用它来实现一些有趣的动态功能；\n- `m`: 正则表达式匹配组。`m[0]` 是正则表达式匹配到的全部具体内容，`m[1]` 开始就是每个组的具体内容；\n- `w`: 当前打开工作区的 URI 字符串；\n- `path`: 当前打开文件的 URI 字符串。\n\n举两个有趣的例子：\n\n```hsnips\nsnippet box \"Box\" A\n``rv = '┌' + '─'.repeat(t[0].length + 2) + '┐'``\n│ $1 │\n``rv = '└' + '─'.repeat(t[0].length + 2) + '┘'``\nendsnippet\n```\n\n这个例子可以生成一个「盒子」动态包裹住你输入的内容。\n\n```hsnips\nsnippet filename \"Current Filename\"\n``rv = require('path').basename(path)``\nendsnippet\n```\n\n这个例子表明你甚至可以使用 NodeJS 的库函数，进而实现非常强大的功能。你甚至能用 VS Code 的 API。\n\n\n## 五、延展阅读\n\n一份十分详尽的 LaTeX 2 介绍。\n\n---\n\n一份（不太）简短的 LATEX 2ε 介绍\nhttps://github.com/CTeX-org/lshort-zh-cn/releases/download/v6.03/lshort-zh-cn.pdf\n\n---\n\nWiki Book 上有关的介绍（英文）。\n\n---\n\nLaTeX/Mathematics\nhttps://en.wikibooks.org/wiki/LaTeX/Mathematics\n\n---\n\nOverleaf 家数学公式文档（英文）。\n\n---\n\nMathematical expressions - Overleaf, Online LaTeX Editor\nhttps://www.overleaf.com/learn/latex/Mathematical_expressions\n\n---\n\n\n## 六、参考文献\n\n1. 一份（不太）简短的 LATEX 2ε 介绍 - https://github.com/CTeX-org/lshort-zh-cn/releases/download/v6.03/\n2. LaTeX/Mathematics - https://en.wikibooks.org/wiki/LaTeX/Mathematics\n3. Mathematical expressions - Overleaf, Online LaTeX Editor - https://www.overleaf.com/learn/latex/Mathematical_expressions\n4. 怎么在 Word 中方便地输入数学公式？- https://www.zhihu.com/question/24613226\n5. Axmath和Mathtype主要有什么区别？为什么Mathtype卖的那么贵？- https://www.zhihu.com/question/55740822\n6. MathType - https://www.mathtype.cn/\n7. AxMath - https://www.amyxun.com/\n8. KaTeX - https://katex.org/\n9. MathJax - https://www.mathjax.org/\n10. Math Live - https://cortexjs.io/mathlive/demo/\n11. LaTeX 公式编辑器 - https://www.latexlive.com/home##\n12. Mathpix - https://mathpix.com/\n13. OrangeX4's HyperSnips - https://github.com/OrangeX4/OrangeX4-HyperSnips/blob/main/markdown.hsnips\n14. HyperSnips - https://github.com/draivin/hsnips\n\n\n## 七、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-5/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 5 期、写作：LaTeX 和 Markdown 中的数学公式和 HyperSnips 快捷输入 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-5/\n\n---\n","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"微积分知识点整理","url":"/post/cheatsheet-for-calculus/","content":"\n# 微积分知识点整理\n\n微积分知识点整理.\n\n<!--more-->\n\n## 常见不定积分\n\n* $\\displaystyle\\int a^x{\\rm d}x=\\frac{a^x}{\\ln a}+C$\n* $\\displaystyle\\int \\frac{1}{x}{\\rm d}x=\\ln|x|+C$\n* $\\displaystyle\\int \\ln x{\\rm d}x=x\\ln x-x+C$\n* $\\displaystyle\\int \\frac{1}{1+x^2}{\\rm d}x=\\arctan x+C$\n* $\\displaystyle\\int \\frac{1}{\\sqrt{1-x^2}}{\\rm d}x=\\arcsin x+C$\n* $\\displaystyle\\int -\\frac{1}{\\sqrt{1-x^2}}{\\rm d}x=\\arccos x+C$\n* $\\displaystyle\\int \\tan x{\\rm d}x=-\\ln|\\cos x|+C$\n* $\\displaystyle\\int \\cot x{\\rm d}x=-\\ln|\\sin x|+C$\n* $\\displaystyle\\int \\sec x{\\rm d}x=-\\ln|\\sec x+\\tan x|+C=\\frac{1}{2}\\ln\\left| \\frac{1+\\sin x}{1-\\sin x} \\right|+C$\n* $\\displaystyle\\int \\csc x{\\rm d}x=-\\ln|\\csc x-\\cot x|+C=\\ln\\left| \\tan \\frac{x}{2} \\right|+C$\n\n## 华里兹公式\n\n由区间再现公式 $\\displaystyle I_n=\\int_0^{\\frac{\\pi}{2}}\\sin^nx{\\rm d}x=\\int_0^\\frac{\\pi}{2}\\cos^nx{\\rm d}x, \\int_a^bf(x){\\rm d}x=\\int_a^bf(x){\\rm d}x=\\int_a^bf(a+b-x){\\rm d}x$\n\n$\\because\\displaystyle I_n'=\\int\\sin^nx{\\rm d}x=\\frac{1}{n}\\cos x\\sin^{n-1}x+\\frac{n-1}{n}I_{n-2}', \\quad n\\geq 2$\n\n$\\therefore\\displaystyle I_n=\\frac{n-1}{n}I_{n-2}, I_0=\\frac{\\pi}{2}, I_1=1$\n\n华里兹公式\n\n$\n\\therefore I_n=\n\\begin{cases}\n\\displaystyle\\frac{(n-1)!!}{n!!}=\\frac{(n-1)(n-3)\\times 2}{n(n-2)\\times 1}, &n \\text{ is odd} \\\\\n\\displaystyle\\frac{(n-1)!!}{n!!}\\times\\frac{\\pi}{2}=\\frac{(n-1)(n-3)\\times 1}{n(n-2)\\times 2}\\times\\frac{\\pi}{2}, &n \\text{ is even} \\\\\n\\end{cases}\n$\n\n当 $n$ 为奇数时:\n\n$\\therefore \\displaystyle \\int_{0}^{\\pi}\\sin^{n}x\\mathrm{d}x=2I_{n}, \\int_{0}^{\\pi}\\cos^{n}x\\mathrm{d}x=0$\n\n$\\therefore \\displaystyle \\int_{0}^{2\\pi}\\sin^{n}x\\mathrm{d}x=0, \\int_{0}^{2\\pi}\\cos^{n}x\\mathrm{d}x=0$\n\n当 $n$ 为偶数时:\n\n$\\therefore \\displaystyle \\int_{0}^{\\pi}\\sin^{n}x\\mathrm{d}x=2I_{n}, \\int_{0}^{\\pi}\\cos^{n}x\\mathrm{d}x=2I_{n}$\n\n$\\therefore \\displaystyle \\int_{0}^{2\\pi}\\sin^{n}x\\mathrm{d}x=4I_{n}, \\int_{0}^{2\\pi}\\cos^{n}x\\mathrm{d}x=4I_{n}$\n\n\n## 欧拉积分\n\n$\\Gamma$ 函数: $\\displaystyle\\Gamma(s)=\\int_0^{+\\infty}x^se^{-x}{\\rm d}x$\n\n1. $\\Gamma(s+1)=s\\cdot \\Gamma(s)$\n2. $\\Gamma(1)=1$\n3. $\\Gamma(n)=n!$\n4. $\\displaystyle x=t^2, \\Gamma(s)=2\\int_0^{+\\infty}t^{2s-1}\\cdot e^{-t^2}{\\rm d}t, \\Gamma(\\frac{1}{2})=\\frac{\\pi}{2}$\n5. $\\displaystyle x=p\\cdot t, \\Gamma(s)=p^s\\cdot \\int_0^{+\\infty}t^{s-1}e^{-pt}{\\rm d}t$\n\n$\\displaystyle \\int x^4e^{-x^2}{\\rm d}x$\n\n$B$ 函数: $\\displaystyle B(p,q)=\\int_0^1x^{p-1}\\cdot (1-x)^{q-1}{\\rm d}x$\n\n1. $B(p,q)=B(q,p)$\n2. $\\displaystyle B(p,q)=\\frac{p-1}{p+q-1}\\cdot B(p-1,q)$\n\n$\\displaystyle B(p,q)=\\frac{\\Gamma(p)\\Gamma(q)}{\\Gamma(p+q)}$\n\n或者说\n\n令 $x=\\cos\\theta$, 则 $\\displaystyle B(p,q)=2\\int_0^{\\frac{\\pi}{2}}\\cos^{2p-1}\\theta\\cdot\\sin^{2q-1}\\theta\\mathrm{d}\\theta$\n\n\n## 二重积分换元公式\n\n$\\displaystyle \\iint_{(\\sigma)}f(x,y)\\mathrm{d}x\\mathrm{d}y=\\iint_{(\\sigma')}f(x(u,v),y(u,v))\\left| \\frac{\\partial (x,y)}{\\partial (u,v)} \\right|\\mathrm{d}u\\mathrm{d}v$\n\n其中 $\\displaystyle J=\\frac{\\partial (x,y)}{\\partial (u,v)}=\\begin{vmatrix} x_{u} &x_{v} \\\\ y_{u} &y_{v} \\\\\\end{vmatrix}=\\frac{1}{\\displaystyle \\frac{\\partial (u,v)}{\\partial (x,y)}}=\\frac{1}{\\begin{vmatrix} u_{x} &u_{y} \\\\ v_{x} &v_{y} \\\\\\end{vmatrix}}$\n\n即使 $J=0$ 在某些点或某条直线上为零, 此式依然成立.\n\n其中, 对于极坐标 $\\begin{cases} x=\\rho\\cos\\theta \\\\ y=\\rho\\sin\\theta \\end{cases}$ 有 $|J|=\\rho$\n\n其中, 对于广义极坐标 $\\begin{cases} x=a\\rho\\cos\\theta \\\\ y=b\\rho\\sin\\theta \\end{cases}$ 有 $|J|=ab\\rho$\n\n\n## 三重积分换元公式\n\n同理有\n\n$\\displaystyle \\iiint_{(V)}f(x,y,z)\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z=\\iiint_{(V')}f(x(u,v,w),y(u,v,w),z(u,v,w))\\left| \\frac{\\partial (x,y,z)}{\\partial (u,v,w)} \\right|\\mathrm{d}u\\mathrm{d}v\\mathrm{d}w$\n\n其中 $\\displaystyle J=\\frac{\\partial (x,y,z)}{\\partial (u,v,w)}=\\begin{vmatrix} x_{u} &x_{v} &x_{w} \\\\ y_{u} &y_{v} &y_{w} \\\\ z_{u} &z_{v} &z_{w} \\\\\\end{vmatrix}=\\frac{1}{\\displaystyle \\frac{\\partial (u,v,w)}{\\partial (x,y,z)}}=\\frac{1}{\\begin{vmatrix} u_{x} &u_{y} &u_{z} \\\\ v_{x} &v_{y} &v_{z} \\\\ w_{x} &w_{y} &w_{z} \\\\\\end{vmatrix}}$\n\n对于柱面坐标 $\\begin{cases} x=\\rho\\cos\\theta \\\\ y=\\rho\\sin\\theta \\\\ z=z \\end{cases}$\n\n有 $\\displaystyle J=\\frac{\\partial (x,y,z)}{\\partial (\\rho,\\theta,z)}=\\begin{vmatrix} \\cos\\theta &-\\rho\\sin\\theta &0 \\\\ \\sin\\theta &\\rho\\cos\\theta &0 \\\\ 0 &0 &1 \\\\\\end{vmatrix}=\\rho$\n\n对于球面坐标 $\\begin{cases} x=r\\sin\\varphi\\cos\\theta \\\\ y=r\\sin\\varphi\\sin\\theta \\\\ z=r\\cos\\varphi \\end{cases}, (0\\leqslant \\varphi\\leqslant \\pi, 0\\leqslant \\theta\\leqslant 2\\pi)$\n\n有 $\\displaystyle J=\\frac{\\partial (x,y,z)}{\\partial (r,\\varphi,\\theta)}=\\begin{vmatrix} \\sin\\varphi\\cos\\theta &r\\cos\\varphi\\cos\\theta &-r\\sin\\varphi\\cos\\theta \\\\ \\sin\\varphi\\sin\\theta &r\\cos\\varphi\\sin\\theta &r\\sin\\varphi\\cos\\theta \\\\ \\cos\\varphi &-r\\sin\\varphi &0 \\\\\\end{vmatrix}=r^{2}\\sin\\varphi$\n\n\n## 三大积分公式\n\n三大积分公式: Green公式, Gauss 公式, 斯托克斯公式\n\n* Green公式 $\\displaystyle \\oint_\\Gamma P\\mathrm{d}x+Q\\mathrm{d}y=\\iint_{D_{xy}}\\left( \\frac{\\partial Q}{\\partial x} -\\frac{\\partial P}{\\partial y}  \\right)\\mathrm{d}x\\mathrm{d}y$\n* Gauss 公式 $\\displaystyle \\iiint \\left( \\frac{\\partial P}{\\partial x} +\\frac{\\partial Q}{\\partial y} +\\frac{\\partial R}{\\partial z}  \\right)\\mathrm{d}V=\\oiint_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}z\\mathrm{d}x+R\\mathrm{d}x\\mathrm{d}y$\n* 斯托克斯公式 $\\displaystyle \\oint_\\Gamma P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z=\\iint_\\Sigma \\begin{vmatrix}\t\\cos\\alpha &\\cos\\beta &\\cos\\gamma \\\\\\frac{\\partial }{\\partial x}  &\\frac{\\partial }{\\partial y}  &\\frac{\\partial }{\\partial z}  \\\\\tP &Q &R \\end{vmatrix}\\mathrm{d}S$\n\nGreen 公式和 Stokes 公式本质上是一样的, 只不过一个是二维情况一个是三维情况. 令 $\\cos\\gamma=1$, 则 Stokes 公式退化为 Green 公式.\n\n\n## Green公式\n\n$\\displaystyle \\oint_\\Gamma P\\mathrm{d}x+Q\\mathrm{d}y=\\iint_{D_{xy}}\\left( \\frac{\\partial Q}{\\partial x} -\\frac{\\partial P}{\\partial y}  \\right)\\mathrm{d}x\\mathrm{d}y$\n\n1. $D_{xy}$ 是连通的.\n2. $P(x,y), Q(x,y)$ 在 $D_{xy}$ 上连续可导.\n3. $\\Gamma$ 取正向, 即封闭区域始终在左边.\n\n**路径无关性质:**\n\n1. $\\displaystyle \\frac{\\partial Q}{\\partial x}=\\frac{\\partial P}{\\partial y}$\n2. $\\displaystyle \\oint_{\\Gamma}P\\mathrm{d}x+Q\\mathrm{d}y=0$\n3. $\\displaystyle \\int_{\\Gamma}P\\mathrm{d}x+Q\\mathrm{d}y$ 只与 $\\Gamma$ 的起点和终点有关 (与路径无关)\n4. $P\\mathrm{d}x+Q\\mathrm{d}y$ 是一个恰当微分, 即 $\\exist u=u(x,y)$ 使 $\\mathrm{d}u=P\\mathrm{d}x+Q\\mathrm{d}y$ 即 $\\displaystyle P=\\frac{\\partial u}{\\partial x}, Q=\\frac{\\partial u}{\\partial y}$\n\n\n## Gauss 公式\n\n$\\displaystyle \\oiint_\\Sigma P\\mathrm{d}y\\land\\mathrm{d}z+Q\\mathrm{d}z\\land\\mathrm{d}x+R\\mathrm{d}x\\land\\mathrm{d}y=\\iiint_{\\Omega} \\left( \\frac{\\partial P}{\\partial x} +\\frac{\\partial Q}{\\partial y} +\\frac{\\partial R}{\\partial z}  \\right)\\mathrm{d}V$\n\n方向为封闭曲面向外.\n\n用 nabla 算子表示:\n\n$\\displaystyle \\iiint_{(V)}\\nabla \\cdot \\vec{A}\\mathrm{d}V=\\oiint_{(S)}\\vec{A}\\cdot \\mathrm{d}\\vec{S}$\n\n其中 $\\displaystyle \\text{div}\\vec{A}=\\nabla \\cdot \\vec{A}=\\frac{\\partial P}{\\partial x} +\\frac{\\partial Q}{\\partial y} +\\frac{\\partial R}{\\partial z}$ 又称为散度.\n\n散度 $\\displaystyle \\text{div}\\vec{A}=\\lim_{(\\Delta V) \\to M}\\frac{1}{\\Delta V}\\oiint_{(\\Delta S)}\\vec{A}(M)\\cdot \\mathrm{d}\\vec{S}$\n\n可用中值定理和连续性证明它们相等.\n\n性质:\n\n- $\\text{div}(C\\vec{A})=C\\text{div}(\\vec{A})$\n- $\\text{div}(\\vec{A}+\\vec{B})=\\text{div}(\\vec{A})+\\text{div}(\\vec{B})$\n- $\\text{div}(u \\vec{A})=u\\text{div}\\vec{A}+\\nabla u\\cdot \\vec{A}$\n\n\n## Stokes 公式\n\n$\\displaystyle \\iint_\\Sigma \\begin{vmatrix}\t\\cos\\alpha &\\cos\\beta &\\cos\\gamma \\\\\\frac{\\partial }{\\partial x}  &\\frac{\\partial }{\\partial y}  &\\frac{\\partial }{\\partial z}  \\\\\tP &Q &R \\end{vmatrix}\\mathrm{d}S=\\oint_\\Gamma P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z$\n\n如果 $\\cos\\alpha, \\cos\\beta, \\cos\\gamma$ 取确定值, 就变成了第Ⅰ型曲面积分, 如果不取确定值, 就是第Ⅱ型曲面积分.\n\n方向为右手螺旋法则.\n\n用 nabla 算子表示:\n\n$\\displaystyle \\oint_{(C)}\\vec{A}\\cdot \\mathrm{d}\\vec{s}=\\iint_{(S)}(\\nabla \\times \\vec{A})\\cdot \\mathrm{d}\\vec{S}=\\iint_{(S)}(\\nabla \\times \\vec{A})\\cdot \\vec{\\tau}\\mathrm{d}S$\n\n其中 $\\text{rot}\\vec{A}=\\nabla \\times \\vec{A}$ 称为旋度\n\n证明的关键在于, 把空间曲线积分转化为平面曲线积分, 再用 Green 公式.\n","tags":["Study","Calculus"],"categories":["Study"]},{"title":"线性代数知识点整理","url":"/post/cheatsheet-for-linear-algebra/","content":"\n# 线性代数知识点整理\n\n线性代数知识点整理.\n\n<!--more-->\n\n## 求和运算法则\n\n* $\\displaystyle\\sum_{i=1}^nx_i=x_1+x_2+\\cdots +x_n$\n* $\\displaystyle\\sum_{i=1}^nkx_i=k\\sum_{i=1}^nx_i$\n* $\\displaystyle\\sum_{i=1}^n(x_i+y_i)=\\sum_{i=1}^nx_i+\\sum_{i=1}^ny_i$\n* $\\displaystyle\\sum_{i=1}^nx_i\\sum_{j=1}^my_j=\\sum_{j=1}^my_j\\sum_{i=1}^nx_i=\\sum_{i=1}^n\\sum_{j=1}^mx_iy_j=\\sum_{j=1}^m\\sum_{i=1}^nx_iy_j$\n* $\\displaystyle\\sum_{i=1}^nx_i\\sum_{j=1}^my_jz_{ij}=\\sum_{j=1}^my_j\\sum_{i=1}^nx_iz_{ij}=\\sum_{i=1}^n\\sum_{j=1}^mx_iy_jz_{ij}=\\sum_{j=1}^m\\sum_{i=1}^nx_iy_jz_{ij}$\n\n## 值域和零空间\n\n$A \\in \\mathbb{R}^{m \\times n}$ 的列向量的线性组合的所有向量的集合 $\\mathcal{R}(A)$ 称为 $A$ 的 **值域**.\n\n$\\mathcal{R}(A) = \\{ Ax | x \\in \\mathbb{R}^{n} \\}$\n\n$\\mathcal{R}(A)$ 是 $\\mathbb{R}^{m}$ 的子空间, 它的维数是 $A$ 的 **秩**.\n\n被 $A$ 映射成零的所有向量 $x$ 的集合 $\\mathcal{N}(A)$ 称为 $A$ 的 **零空间** 或 **核**.\n\n$\\mathcal{N}(A) = \\{ x | Ax = 0 \\}$\n\n它们之间的关系是\n\n$\\mathcal{N}(A) = \\mathcal{R}(A^{\\top})^{\\bot}$\n\n## 秩的性质\n\n- 初等行变换不改变矩阵的秩\n- 对于 $A \\in \\mathbb{R}^{m\\times n}, B \\in \\mathbb{R}^{n\\times r}$ 有\n  - $\\operatorname{rank}(A)+\\operatorname{rank}(B)-n\\le \\operatorname{rank}(AB)\\le \\min \\{ \\operatorname{rank}(A), \\operatorname{rank}(B) \\}$\n- 对于 $A \\in \\mathbb{R}^{m\\times n}, B \\in \\mathbb{R}^{m\\times n}$ 有\n  - $\\operatorname{rank}(A + B) \\le \\operatorname{rank}(A) + \\operatorname{rank}(B)$\n- 对于任意矩阵 $A$ 有\n  - $\\operatorname{rank}(A) = \\operatorname{rank}(A^{\\top}) = \\operatorname{rank}(A A^{\\top}) = \\operatorname{rank}(A^{\\top}A)$\n\n## 合同与相似\n\n设 $A,B\\in P^{n\\times n}$, 若存在可逆矩阵 $C\\in P^{n\\times n}$, 使得 $B=C^{\\top} AC$, 则称 $A$ 与 $B$ **合同**.\n\n实对称矩阵 $A$ 正定 $\\Leftrightarrow$ $A$ 与单位矩阵 $E$ 合同, 即存在可逆矩阵 $C$, 使 $A=C^TC$\n\n设 $A,B\\in P^{n\\times n}$, 若存在可逆矩阵 $C\\in P^{n\\times n}$, 使得 $B=C^{-1} AC$, 则称 $A$ 与 $B$ **相似**.\n\n这里的 $C$ 可以看作一个基 $B$ 到 $A$ 的过渡矩阵 (即 $\\alpha_{A} = C\\alpha_{B}$).\n\n## 特征值分解\n\n若方阵 $A$ 可以使用相似矩阵分解为 $A = Q\\Lambda Q^{-1}$, 其中 $\\Lambda$ 是对角矩阵, 且对角线上是它的特征值, $Q$ 是它的特征向量矩阵, 则称 $A$ 可以特征值分解.\n\n## 实对称矩阵\n\n- 所有特征值都为实数;\n- 不同特征值对应的特征向量互相正交;\n- $k$ 重特征值对应的线性无关的特征向量恰有 $k$ 个;\n- $n$ 阶实对称矩阵 $A$ 必可相似对角化，且对角阵上的元素即为特征值;\n- 任意矩阵 $A$, 都有 $A^{\\top}A$ 是一个实对称矩阵.\n\n## 实对称特征值分解\n\n若实对称矩阵 $A$ 可以使用相似矩阵分解为 $A = Q\\Lambda Q^{\\top}$, 其中 $\\Lambda$ 是对角矩阵, 且对角线上是它的特征值, $Q$ 是它的特征向量矩阵.\n\n我们还可以知道 $Q$ 是正交矩阵, 即满足 $Q^{\\top}Q = I$.\n\n其中 $\\Lambda = \\operatorname{diag}(\\lambda_1,\\cdots ,\\lambda_{n}), \\lambda_1 \\ge \\cdots \\ge \\lambda_{n}$, 且 $\\lambda_{i}$ 是特征多项式 $\\det (\\lambda I-A)$ 的根.\n\n从几何意义上来说, 可以看成是先用 $Q^{\\top}$ 进行旋转, 然后用 $\\Lambda$ 进行各个基向量方向的拉伸, 最后再使用 $Q$ 旋转恢复原样.\n\n## 奇异值分解\n\n对于 $A \\in \\mathbb{R}^{m \\times n}, \\operatorname{rank}A=r$, 则 $A$ 可以因式分解为 $A = U\\Sigma V^{\\top}$\n\n其中 $U \\in \\mathbb{R}^{m \\times r}$ 满足 $U^{\\top}U = I$, $V \\in \\mathbb{R}^{n \\times r}$ 满足 $V^{\\top}V = I$.\n\n而 $\\Sigma = \\operatorname{diag}(\\sigma_1,\\cdots ,\\sigma_{r})$ 满足 $\\sigma_1 \\ge \\cdots \\ge \\sigma_{r}$\n\n则称为 $A$ 的奇异值分解.\n\n$U$ 的列向量称为左奇异向量, $V$ 的列向量称为右奇异向量, $\\sigma_{i}$ 称为奇异值.\n\n$A$ 的奇异值分解和实对称矩阵 $A^{\\top}A$ 的特征值分解密切相关\n\n$A^{\\top}A = V\\Sigma^{2}V^{\\top} = \\begin{bmatrix} V & \\tilde{V} \\end{bmatrix} \\begin{bmatrix} \\Sigma^{2} & 0 \\\\ 0 & 0 \\\\\\end{bmatrix} \\begin{bmatrix} V & \\tilde{V} \\end{bmatrix}^{\\top}$\n\n同理可以用 $AA^{\\top}$ 算出左奇异向量 $U$\n\n并且我们还可以知道 $A^{\\top}A$ 或 $AA^{\\top}$ 的 特征值就是奇异值 $\\sigma_{i}$ 的平方.\n\n对于满秩实对称矩阵 $A$, 我们可以知道 $n = m = r$, 并且 $A = Q\\Lambda Q^{\\top}$, 则有\n\n$A^{\\top}A = Q\\Lambda Q^{\\top}Q\\Lambda Q^{\\top} = Q\\Lambda^{2}Q$\n\n所以我们可知此时 $Q = \\Sigma$ 与 $U = V = Q$, 即满秩实对称矩阵的奇异值分解就是特征值分解.\n\n## 伪逆\n\n令 $A = U\\Sigma V^{\\top}$ 为 $A$ 的奇异值分解, 则我们有 $A^{\\dagger} = V\\Sigma^{-1}U^{\\top}$, 称为 $A$ 的 **伪逆**. \n\n## 协方差矩阵\n\n假定我们现在有 $n$ 个样本, 其中每个样本 $x$ 都是一个 $d$ 维的随机变量, 每个分量分别是 $x_{k}, k=1,2,\\cdots,d$.\n\n那么协方差计算公式为\n\n$\\displaystyle \\sigma(x_{m}, x_{k}) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_{mi}-\\bar{x}_{m})(x_{ki}-\\bar{x}_{k})$\n\n相同随机变量的协方差即为方差.\n\n所以有协方差矩阵为\n\n$\\Sigma = \\begin{bmatrix} \\sigma(x_1,x_1) & \\cdots  & \\sigma(x_1,x_{d}) \\\\ \\vdots & \\ddots & \\vdots \\\\ \\sigma(x_{d},x_1) & \\cdots  & \\sigma(x_{d},x_{d}) \\\\\\end{bmatrix} \\in \\mathbb{R}^{d \\times d}$\n\n经过中心化之后的 $X$, 可以通过一种方式很快得算出协方差\n\n$\\displaystyle \\Sigma = \\frac{1}{n-1}X^{\\top}X$\n\n因此协方差矩阵是一个标准的实对称矩阵, 可以使用特征值分解等方式进行分析.\n\n## 多元正态分布\n\n假设向量 $x$ 服从均值向量为 $\\mu$, 协方差矩阵为 $\\Sigma$ 的多元正态随机分布, 则有\n\n$\\displaystyle p(x) = |2\\pi\\Sigma|^{-\\frac{1}{2}}\\exp (-\\frac{1}{2}(x-\\mu)^{\\top}\\Sigma^{-1}(x-\\mu))$\n\n我们知道协方差矩阵可以分解为 $\\Sigma = U\\Lambda U^{\\top} = (U\\Lambda^{\\frac{1}{2}})(U\\Lambda^{\\frac{1}{2}})^{\\top}$\n\n所以可以认为, 特征向量矩阵 $U$ 控制概率密度 **旋转** (rotation), 特征值矩阵 $\\Lambda$ 控制 **缩放** (scale), 均值向量 $\\mu$ 控制 **中心位置**.\n\n实际上, 由于 $\\Sigma = U\\Lambda U^{\\top}$, 我们可以知道 $\\Sigma^{-1} = U\\Lambda^{-1}U^{\\top} = (U\\Lambda^{-\\frac{1}{2}})(U\\Lambda^{-\\frac{1}{2}})^{\\top}$\n\n即 $\\Sigma^{-\\frac{1}{2}} = U\\Lambda^{-\\frac{1}{2}}$, 则有 $U\\Lambda^{-\\frac{1}{2}}$\n\n所以实际上 $\\Sigma^{-\\frac{1}{2}}(x-\\mu)$ 就是转为了标准多元正态分布的形式.\n","tags":["Study","Linear Algebra"],"categories":["Study"]},{"title":"概率论知识点整理","url":"/post/cheatsheet-for-probability-theory/","content":"\n# 概率论知识点整理\n\n概率论知识点整理.\n\n<!--more-->\n\n## 1. 条件概率\n\n**事件的差:**\n\n$A-B=A-AB=A\\bar{B}$\n\n**乘法公式:**\n\n$P(AB)=P(A)P(B|A)$\n\n**全概率公式:**\n\n$\\displaystyle P(B)=\\sum_{i=1}^{n}P(BA_{i})=\\sum_{i=1}^{n}P(A_{i})P(B|A_{i})$\n\n**贝叶斯公式:**\n\n$\\displaystyle P(A_{i}|B)=\\frac{P(A_{i}B)}{P(B)}=\\frac{P(A_{i})P(B|A_{i})}{P(B)}=\\frac{P(A_{i})P(B|A_{i})}{\\sum_{j=1}^{n}P(A_{j})P(B|A_{j})}$\n\n$\\displaystyle \\text{后验概率}=\\frac{\\text{先验概率}\\times \\text{似然度}}{\\text{证据概率}}$\n\n**独立性:**\n\n$P(AB)=P(A)P(B)$\n\n\n## 2. 离散型随机变量\n\n**琴生不等式:**\n\n利用琴生不等式有, 对于连续凸函数 $g$ 有\n\n$g(E(X))\\leqslant E(g(X))$\n\n例如有\n\n$\\displaystyle (E(X))^{2}\\leqslant E(X^{2})$ 和 $e^{E(X)}\\leqslant E(e^{X})$\n\n**方差:**\n\n$\\displaystyle \\mathrm{Var}(X)=D(X)=E[(X-E(X))^{2}]=E(X^{2})-[E(X)]^{2}$\n\n**Bhatia-Davis 不等式:**\n\n对于 $X\\in [a,b]$, 有\n\n$\\displaystyle \\mathrm{Var}(X)\\leqslant (b-E(X))(E(X)-a)\\leqslant (b-a)^{2}/4$\n\n**Bernoulli 分布:**\n\n分布列为 $P(X=1)=p, P(X=0)=1-p$, 记作 $X\\sim \\mathrm{Ber}(p)$\n\n有 $E(X)=p, \\mathrm{Var}(X)=p(1-p)$\n\n**二项分布:**\n\n重复进行了 $n$ 次 Bernoulli 试验, 记作事件 $A$, 随机变量 $X$ 表示事件 $A$ 发生的次数.\n\n分布列为 $\\displaystyle P(X=k)=\\binom{n}{k}p^{k}(1-p)^{n-k}$, 记作 $X\\sim B(n, p)$\n\n有 $E(X)=np, \\mathrm{Var}(X)=np(1-p)$\n\n用级数求和, 两边求导的方法进行计算证明. 用到二项展开式 $\\displaystyle (1+x)^{n}=\\sum_{i=1}^{n}\\binom{n}{k}x^{k}$\n\n**几何分布:**\n\n重复进行了 $n$ 次 Bernoulli 试验, 记作事件 $A$, 随机变量 $X$ 表示事件 $A$ 首次发生的试验次数.\n\n分布列为 $\\displaystyle P(X=k)=(1-p)^{k-1}p$, 记作 $X\\sim G(p)$\n\n有 $\\displaystyle E(X)=\\frac{1}{p}$ 和 $\\displaystyle \\mathrm{Var}(X)=\\frac{1-p}{p^{2}}$\n\n等比数列求和 $\\displaystyle S_{n}=a_1\\frac{1-q^{n}}{1-q}$\n\n依旧使用级数 $\\displaystyle (1-x)^{-1}=\\sum_{k=1}^{\\infty}x^{k}$ 和两边求导来证明.\n\n几何分布拥有无记忆性: $\\displaystyle P(X>m+n|X>m)=P(X>n)$\n\n**Pascal / 负二项分布:**\n\n重复进行了 $n$ 次 Bernoulli 试验, 记作事件 $A$, 随机变量 $X$ 表示事件 $A$ 第 $r$ 次发生的试验次数.\n\n分布列为 $\\displaystyle P(X=k)=\\binom{k-1}{r-1}p^{r-1}(1-p)^{k-r}\\cdot p=\\binom{k-1}{r-1}p^{r}(1-p)^{k-r}$, 则称 $X$ 为服从参数 $p$ 和 $r$ 的负二项分布.\n\n重点在于 $\\displaystyle (1-q)^{-r}=\\sum_{t=0}^{\\infty}\\binom{t+r-1}{r-1}q^{t}$, 即 $\\displaystyle p^{-r}=\\sum_{k=r}^{\\infty}\\binom{k-1}{r-1}(1-p)^{k-r}$\n\n有 $\\displaystyle E(X)=\\frac{r}{p}$ 和 $\\displaystyle \\mathrm{Var}(X)=\\frac{r(1-p)}{p^{2}}$\n\n证明的时候只要想办法往概率求和等于一上转化即可.\n\n还需要一个性质: $\\displaystyle \\frac{k}{r}\\cdot \\binom{k-1}{r-1}= \\binom{k}{r}$\n\n**泊松分布:**\n\n分布列为 $\\displaystyle P(X=k)=\\frac{\\lambda^{k}}{k!}e^{-\\lambda}$, 记作 $X\\sim P(\\lambda)$\n\n我们知道泰勒展开式 $\\displaystyle e^{\\lambda}=\\sum_{k=0}^{\\infty}\\frac{\\lambda^{k}}{k!}$\n\n有 $\\displaystyle E(X)=\\lambda$ 和 $\\displaystyle \\mathrm{Var}(X)=\\lambda$\n\n**泊松定理:**\n\n对任意给定的常数 $\\lambda>0$, $n$ 为任意正整数, 设 $np=\\lambda$, 则对任意给定非负整数 $k$ 有\n\n$\\displaystyle \\lim_{n \\to \\infty} \\binom{n}{k}p^{k}(1-p)^{n-k}=\\frac{\\lambda^{k}}{k!}e^{-\\lambda}$\n\n对于随机变量 $X\\sim B(n,p)$, 当 $n$ 较大而 $p$ 较小时, 令 $\\lambda=np$, 则有\n\n$\\displaystyle P(X=k)=\\binom{n}{k}p^{k}(1-p)^{n-k}\\thickapprox \\frac{\\lambda^{k}}{k!}e^{-\\lambda}$\n\n即可以用泊松分布来近似计算二项分布.\n\n\n\n## 3. 连续型随机变量\n\n**非负随机变量期望:**\n\n$\\displaystyle E[X]=\\int_{0}^{\\infty}P(X>t)\\mathrm{d}t$\n\n证明:\n\n首先观察得到 $\\displaystyle X=\\int_{0}^{X}1\\mathrm{d}t=\\int_{0}^{\\infty}1(X>t)\\mathrm{d}t$\n\n$\n\\begin{aligned}\nE[X]\n&=E[\\int_{0}^{\\infty}1(X>t)\\mathrm{d}t] \\\\\n&=\\int_{-\\infty}^{+\\infty}\\int_{0}^{\\infty}1(x>t)f(x)\\mathrm{d}t \\\\\n&=\\int_{0}^{+\\infty}[\\int_{-\\infty}^{+\\infty}1(X>t)f(x)\\mathrm{d}x]\\mathrm{d}t \\\\\n&=\\int_{0}^{+\\infty}[\\int_{-\\infty}^{t}1(X>t)f(x)\\mathrm{d}x+\\int_{t}^{+\\infty}1(X>t)f(x)\\mathrm{d}x]\\mathrm{d}t \\\\\n&=\\int_{0}^{+\\infty}[\\int_{t}^{+\\infty}f(x)\\mathrm{d}x]\\mathrm{d}t \\\\\n&=\\int_{0}^{+\\infty}P(X>t)\\mathrm{d}t \\\\\n\\end{aligned}\n$\n\n**均匀分布:**\n\n概率密度 $\\displaystyle f(x)=\\frac{1}{b-a}, x\\in [a,b]$, 则记作 $X\\sim U(a,b)$\n\n而分布函数则为 $\\displaystyle F(x)=\\frac{x-a}{b-a}, a<x<b$\n\n期望和方差分别为 $\\displaystyle E(X)=\\frac{a+b}{2}, \\mathrm{Var}(X)=\\frac{(b-a)^{2}}{12}$\n\n**指数分布:**\n\n$\\displaystyle f(x)=\\lambda e^{-\\lambda x}, x\\geqslant 0$, 而 $F(x)=1-e^{-\\lambda x}$, 记作 $X\\sim e(\\lambda)$\n\n期望和方差为 $\\displaystyle E(X)=\\frac{1}{\\lambda}, \\mathrm{Var}(X)=\\frac{1}{\\lambda^{2}}$\n\n证明用分部积分法.\n\n指数分布具有无记忆性, 且是唯一具有无记忆性的连续型随机变量:\n\n$\\displaystyle P(X>s+t|X>t)=P(X>s)$\n\n**正态分布:**\n\n概率密度为 $\\displaystyle f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}}$, 记作 $X\\sim N(\\mu, \\sigma^{2})$\n\n标准正态分布为 $\\displaystyle f(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^{2}}{2}}$, 记作 $X\\sim N(0,1)$\n\n期望和方差为 $E(X)=\\mu, \\mathrm{Var}(X)=\\sigma^{2}$\n\n**正态分布的估计:**\n\n对于标准正态分布 $X\\sim N(0,1)$ 和任意 $\\epsilon>0$, 有\n\n$\\displaystyle P(X\\geqslant \\epsilon)\\leqslant \\frac{1}{2}e^{-\\frac{\\epsilon^{2}}{2}}$\n\n还有 $\\displaystyle P(|X|\\geqslant \\epsilon)\\leqslant \\min\\{1, \\sqrt{\\frac{2}{\\pi}}\\frac{1}{\\epsilon}e^{-\\frac{\\epsilon^{2}}{2}}\\}$\n\n\n\n## 4. 多维随机变量及其分布\n\n**随机变量独立性:**\n\n$\\displaystyle F(x,y)=F_{X}(x)F_{Y}(y)$\n\n对于离散型随机变量来说, 即等价于 $p_{i,j}=p_{i\\cdot}p_{\\cdot j}$\n\n对于连续型随机变量来说, 即等价于 $f(x,y)=f_{X}(x)f_{Y}(y)$\n\n**二维正态分布:**\n\n令 $\\mu=\\begin{pmatrix} \\mu_{x} \\\\ \\mu_{y} \\\\\\end{pmatrix}$ 和 $\\Sigma=\\begin{pmatrix} \\sigma_{x}^{2} & \\rho\\sigma_{x}\\sigma_{y} \\\\ \\rho\\sigma_{x}\\sigma_{y} & \\sigma_{y}^{2} \\\\\\end{pmatrix}$\n\n则 $X$ 和 $Y$ 的联合概率密度函数为 \n\n$\\displaystyle f(x,y)=(2\\pi)^{-2/2}|\\Sigma|^{-\\frac{1}{2}}\\exp(-\\frac{1}{2}(\\xi-\\mu)^{T}\\Sigma^{-1}(\\xi-\\mu))$\n\n其中 $\\displaystyle \\Sigma^{-1}=\\frac{1}{(1-\\rho^{2})\\sigma_{x}^{2}\\sigma_{y}^{2}}\\begin{pmatrix} \\sigma_{y}^{2} & -\\rho\\sigma_{x}\\sigma_{y} \\\\ -\\rho\\sigma_{x}\\sigma_{y} & \\sigma_{x}^{2} \\\\\\end{pmatrix}$\n\n**极大极小分布:**\n\n假设 $X, Y$ 相互独立.\n\n极大分布:\n\n$\\displaystyle F_{Z}(z)=P(Z\\leqslant z)=P(\\max(X,Y)\\leqslant z)=P(X\\leqslant z, Y\\leqslant z)=F_{X}(z)F_{Y}(z)$\n\n极小分布:\n\n$\\displaystyle F_{Z}(z)=1-(1-F_{X}(z))(1-F_{Y}(z))$\n\n**和的分布:**\n\n对于 $Z=X+Y$,\n\n通用的有 $\\displaystyle F_{Z}(z)=\\iint_{x+y\\leqslant z}f(x,y)\\mathrm{d}x\\mathrm{d}y=\\int_{-\\infty}^{+\\infty}\\mathrm{d}x\\int_{-\\infty}^{z}f(x,u-x)\\mathrm{d}u=\\int_{-\\infty}^{z}\\int_{-\\infty}^{+\\infty}f(x,u-x)\\mathrm{d}x\\mathrm{d}u$\n\n两边求导可得 $\\displaystyle f_{Z}(z)=\\int_{-\\infty}^{+\\infty}f(x,z-x)\\mathrm{d}x$\n\n假设 $X, Y$ 相互独立, 有著名的卷积公式\n\n$\\displaystyle f_{Z}(z)=\\int_{-\\infty}^{+\\infty}f_{X}(x)f_{Y}(z-x)\\mathrm{d}x=\\int_{-\\infty}^{+\\infty}f_{X}(z-y)f_{Y}(y)\\mathrm{d}y$\n\n**乘除的分布:**\n\n$\\displaystyle f_{XY}(z)=\\int_{-\\infty}^{+\\infty}\\frac{1}{|x|}f(x, \\frac{z}{x})\\mathrm{d}x$\n\n$\\displaystyle f_{X/Y}(z)=\\int_{-\\infty}^{+\\infty}|x|f(x, xz)\\mathrm{d}x$\n\n**联合分布函数:**\n\n设有 $U=u(X,Y), V=v(X,Y)$\n\n$\\displaystyle f_{UV}(u,v)=f_{XY}(x(u,v), y(u,v))\\begin{vmatrix} \\frac{\\partial u}{\\partial x} & \\frac{\\partial u}{\\partial y} \\\\ \\frac{\\partial v}{\\partial x} & \\frac{\\partial v}{\\partial y} \\\\\\end{vmatrix}$\n\n**多维随机变量柯西不等式:**\n\n$\\displaystyle E[XY]\\leqslant \\sqrt{E[X^{2}]E[Y^{2}]}$\n\n**协方差:**\n\n定义协方差为 $\\displaystyle \\mathrm{Cov}(X,Y)=E[(X-E[X])(Y-E[Y])]=E[XY]-E[X]E[Y]$\n\n则有 $\\displaystyle \\mathrm{Var}(X+Y)=\\mathrm{Var}(X)+\\mathrm{Var}(Y)+2\\mathrm{Cov}(X,Y)$\n\n对任意 $X_1, X_2, Y$ 还有性质 $\\displaystyle \\mathrm{Cov}(X_1+X_2, Y)=\\mathrm{Cov}(X_1,Y)+\\mathrm{Cov}(X_2,Y)$\n\n并且 $\\displaystyle \\mathrm{Cov}(aX,bY)=ab\\mathrm{Cov}(X,Y)$\n\n若 $X$ 和 $Y$ 独立, 则 $\\mathrm{Cov}(X,Y)=0$, 反之则不然.\n\n**协方差不等式:**\n\n$\\displaystyle [\\mathrm{Cov}(X,Y)]^{2}\\leqslant \\mathrm{Var}(X)\\mathrm{Var}(Y)$, 当且仅当 $Y=aX+b$ 等号成立.\n\n**相关系数:**\n\n$\\displaystyle \\rho_{XY}=\\frac{\\mathrm{Cov}(X,Y)}{\\sqrt{\\mathrm{Var}(X)\\mathrm{Var}(Y)}}$\n\n**条件概率:**\n\n先有 $\\displaystyle f_{X|Y}(x|y)=\\frac{f(x,y)}{f_{Y}(y)}$\n\n再有 $\\displaystyle F_{X|Y}(x|y)=P(X\\leqslant x|Y=y)=\\int_{-\\infty}^{x}f_{X|Y}(u|y)\\mathrm{d}u$\n\n**乘法公式:**\n\n$\\displaystyle f(x,y)=f_{X}(x)f_{Y|X}(y|x)=f_{Y}(y)f_{X|Y}(x|y)$\n\n\n\n## 5. 集中不等式\n\n**Markov 不等式:**\n\n对任意随机变量 $X\\geqslant 0, \\epsilon>0$, 有\n\n$\\displaystyle P(X\\geqslant \\epsilon)\\leqslant \\frac{E(X)}{\\epsilon}$\n\n证明:\n\n$\\displaystyle E[X]=E[X|X\\geqslant \\epsilon]P(X\\geqslant \\epsilon)+E[X|X\\leqslant \\epsilon]P(X\\leqslant \\epsilon)\\geqslant \\epsilon P(X\\geqslant \\epsilon)$\n\n推论: 对于单调增的非负函数 $g$ 有 $\\displaystyle P(X\\geqslant \\epsilon)\\leqslant \\frac{E[g(X)]}{g(\\epsilon)}$\n\n**Chebyshev 不等式:**\n\n$\\displaystyle P(|X-\\mu|>\\epsilon)\\leqslant \\frac{\\mathrm{Var}(X)}{\\epsilon^{2}}$\n\n**Cantelli 不等式:**\n\n$\\displaystyle P(X-\\mu\\geqslant \\epsilon)\\leqslant \\frac{\\sigma^{2}}{\\sigma^{2}+\\epsilon^{2}}$ 和 $\\displaystyle P(X-\\mu\\leqslant -\\epsilon)\\leqslant \\frac{\\sigma^{2}}{\\sigma^{2}+\\epsilon^{2}}$\n\n证明过程中令 $Y=X-\\mu$, 并添加了一个 $t$ 变量, 用以之后求最值.\n\n**Chebyshev 不等式推论:**\n\n独立同分布随机变量 $E[X_{i}]=\\mu, \\mathrm{Var}(X_{i})\\leqslant \\sigma^{2}$\n\n$\\displaystyle P(|\\frac{1}{n}\\sum_{i=1}^{n}X_{i}-\\mu|\\geqslant \\epsilon)\\leqslant \\frac{\\sigma^{2}}{n\\epsilon^{2}}$\n\n**Young 不等式:**\n\n对于 $\\displaystyle \\frac{1}{p}+\\frac{1}{q}=1$, 有\n\n$\\displaystyle ab\\leqslant \\frac{1}{p}a^{p}+\\frac{1}{q}b^{q}$\n\n**Holder 不等式:**\n\n$E[|XY|]\\leqslant (E[|X|^{p}])^{\\frac{1}{p}}(E[|Y|^{q}])^{\\frac{1}{q}}$\n\n**Chernoff 不等式:**\n\n矩生成函数为 $M_{X}(t)=E[e^{tX}]$\n\nChernoff 方法为:\n\n$\\displaystyle P(X\\geqslant E[X]+\\epsilon)=P(e^{tX}\\geqslant e^{tE[X]+t\\epsilon})\\leqslant e^{-t\\epsilon-tE[X]}E[e^{tX}]$\n\n**Chernoff 引理:**\n\n对于 $X \\in [0,1]$ 的期望 $\\mu=E[X]$, 对任意 $t>0$ 有\n\n$\\displaystyle E[e^{tX}]\\leqslant \\exp(t\\mu+\\frac{t^{2}}{8})$\n\n使用凸函数性质 $e^{tX}=e^{tX+(1-X)0}\\leqslant Xe^{t}+(1-X)e^{0}$\n\n因此对 $X \\in [a,b]$ 有 $\\displaystyle E[e^{tX}]\\leqslant \\exp(\\mu t+\\frac{t^{2}(b-a)^{2}}{8})$\n\n**亚高斯随机变量:**\n\n将有界随机变量和高斯随机变量统一起来.\n\n若 $X$ 满足 $\\displaystyle E[e^{(X-E[X])t}]\\leqslant \\exp(\\frac{bt^{2}}{2})$\n\n则称为亚高斯随机变量.\n\n高斯分布是参数为 $\\sigma^{2}$ 的亚高斯分布.\n\n对于满足 $E[X_{i}]=0$ 的亚高斯随机变量有\n\n$\\displaystyle E[\\max_{i\\in [n]}X_{i}]\\leqslant \\sqrt{2b\\ln n}$\n\n根据 Jensen 不等式有 $\\displaystyle \\exp(tE[\\max_{i\\in [n]}X_{i}])\\leqslant E[\\exp(t \\max_{i\\in [n]}X_{i})]$\n\n\n\n## 6. 大数定理以及中心极限定理\n\n**依概率收敛:**\n\n$\\displaystyle \\lim_{n \\to \\infty} P(|X_{n}-a|<\\epsilon)=1$ 或 $\\displaystyle \\lim_{n \\to \\infty} P(|X_{n}-a|\\geqslant \\epsilon)=0$\n\n则称 $\\{X_{n}\\}$ 依概率收敛于 $a$, 记作 $X_{n}\\xrightarrow{P}a$\n\n**大数定律:**\n\n$\\displaystyle \\frac{1}{n}\\sum_{i=1}^{n}X_{i}\\xrightarrow{P}\\frac{1}{n}\\sum_{i=1}^{n}E[X_{i}]$\n\n即看 $\\displaystyle P(|\\frac{1}{n}\\sum_{i=1}^{n}(X_{i}-E[X_{i}])|\\geqslant \\epsilon)\\to 0$\n\n**Markov 大数定律:**\n\n$\\displaystyle \\frac{1}{n^{2}}\\mathrm{Var}(\\sum_{i=1}^{n}X_{i})\\to 0$\n\n**Chebyshev 大数定律:**\n\n$\\mathrm{Var}(X_{n})\\leqslant c$ 即 $\\displaystyle \\frac{c}{n\\epsilon^{2}}\\to 0$\n\n**辛钦大数定律:**\n\n每个随机变量的期望 $E[X_{i}]=\\mu$ 存在.\n\n**Bernoulli 大数定律:**\n\n对于 $X_{n}\\sim B(n,p)$ 可以看作是一系列的 Bernoulli 随机变量, 然后就有 $\\displaystyle \\frac{X_{n}}{n}\\xrightarrow{P}p$\n\n**判断随机变量序列满足大数定律:**\n\n独立同分布, 则用辛钦大数定律; 否则用 Markov 大数定律.\n\n**依分布收敛:**\n\n$\\displaystyle \\lim_{n \\to \\infty} F_{Y_{n}}(y)=F_{Y}(y)$\n\n**中心极限定理:**\n\n对于独立同分布的随机变量 $X_1, X_2,\\cdots,X_{n},\\cdots$ 的期望 $E[X_{i}]=\\mu$ 和方差 $\\mathrm{Var}(X_{i})=\\sigma^{2}$\n\n则 $\\displaystyle Y_{n}=\\frac{\\sum_{i=1}^{n}X_{i}-n\\mu}{\\sigma\\sqrt{n}}\\xrightarrow{d}N(0,1)$\n\n变形公式为:\n\n$\\displaystyle \\sum_{i=1}^{n}X_{i}\\xrightarrow{d}N(n\\mu,n\\sigma^{2})$ 和 $\\displaystyle \\frac{1}{n}\\sum_{i=1}^{n}X_{i}\\xrightarrow{d}N(\\mu,\\frac{\\sigma^{2}}{n})$\n\n\n\n## 7. 统计基本概念\n\n**样本均值:**\n\n$\\displaystyle \\bar{X}=\\frac{1}{n}\\sum_{i=1}^{n}X_{i}$\n\n且有 $\\displaystyle E[\\bar{X}]=\\mu, \\mathrm{Var}(\\bar{X})=\\frac{\\sigma^{2}}{n}, \\bar{X}\\xrightarrow{d}N(\\mu, \\frac{\\sigma^{2}}{n})$\n\n**样本方差:**\n\n$\\displaystyle S_{0}^{2}=\\frac{1}{n}\\sum_{i=1}^{n}(X_{i}-\\bar{X})^{2}=\\frac{1}{n}\\sum_{i=1}^{n}X_{i}^{2}-\\bar{X}^{2}$\n\n则有 $\\displaystyle E[S_{0}^{2}]=\\frac{n-1}{n}\\sigma^{2}$\n\n**修正后的样本方差:**\n\n$\\displaystyle S^{2}=\\frac{1}{n-1}\\sum_{i=1}^{n}(X_{i}-\\bar{X})^{2}$ 即 $\\displaystyle S^{2}=\\frac{n}{n-1}S_0^{2}$\n\n则有 $\\displaystyle E[S^{2}]=\\sigma^{2}$\n\n**样本 k 阶原点矩:**\n\n$\\displaystyle A_{k}=\\frac{1}{n}\\sum_{i=1}^{n}X_{i}^{k}$\n\n**样本 k 阶中心矩:**\n\n$\\displaystyle A_{k}=\\frac{1}{n}\\sum_{i=1}^{n}(X_{i}-\\bar{X})^{k}$\n\n**第 k 次序统计量:**\n\n$\\displaystyle F_{k}(x)=\\sum_{r=k}^{n}\\binom{n}{r}[F(x)]^{r}[1-F(x)]^{n-r}$\n\n$\\displaystyle f_{k}(x)=\\frac{n!}{(k-1)!(n-k)!}[F(x)]^{k-1}[1-F(x)]^{n-k}f(x)$\n\n**Beta 函数:**\n\n$\\displaystyle \\mathrm{Beta}(\\alpha_1, \\alpha_2)=\\int_{0}^{1}x^{\\alpha_1-1}(1-x)^{\\alpha_2-1}\\mathrm{d}x$\n\n**Gamma 函数:**\n\n$\\displaystyle \\Gamma(\\alpha)=\\int_{0}^{+\\infty}x^{\\alpha-1}e^{-x}\\mathrm{d}x$\n\n$\\Gamma(1)=1, \\Gamma(\\frac{1}{2})=\\sqrt{\\pi}, \\Gamma(\\alpha)=(\\alpha-1)\\Gamma(\\alpha-1), \\Gamma(n+1)=n!$\n\n$\\displaystyle \\mathrm{Beta}(\\alpha_1, \\alpha_2)=\\frac{\\Gamma(\\alpha_1)\\Gamma(\\alpha_2)}{\\Gamma(\\alpha_1+\\alpha_2)}$\n\n$\\displaystyle \\mathrm{Beta}(\\alpha_1, \\alpha_2)=\\frac{\\alpha_1-1}{\\alpha_1+\\alpha_2-1}\\mathrm{Beta}(\\alpha_1-1,\\alpha_2)$\n\n**Beta 分布:**\n\n$\\displaystyle f(x)=\\frac{x^{\\alpha_1-1}(1-x)^{\\alpha_2-1}}{\\mathrm{Beta}(\\alpha_1, \\alpha_2)}, x\\in (0,1)$\n\n记作 $X\\sim B(\\alpha_1,\\alpha_2)$\n\n有 $\\displaystyle E[X]=\\frac{\\alpha_1}{\\alpha_1+\\alpha_2}, \\mathrm{Var}(X)=\\frac{\\alpha_1\\alpha_2}{(\\alpha_1+\\alpha_2)^{2}(\\alpha_1+\\alpha_2+1)}$\n\n**均匀分布第 k 次序统计量:**\n\n若 $X_1,X_2,\\cdots,X_{n}$ 服从 $U(0,1)$, 则\n\n$\\displaystyle X_{(k)}\\sim B(k, n-k+1)$\n\n**Gamma 分布:**\n\n$\\displaystyle f(x)=\\frac{\\lambda^{\\alpha}}{\\Gamma(\\alpha)}x^{\\alpha-1}e^{-\\lambda x}, x>0$\n\n记作 $X\\sim \\Gamma(\\alpha, \\lambda)$\n\n有 $\\displaystyle E[X]=\\frac{\\alpha}{\\lambda}, \\mathrm{Var}(X)=\\frac{\\alpha}{\\lambda^{2}}$\n\n和指数分布比较类似.\n\nGamma 分布具有可加性: $\\displaystyle X+Y\\sim \\Gamma(\\alpha_1+\\alpha_2, \\lambda)$\n\n特别的, $X\\sim \\Gamma(\\frac{1}{2}, \\frac{1}{2})$ 有 $\\displaystyle f(x)=\\frac{1}{\\sqrt{2\\pi}}x^{-\\frac{1}{2}}e^{-\\frac{1}{2}x}, x>0$\n\n且有若 $X\\sim N(0,1)$, 则 $X^{2}\\sim \\Gamma(\\frac{1}{2}, \\frac{1}{2})$\n\n**卡方分布:**\n\n若 $X_1, X_2, \\cdots,X_{n}$ 是来自总体 $X\\sim N(0,1)$ 的一个样本, 称 $Y=X_1^{2}+X_2^{2}+\\cdots+X_{n}^{2}$ 为服从自由度为 $n$ 的 $\\chi^{2}$ 分布, 记作 $Y\\sim \\chi^{2}(n)$\n\n所以也就有 $Y\\sim \\Gamma(\\frac{n}{2}, \\frac{1}{2})$\n\n$\\displaystyle E[Y]=n, \\mathrm{Var}(Y)=2n$\n\n可加性: $X+Y\\sim \\chi^{2}(m+n)$\n\n若随机变量 $X\\sim N(0,1)$, 则 $E[X^{k}]=\\begin{cases} (k-1)!!, & k \\text{ is even} \\\\ 0, & k \\text{ is odd} \\end{cases}$\n\n**t 分布:**\n\n设 $X\\sim N(0,1)$ 和 $Y\\sim \\chi^{2}(n)$ 相互独立, 则称\n\n$\\displaystyle T=\\frac{X}{\\sqrt{Y / n}}$ 服从自由度为 $n$ 的 t 分布, 记作 $T\\sim t(n)$\n\n**F 分布:**\n\n设随机变量 $X\\sim \\chi^{2}(m)$ 和 $Y\\sim \\chi^{2}(n)$ 相互独立, 则称\n\n$\\displaystyle F=\\frac{X / m}{Y / n}$ 为服从自由度 $m, n$ 的 F 分布, 记作 $F\\sim F(m,n)$\n\n**五大抽样定理其一:**\n\n设 $X_1, X_2, \\cdots, X_{n}$ 是来自总体 $N(\\mu, \\sigma^{2})$ 的样本, 则有\n\n$\\displaystyle \\bar{X}=\\sum_{i=1}^{n}X_{i}\\sim N(\\mu, \\frac{\\sigma^{2}}{n})$, $\\displaystyle \\frac{\\bar{X}-\\mu}{\\sigma / \\sqrt{n}}\\sim N(0,1)$\n\n在知方差 $\\sigma$ 时能用于估计 $\\mu$; 知期望 $\\mu$ 时能用于估计 $\\sigma^{2}$.\n\n**五大抽样定理其二:**\n\n$\\displaystyle S^{2}=\\frac{1}{n-1}\\sum_{i=1}^{n}(X_{i}-\\bar{X})^{2}$\n\n则有 $\\displaystyle \\frac{(n-1)S^{2}}{\\sigma^{2}}\\sim \\chi^{2}(n-1)$\n\n即 $\\displaystyle \\frac{\\sum_{i=1}^{n}(X_{i}-\\bar{X})^{2}}{\\sigma^{2}}\\sim \\chi^{2}(n-1)$\n\n能用于估计方差 $\\sigma^{2}$\n\n**五大抽样定理其三:**\n\n$\\displaystyle \\frac{\\bar{X}-\\mu}{S / \\sqrt{n}}\\sim t(n-1)$\n\n可用于估计期望 $\\mu$\n\n**五大抽样定理其四:**\n\n设 $X_1,X_2,\\cdots,X_{m}$ 和 $Y_1,Y_2,\\cdots,Y_{n}$ 分别来自总体 $N(\\mu_{X}, \\sigma^{2}), N(\\mu_{Y}, \\sigma^{2})$, 其中两者方差一致, 则\n\n$\\displaystyle \\frac{\\bar{X}-\\bar{Y}-(\\mu_{X}-\\mu_{Y})}{\\sqrt{\\frac{(m-1)S_{X}^{2}+(n-1)S_{y}^{2}}{m+n-2}}\\sqrt{\\frac{1}{m}+\\frac{1}{n}}}\\sim t(m+n-2)$\n\n**五大抽样定理其五:**\n\n设 $X_1,X_2,\\cdots,X_{m}$ 和 $Y_1,Y_2,\\cdots,Y_{n}$ 分别来自总体 $N(\\mu_{X}, \\sigma_{X}^{2}), N(\\mu_{Y}, \\sigma_{Y}^{2})$, 其中两者方差不一定一致, 则\n\n$\\displaystyle \\frac{S_{X}^{2} / \\sigma_{X}^{2}}{S_{Y}^{2} / \\sigma_{Y}^{2}}\\sim F(m-1, n-1)$\n\n**分位点:**\n\n给定 $\\alpha\\in (0,1)$ 和随机变量 $X$, 称 $P(X>\\lambda_{\\alpha})=\\alpha$ 的实数 $\\lambda_{\\alpha}$ 为上侧 $\\alpha$ 分位点.\n\n\n## 8. 参数估计\n\n**矩估计:**\n\n使用样本 $k$ 阶矩和样本 $k$ 阶中心矩相等进行估计.\n\n**最大似然估计**\n\n似然函数 $\\displaystyle L(\\theta)=L(x_1,x_2,\\cdots,x_{n}; \\theta)=\\prod_{i=1}^{n}P(x_{i}; \\theta)$\n\n取其对数 $\\displaystyle \\ln L(\\theta)=\\sum_{i=1}^{n}\\ln P(x_{i};\\theta)$ 然后进行求导等于零\n\n并令其等于零, 即可解出 $\\hat{\\theta}$\n\n我们有 $\\hat{\\mu}=\\mu(\\hat{\\theta})$ 是 $\\mu$ 的最大似然估计.\n\n**无偏性:**\n\n$E[\\hat{\\theta}(X_1,X_2,\\cdots,X_{n})]=\\theta$\n\n则 $\\hat{\\theta}$ 是 $\\theta$ 的无偏估计.\n\n**有效性:**\n\n$\\mathrm{Var}(\\hat{\\theta})=E[(\\hat{\\theta}-\\theta)^{2}]$\n\n一般方差越小, 无偏估计越好.\n","tags":["Study","Probability"],"categories":["Study"]},{"title":"第 4 期、写作：TeX、LaTeX 与排版系统","url":"/post/lesson-zero-4/","content":"\n# 第 4 期、写作：TeX、LaTeX 与排版系统\n\n<!-- #! https://zhuanlan.zhihu.com/p/496078810 -->\n\n> \"Your paper makes no goddamn sense, but it's the most beautiful thing I have ever laid eyes on.\"  -- From r/ProgrammerHumor\n\n随着印刷技术的不断发展，排版显得愈发重要，我们今天所看见的书籍，都离不开排版技术。在固定的版面，**排版**（Typesetting）各种不同类型的资料，例如文字、数字、表格和图片等，以最合适的方式进行呈现。例如印刷品中的版面安排，网页中内容的摆布，为了让读者有更舒适的体验，就需要考虑排版相关的问题。\n\n现存的排版系统的 **设计理念** 主要有两种，第一类是「**所示即所得**」，可以直接修改字体、颜色，马上就能看见效果，这类排版系统的好处是初学者容易上手，而坏处是随着复杂程度的增加，花费在样式上的精力明显增大，这类排版系统主要代表就是微软的 Word 软件。第二类是「**样式与内容分离**」，内容用特定的「标记语言」进行纯文本书写，样式单独写在其他地方，以便作者可以专注于他们正在编写的内容，而不必同时注意其外观，这类排版系统主要代表就是 HTML，Markdown 和 LaTeX。\n\n除了设计理念，排版系统还在「**主要面向介质**」上有所区别。Word 和 LaTeX 主要面向印刷品，是写论文的主要手段；而 HTML 和 Markdown 主要面向网页浏览器，没有明显的分页机制，比较适合用来写网络文档和博客。\n\n这一期中，我们主要讲讲 LaTeX。**LaTeX** 是一种在学术界和印刷界十分出名的排版系统，它的入门难度较高，需要花费较多精力去学习枯燥的命令和语法，即使是微小的错误也会导致编译不通过。但是一旦掌握 LaTeX 的用法，编写长稿子或者书写数学公式都能熟练地迅速完成。\n\n<!--more-->\n\n\n## 一、简介\n\n### 1、TeX\n\n**TeX** 是高德纳（Donald E. Knuth）为排版文字和数学公式而开发的软件。1977 年，正在\n编写《计算机程序设计艺术》的高德纳意识到每况愈下的排版质量将影响其著作的发行，为扭转这种状况，他着手开发 TeX，发掘当时刚刚用于出版工业的数字印刷设备的潜力。1982 年，高德纳发布 TeX 排版引擎，而后在 1989 年又为更好地支持 8-bit 字符和多语言排版而予以改进。TeX 以其卓越的稳定性、跨平台能力和几乎没有 bug 的特性而著称。它的版本号不断趋近于 π，当前为 3.141592653。\n\n### 2、LaTeX\n\n**LaTeX** 是一种使用 TeX 程序作为排版引擎的 **格式**（format），可以粗略地将它理解成是对 TeX 的一层封装。「**格式**」定义了一组命令的代码集，高德纳本人还编写了一个简单的 **plain TeX** 格式，而 **LaTeX** 则是当今应用最广泛的 TeX 格式。\n\nLaTeX 由美国计算机科学家莱斯利·兰伯特（Leslie Lamport）在 20 世纪 80 年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由 TeX 所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。\n\n因此它非常适用于生成高印刷质量的科技和数学、物理文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。\n\n正是因为这些原因，理工科的论文编写，基本是强制使用 LaTeX，而不会用 Word 来编写。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220407152418.png)\n\n### 3、排版引擎\n\n**排版引擎**，是编译源代码并生成文档的程序，如 pdfTeX、XeTeX 和 LuaTeX 等。有时也称其为 **编译器**。\n\n如果我们将 plain TeX 与 LaTeX 的关系比作 C 和 C++ 的关系，那么 pdfTeX、XeTeX 和 LuaTeX 之间的关系就可以比作是 GCC、LLVM 和 Clang 之间的关系。\n\n- **pdfTeX**：直接生成 PDF，支持 micro-typography；\n- **XeTeX**：支持 Unicode、OpenType 与复杂文字编排（CTL），支持中文；\n- **LuaTeX**：支持 Unicode、OpenType，内联 Lua，支持中文。\n\n\n## 二、在线使用\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220407155429.png)\n\n在本地安装 LaTeX 开发环境是一个字面意义上的「大工程」。不仅配置起来繁琐，而且占用空间极大，大约在 3 到 5 GiB 左右。\n\n所以如果你只是想简单学习一下 LaTeX，可以选择 **Overleaf** 这类云端服务。这类云端服务的好处是有着完整的 LaTeX 环境，并且模板丰富，用户支持好。\n\n---\n\nOverleaf, Online LaTeX Editor\nhttps://www.overleaf.com/\n\n---\n\n但是 Overleaf 也有着一定的缺点，例如因为是国外的网站，国内用户在注册及使用的时候可能会碰到网络问题。部分大学也会搭建自己的 Overleaf 版本，例如南京大学的 [在线 LaTeX](https://tex.nju.edu.cn/).\n\n另外的缺点是，Overleaf 的编辑器使用体验并不佳，自动补全等功能也都仅仅是「可用」的程度，远远达不到「好用」的标准。使用本地的 VS Code 并配上 HyperSnips 等插件，可以让 LaTeX 数学公式的输入速度和准确率上升一个台阶。\n\n\n## 三、本地安装\n\n### 1、TeX 发行版（distribution）\n\n一个 TeX 发行版是 TeX 排版引擎、支持排版的文件（基本格式、LaTeX 宏包、字体等）以及一些辅助工具的集合。\n\n各式各样的 TeX 发行版经过十多年的发展，大浪淘沙，现今的两个主流发行版为：\n\n- **TeX Live** 由类 UNIX 系统上的 teTeX 发展并取而代之，最终成为「跨平台」的 TeX 发行版。TeX Live 自 2011 年起以年份作为发行版的版本号，保持了一年一更的频率。**MacTeX** 是 macOS（OS X）系统下的一个定制化的 TeX Live 版本，与 TeX Live 同步更新。\n\n- **MiKTeX** 是主要用于 Windows 平台的一个稳定发展的 TeX 发行版，和 TeX Live 相比，它只会安装用得到的宏包，所以体积较小。在中国大陆曾经发行过“CTeX 套装”，它是一个经过本地化配置的 MiKTeX，不过其配置较为过时，也不再有更新支持，使用起来可能有诸多问题，现已不推荐使用。\n\nTeX Live 和 MiKTeX 都集成了一个简单的 LaTeX 源代码编辑器 **TeXworks**（MacTeX 则集成了类似的 **TeXShop**）。用户在安装完毕后，可直接使用 TeXworks 编写和编译 LaTeX 源代码。但是我并不推荐使用这两个源代码编辑器，我们会在下文提到如何使用 **VS Code** 作为编辑器编写 LaTeX。\n\n我们推荐将 **TeX Live**、**XeTeX** 和 **VS Code** 作为 LaTeX 本地安装的选择，下文的安装指南均以其为标准。\n\n### 2、Windows 10 系统\n\n在 Windows 10 下安装 TeX Live，推荐使用「**镜像安装**」的方式。\n\n你可以在类似 **南京大学镜像站** 的镜像站，\n\n---\n\nNJU Mirror\nhttps://mirrors.nju.edu.cn/CTAN/systems/texlive/Images/\n\n---\n\n下载一个「巨大无比」的安装镜像，即 [texlive2022.iso 文件](https://mirrors.nju.edu.cn/CTAN/systems/texlive/Images/texlive2022-20220321.iso).\n\n双击打开下载的 ISO 文件，Windows 会自动挂载到虚拟光驱，然后弹出一个新的文件夹窗口。如果你安装了一些其他的压缩软件的话，ISO 文件也可能被当成了压缩文件，这时候你就需要将其「**完整解压**」到一个「**不含中文**」的文件夹下面。\n\n然后，右键菜单，选择「**以管理员身份运行**」`install-tl-windows.bat` 文件，稍等片刻，便会显示出一个窗口。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220407165944.png)\n\n保持默认配置，或者设置「不安装 TeXworks 编辑器」，然后安装即可。安装耗时较久，大概在半个小时左右，请耐心等待。\n\n### 3、Ubuntu 系统\n\nUbuntu 系统可以通过 `apt` 包管理器安装，即可以安装完整版的 TeX Live，也可以只安装自己需要的部分。\n\n- 安装完整版 TeX Live\n\n```bash\nsudo apt install texlive-full\n```\n\n- 安装部分 TeX Live（XeTeX + 中文支持 + Science 相关宏包）\n\n```bash\nsudo apt install texlive-xetex\nsudo apt install texlive-lang-cjk\nsudo apt install texlive-science\n```\n\n如果一切正常的话，这样就安装完毕了。\n\n### 4、macOS 系统\n\nmacOS 系统可以使用 Homebrew 来安装 MacTeX。\n\n- 安装完整版 MacTeX\n\n```sh\nbrew cask install mactex\n```\n\n- 安装基础版 BasicTeX，好处是占用空间小，但是会缺少很多包，需要手动安装，**不建议初学者尝试**。\n\n```sh\nbrew cask install basictex\n```\n\n### 4、VS Code 及 LaTeX Workshop 插件安装\n\n安装 VS Code 的方式已经在之前的博文中讲过了，可以去 [官网](https://code.visualstudio.com/Download) 下载。\n\n然后是安装 LaTeX Workshop 插件，在打开 VS Code 之后，点左侧的插件商店选项，搜索 `LaTeX Workshop`，然后安装即可。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220407172801.png)\n\n安装完成后，新建一个 `.tex` 文件，将以下内容复制进去，然后保存。\n\n```latex\n\\documentclass{ctexart}\n\\begin{document}\n你好，\\LaTeX{}!\n\\end{document}\n```\n\n接着点击左侧 TeX 面板的 `Build LaTeX` 和 `View LaTeX PDF` 即可。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220407172453.png)\n\n\n## 四、LaTeX 语法\n\n### 1、LaTeX 源代码结构\n\nLaTeX 源代码以一个 `\\documentclass` 命令作为开头，它指定了文档使用的 **文档类**。`\\begin{document}...\\end{document}` 环境当中的内容是文档正文。\n\n在 `\\documentclass` 和 `\\begin{document}` 之间的位置称为 **导言区**。在导言区中常会使用 `\\usepackage` 命令调用宏包，还会进行文档的全局设置，例如设置页面大小、页眉页脚样式、章节标题样式等等。\n\n接在 `%` 符号后面的内容是 **注释**，它不会在文档中被渲染出来。如果你想在文档中显示出 `%` 这个字符，可以在前面加 **反斜杠**，也就是 `\\%`。\n\n以 **反斜杠** 开头，以第一个 **空格或非字母** 字符结束的一串文字，被称为 **控制序列**，也可以称为 **命令** 或 **标记**，请注意命令是 **区分大小写** 的。\n\n```latex\n\\documentclass{...} % ... 为某文档类\n% 导言区\n\\begin{document}\n% 正文内容\n\\end{document}\n% 此后内容会被忽略\n```\n\n### 2、文档类\n\n一个最简单的英文文档是使用了 `\\documentclass{article}` 文档类的 latex 源码。\n\n```latex\n\\documentclass{article}\n\\begin{document}\n``Hello world!'' from \\LaTeX.\n\\end{document}\n```\n\n一个最简单的中文文档是使用了 `\\documentclass[UTF8]{ctexart}` 文档类的 latex 源码。\n\n```latex\n\\documentclass[UTF8]{ctexart}\n\\begin{document}\n“你好，世界！”来自 \\LaTeX{} 的问候。\n\\end{document}\n```\n\n其中 `[UTF8]` 是 **文档可选参数**，用以全局规定一些排版参数。\n\n另外的例子是，`[11pt,twoside,a4paper]` 指定纸张为 A4 大小，基本字号为 11pt，双面\n排版。\n\n更多相关参数可以参考后面的 **扩展阅读**。\n\n### 3、宏包\n\n在使用 LaTeX 时，时常需要依赖一些扩展来增强或补充 LaTeX 的功能，比如排版复杂的表\n格、插入图片、增加颜色甚至超链接等等。这些扩展称为宏包。\n\n调用宏包的方法非常类似调用文档类的方法：\n\n```latex\n\\usepackage[⟨options⟩]{⟨package-name⟩}\n```\n\n一些常见的宏包有：\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220407211116.png)\n\n内容来自 [latex-talk](https://github.com/stone-zeng/latex-talk)。\n\n### 4、谋篇布局\n\n一篇经典的包含各级标题的文章的结构就像这样。\n\n```latex\n\\documentclass[UTF8]{ctexart}\n\n% 导言区，只是定义一些信息，不会被渲染\n\\title{你好，world!}  % 标题\n\\author{Liam}  % 作者\n\\date{\\today}  % 时间设为今天\n\n% 正文内容\n\\begin{document}\n\n\\maketitle  % 渲染标题、作者和时间等信息\n\\tableofcontents  % 目录\n\n% 各级标题和内容\n\\section{你好中国}\n中国在East Asia.\n\n\\subsection{Hello Beijing}\n北京是capital of China.\n\n\\subsubsection{Hello Dongcheng District}\n\n\\paragraph{Tian'anmen Square}\nis in the center of Beijing\n\n\\subparagraph{Chairman Mao}\nis in the center of 天安门广场。\n\n\\subsection{Hello 山东}\n\n\\paragraph{山东大学} is one of the best university in 山东。\n\n\\end{document}\n```\n\n我们也可以使用 `\\include` 之类的命令进行 **分文档编译**。\n\n```latex\n\\documentclass{book}\n% 导言区，加载宏包和各项设置，包括参考文献、索引等\n\\usepackage{makeidx} % 调用 makeidx 宏包，用来处理索引\n\\makeindex % 开启索引的收集\n\\bibliographystyle{plain} % 指定参考文献样式为 plain\n\\begin{document}\n\\frontmatter % 前言部分\n\\maketitle % 标题页\n\\include{preface} % 前言章节 preface.tex\n\\tableofcontents\n\\mainmatter % 正文部分\n\\include{chapter1} % 第一章 chapter1.tex\n\\include{chapter2} % 第二章 chapter2.tex\n...\n\\appendix % 附录\n\\include{appendixA} % 附录 A appendixA.tex\n...\n\\backmatter % 后记部分\n\\include{epilogue} % 后记 epilogue.tex\n\\bibliography{books} % 利用 BibTeX 工具从数据库文件 books.bib 生成参考文献\n\\printindex % 利用 makeindex 工具生成索引\n\\end{document}\n```\n\n### 5、文本标记\n\n你可以使用一些特定的命令进行文本标记。\n\n- 加粗：`{\\bfseries ...}` 或 `\\textbf{...}`\n- 倾斜：`{\\itshape ...}` 或 `\\textit{...}`\n- 字号：`\\tiny`、`\\small`、`\\large`、`\\Large` 等\n- 换行：`\\\\`\n- 缩进：`\\indent`\n- 居中：`\\centering` 或 `center` 环境\n\n但是，我们 **非常不推荐** 这么做。\n\n还记得吗？我们使用 LaTeX 进行排版的理念是「样式与内容分离」。使用上面这些含有固定含义的文本标记实际上就 **破坏** 了这种理念。\n\n正确合理的做法有以下这些。\n\n- 强调文字（意大利体）：`\\emph{...}`\n- 摘要（居中，小字号，带有标题）：`abstract` 环境\n- 引用（左右边距较大）：`quote` 或 `quotation` 环境\n- 自定义新的命令、环境：`\\newcommand\\keyword[1]{\\textbf{#1}}`\n\n### 6、常用环境\n\n列表和枚举：\n\n```latex\n\\begin{enumerate}\n  \\item Da Vinci\n        \\begin{itemize}\n          \\item \\textit{The Last Supper}\n          \\item \\textit{Salvator Mundi}\n          \\item \\textit{Mona Lisa}\n        \\end{itemize}\n  \\item Shakespeare\n        \\begin{itemize}\n          \\item \\textit{Macbeth}\n          \\item \\textit{Hamlet}\n          \\item \\textit{King Lear}\n          \\item \\textit{Othello}\n        \\end{itemize}\n\\end{enumerate}\n```\n\n图片：\n\n```latex\n% 不是 graphics，放到导言区\n\\usepackage{graphicx}\n% 可以统一指定图片路径\n\\graphicspath{{./images/}}\n\n\\begin{figure}\n  \\centering\n  % 可指定宽度、高度等选项\n  \\includegraphics[...]{fudan-logo.pdf}\n  \\caption{Logo of Fudan University}\n  \\label{fig:fudan-logo}\n\\end{figure}\n```\n\n表格：\n\n```latex\n\\usepackage{booktabs}  % 三线表\n\\begin{table}\n  \\caption{Population Census of China}\n  \\label{tab:china-population}\n  % 列格式：c 居中，l 左对齐，r 右对齐\n  \\begin{tabular}{cc}\n    \\toprule\n    Year     & Population \\\\\n    \\midrule\n    1953     & 6.0        \\\\\n    ... 2020 & 14.1       \\\\\n    \\bottomrule\n  \\end{tabular}\n\\end{table}\n```\n\n定理：\n\n```latex\n\\usepackage{amsthm}\n% 需要预先定义\n\\newtheorem{theorem}{Theorem}\n\\newtheorem*{remark}{Remark}  % 不编号\n\n\\begin{theorem}[Fermat]\n  $a^n+b^n=c^n$ has no positive...\n\\end{theorem}\n\\begin{proof}\n  % 证明后面会有 QED 符号 \n  It's obvious.\n\\end{proof}\n\\begin{remark}\n  The cases $n=1$ and $n=2$...\n\\end{remark}\n```\n\n语法高亮：\n\n```latex\n\\usepackage{listings}\n\\usepackage{xcolor}\n\\lstset{\n    columns=fixed,       \n    numbers=left,                                        % 在左侧显示行号\n    frame=none,                                          % 不显示背景边框\n    backgroundcolor=\\color[RGB]{245,245,244},            % 设定背景颜色\n    keywordstyle=\\color[RGB]{40,40,255},                 % 设定关键字颜色\n    numberstyle=\\footnotesize\\color{darkgray},           % 设定行号格式\n    commentstyle=\\it\\color[RGB]{0,96,96},                % 设置代码注释的格式\n    stringstyle=\\rmfamily\\slshape\\color[RGB]{128,0,0},   % 设置字符串格式\n    showstringspaces=false,                              % 不显示字符串中的空格\n    language=c++,                                        % 设置语言\n}\n\n% 引入文件的写法\n% \\lstinputlisting[language=c++]{main.cpp}\n% 直接写法\n\\begin{lstlisting}\n  #include <iostream>\n  int main()\n  {\n      std::cout << \"Hello, World!\" << std::endl;\n  }  \n\\end{lstlisting}\n```\n\n\n## 五、延展阅读\n\n本篇博文很多都参考了 [曾祥东](https://github.com/stone-zeng/latex-talk) 的「现代 LaTeX 入门讲座」，十分推荐大家看一看。\n\n---\n\n现代 LaTeX 入门讲座\nhttps://github.com/stone-zeng/latex-talk\n\n---\n\n简易的 TeX 发行版安装指南。\n\n---\n\n当代 TeX 发行版超快速安装指南\nhttps://git.nju.edu.cn/atXYblip/install-latex-instantly\n\n---\n\n详细的 LaTeX 安装介绍。\n\n---\n\n一份简短的关于 LaTeX 安装的介绍\nhttps://mirrors.mit.edu/CTAN/info/install-latex-guide-zh-cn/install-latex-guide-zh-cn.pdf\n\n---\n\n一份十分详尽的 LaTeX 2 介绍。\n\n---\n\n一份（不太）简短的 LATEX 2ε 介绍\nhttps://github.com/CTeX-org/lshort-zh-cn/releases/download/v6.03/lshort-zh-cn.pdf\n\n---\n\n更详细的文档也可以看看 Overleaf 家的文档（英文）。\n\n---\n\nDocumentation - Overleaf, Online LaTeX Editor\nhttps://www.overleaf.com/learn\n\n---\n\n\n## 六、参考文献\n\n1. 便携式文档格式 - Wikipedia - https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F\n2. LaTeX - Wikipedia - https://zh.wikipedia.org/wiki/LaTeX\n3. 呈现与内容分离 - Wikipedia - https://zh.wikipedia.org/wiki/%E5%91%88%E7%8E%B0%E4%B8%8E%E5%86%85%E5%AE%B9%E5%88%86%E7%A6%BB\n4. Microsoft Word - Wikipedia - https://zh.wikipedia.org/wiki/Microsoft_Word\n5. amsmath 包使用手册 - http://static.latexstudio.net/article/2019/0204/amsmath-guide-zh-cn.pdf\n6. Documentation - Overleaf, Online LaTeX Editor - https://www.overleaf.com/learn\n7. 一份其实很短的 LaTeX 入门文档 - https://liam.page/2014/09/08/latex-introduction/\n8. 在 Ubuntu 中安装 TEX Live 2018 - https://stone-zeng.github.io/2018-05-13-install-texlive-ubuntu/\n9. 一份（不太）简短的 LATEX 2ε 介绍 - https://github.com/CTeX-org/lshort-zh-cn/releases/download/v6.03/\n10. 当代 TeX 发行版超快速安装指南 - https://git.nju.edu.cn/atXYblip/install-latex-instantly\n11. 一份简短的关于 LaTeX 安装的介绍 - https://mirrors.mit.edu/CTAN/info/install-latex-guide-zh-cn/install-latex-guide-zh-cn.pdf\n12. LaTeX 之代码语法高亮 - https://www.latexstudio.net/archives/5900.html\n13. 现代 LaTeX 入门讲座 - https://github.com/stone-zeng/latex-talk\n\n\n## 七、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-4/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 4 期、写作：TeX、LaTeX 与排版系统 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-4/\n\n---","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"第 3 期、写作：使用 Markdown 记笔记入门","url":"/post/lesson-zero-3/","content":"\n# 第 3 期、写作：使用 Markdown 记笔记入门\n\n<!-- #! https://zhuanlan.zhihu.com/p/496076040 -->\n\n我认为，**写作是一个优秀程序员必备的能力**。\n\n程序员光写出好的代码是不够的，要和他人有效地合作，你就需要通过 **书写文档** 的方式，来介绍你写出的代码。在一个团队里，更具有权势和影响的程序员，往往是那些表达能力强的程序员。如果你能够写出清晰的注释和文档，别人就能够更容易地理解你的代码，也就更容易采纳你的想法。\n\n如果 Linus Torvalds 只是埋头默默无闻地开发自己的操作系统，不与他人沟通，Linux 系统也就不太可能会像如今一般受人追捧。正是 Linus Torvalds 通过电子邮件和新闻组，以书面形式表达自己的想法，才吸引了全世界一大批的计算机天才的注意，共同协作完成了 GNU/Linux 这么伟大的项目。\n\n另外，除了技术文档，良好的写作能力也能够让程序员以 **书写博客** 的形式，持续地输出自己的观点，扩大自己的技术影响力。\n\n对于身处学术圈的计算机学生来说，**书写论文** 同样是一项需要写作能力的无比重要的能力。 **记笔记** 也不例外，一份让自己，甚至是让他人也能够清晰理解的笔记，同样需要良好的写作能力。\n\n锻炼写作能力的方法，就是 **多写**。可以通过报一些写作密集型的课程，或者坚持写日记或博客，写得越多，写作也就更容易，进一步又会写得更多，形成一个 **良性循环**。\n\n当前程序员，或者说计算机学生最常用的写作格式，应该是 **Markdown**，这也是我最推荐的写作格式。全世界最大的代码托管网站 GitHub 默认的文档书写语言是 Markdown；大部分自建博客框架如 Hexo，Hugo 都支持 Markdown 书写的博客；具有开源支持和简洁语法的 Markdown 也可以很方便地转化为其他格式，如 word、pdf 等；通过一些开源工具，我们也可以将 Markdown 格式的文章发布到知乎和公众号上，完美避免了针对不同平台重新书写的问题。\n\n<!-- more -->\n\n\n## 一、Markdown 简介\n\n**Markdown** 是一种 **轻量级标记语言**，创始人为约翰·格鲁伯。与 Word 和 PDF 这类二进制文档格式不同，Markdown 是一种纯文本文档格式，就像编程中可执行文件与源文件一般，有着明显的区别。\n\nMarkdown 允许我们使用易读易写的方式来编写文档，然后一般会被转为 HTML 网页格式进行渲染。Markdown 发明的目的就是创建一种「易于阅读」和「易于撰写」的纯文本格式，而不是像 HTML 和 Latex 一般，使用一些固定格式的指令，因为后者并不一目了然。\n\n不过这也意味着 Markdown 很多时候并不是像 Word 一般「所见即所得」的，更多时候是分成两栏，一栏用于写作，一栏用于预览。但是使用一些类似 Typora 的软件，也是可以实现「所见即所得」的，两种方式各有优劣，全看个人选择。\n\n\n## 二、Markdown 编辑器介绍\n\nMarkdown 是一种开源简洁的纯文本文档格式，这也就意味着存在多种多样的 Markdown 编辑器，并不唯一。在下面，我会介绍一些我常用的 Markdown 编辑器，当然你可以选择任何一款你喜欢的编辑器。\n\n### 1、桌面 PC 端\n\n#### 1.1 Visual Studio Code\n\n**Visual Studio Code** 默认支持 Markdown 语言。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221233356.png)\n\nVisual Studio Code 默认支持 Markdown 语言，只需要打开一个 `.md` 后缀的 Markdown 文件，再按下快捷键 `Ctrl + K + V` 就可以显示。\n\n并且，通过一些其他插件，如 `Markdown Preview Enhanced` 和 `Markdown All in One`，就可以有更好的 Markdown 编辑体验。\n\n如果你需要「所见即所得」功能，也可以试试 `Milkdown` 插件。\n\n顺带一提，使用 VS Code 写 Markdown 最大的好处就是：**你可以使用你熟悉的 VS Code 快捷键，并且有着庞大的优秀的第三方插件**。我至今依然是使用 VS Code 来编写 Markdown 文件。\n\nVS Code 完全免费。\n\n---\n\nVisual Studio Code - Code Editing. Redefined\nhttps://code.visualstudio.com/\n\n---\n\n#### 1.2 Typora\n\n**Typora** 也是一款很受欢迎的 Markdown 编辑器。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220305155534.png)\n\nTypora 主打极简风格，从图片也可以看出来，Typora 显得十分「简洁」。同时，Typora 也是一款「所见即所得」的 Markdown 编辑器，如果你需要类似 Word 的体验，可以来尝试一下 Typora。\n\n不过 Typora 有一个巨大的缺点，就是它并不是免费的。Typora 已经开始收费了，并且售价为「89 元」，在一众免费编辑器面前，显得并不便宜，不过这也就见仁见智了。\n\n---\n\nTypora 官方中文站\nhttps://typoraio.cn/\n\n---\n\n\n#### 1.3 Obsidian\n\n**Obsidian** 是另一种风格的 Markdown 编辑器。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220305160353.png)\n\nObsidian 并不是纯粹的 Markdown 编辑器，虽然它在 Markdown 编辑方式方面和 VS Code 比较相似，都是通过双栏实时显示渲染结果。\n\n但是 Obsidian 比较推崇「双向链接」这个概念，通过笔记之间的相互引用，形成像图中所展现的「知识网络」结构，而不是传统基于文件夹的「树状笔记」结构。\n\nObsidian 基本上是免费的，你可以免费地使用自己的 Git 服务进行云托管，也可以选择 Obsidian 的收费云存储功能。\n\n---\n\nObsidian\nhttps://obsidian.md/\n\n---\n\n\n### 2、Android 端\n\n**坚果云 Markdown** 是一款支持 Android 端的 Markdown 编辑器。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220305162603.png)\n\n坚果云 Markdown 是一款支持 Android 端的 Markdown 编辑器。虽然它也算是坚果云用来推广自家的云服务的免费 App，但是它确实没有广告，体验也还可以，在 Android 平台下也算是比较少见了。所以我也在这里推荐 Android 端用户使用坚果云的 Markdown 编辑器。\n\n坚果云 Markdown 是免费的，当然你可以选择付费使用它提供的云存储功能。\n\n---\n\n坚果云 Markdown\nhttps://www.jianguoyun.com/static/html/markdown-landing/index.html\n\n---\n\n\n### 3、iOS 端\n\n**MWeb** 是我在 iOS 平板端常用的一款 Markdown 编辑器。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/0.png)\n\nMWeb 拥有着 Markdown 编辑和预览的能力，并且体验还不错。\n\n在一众收费的 iOS 应用中，MWeb 显得比较良心。MWeb 的基础使用是免费的，虽然它的 iCloud 云存储功能仍然是要收费的。\n\n---\n\nMWeb - 专业的Markdown写作、记笔记、静态博客生成软件 - MWeb\nhttps://zh.mweb.im/\n\n---\n\n\n### 4、Web 端\n\n**马克飞象** 是为印象笔记开发的在线 Markdown 编辑器。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220305164934.png)\n\n如果你想在线体验一下 Markdown 的语法，可以试试这个网站。当然，如果你不使用印象笔记，还是不要用它来进行真正的写作，因为用它只能将文件内容保存到印象笔记中，或者你只能使用复制粘贴把里面的内容保存到本地。\n\n---\n\n欢迎使用马克飞象 - 马克飞象 - 专为印象笔记打造的 Markdown 编辑器\nhttps://maxiang.io/\n\n---\n\n\n\n## 三、Markdown 语法\n\nMarkdown 有着非常简洁的语法，不过由于它的自由性，Markdown 也产生了许多变体，如 GitHub Flavored Markdown (GFM) 和 Pandoc。\n\n不过这些也暂且不论，我们就先来看看 Markdown 通用的基础语法。\n\n纯粹的 Markdown 语法其实非常简单，70 行的语法介绍就可以写完。以下的语法基于 **VS Code** 与 **Markdown Preview Enhanced 插件** 作为 Markdown 编辑器进行介绍。\n\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n每写完一个段落要隔一行空行。\n\n就像这样，隔了一行空行。\n\n---\n\n分割线\n\n**重点加粗**\n\n*斜体*\n\n~~删除线~~\n\n---\n\n列表：\n\n* 无序列表\n  * 嵌套无序列表\n  * 嵌套无序列表\n* 无序列表\n* 无序列表\n\n1. 有序列表 1\n   1. 嵌套有序列表 1\n   2. 嵌套有序列表 2\n2. 有序列表 2\n3. 有序列表 3\n\n---\n\n引用文本：\n\n> 引用别人说的话\n> 就这样写\n> By. OrangeX4\n\n---\n\n这是 `行内代码` 语法。\n\n代码块语法：\n\n''' python\nprint(\"Hello，World!\")\n'''\n\n请将 ' 替换成 `。\n\n---\n\n[超链接名称](链接地址)\n\n![图片提示语](图片地址)\n\n---\n\n表格：\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| 内容 | 内容 |\n\n---\n\n注释：\n\n<!-- 你看不见我 -->\n```\n\n### 标题\n\n你可以用\n\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n段落。\n```\n\n或\n\n``` markdown\n一级标题\n=======\n\n二级标题\n-------\n```\n\n的方式表示标题，个人更推荐前一种方式。\n\n### 段落\n\n```markdown\n段落和段落之间要隔一行。\n\n就像这样。\n```\n\n### 分割线\n\n``` markdown\n三条横线 (或更多的横线) 表示分割线。\n\n---\n\n就像这样。\n```\n\n![](https://pic2.zhimg.com/80/v2-35c44fb7437e3c4e676e0f0af8cd5045_720w.png)\n\n\n### 加粗，斜体和删除线\n\n做笔记的时候，我们常常会有这样的要求，\"加粗，斜体和删除线\"，作为笔记的\n\n``` markdown\n**重点加粗**\n\n*斜体*\n\n~~删除线~~\n```\n\n**Markdown Preview Enhanced 拓展功能：**\n\n``` markdown\n==高亮==\n```\n\n![](https://pic2.zhimg.com/80/v2-a81b2adc3d8820855e1c6a761d3bdb1d_720w.png)\n\n\n**快捷键：**\n\n选中文本之后，按下 `Ctrl + B` 可以给选中文本加粗。\n\n同理 `Ctrl + I` 可以让选中文本变为斜体。\n\n\n### 列表\n\n列表是记笔记时非常基本的元素，在 Markdown 中，可以用很方便的格式书写列表：\n\n``` markdown\n* 无序列表\n  * 嵌套无序列表\n  * 嵌套无序列表\n* 无序列表\n* 无序列表\n\n1. 有序列表 1\n   1. 嵌套有序列表 1\n   2. 嵌套有序列表 2\n2. 有序列表 2\n3. 有序列表 3\n```\n\n**Markdown Preview Enhanced 拓展功能：**\n\n``` markdown\n任务列表：\n\n- [x] 已经完成的事 1\n- [x] 已经完成的事 2\n- [x] 已经完成的事 3\n- [ ] 仍未完成的事 4\n- [ ] 仍未完成的事 5\n```\n\n![](https://pic4.zhimg.com/80/v2-dceae97b65a98286e995a6f59b1989b3_720w.png)\n\n**快捷键：**\n\n要进行**缩进** （书写嵌套列表），你可以使用 VS Code 的快捷键 `Ctrl + [` 和 `Ctrl + ]`。\n\n这个快捷键可以将代码向左或向右进行缩进。\n\n\n### 引用和代码\n\n``` markdown\n引用文本：\n\n> 引用别人说的话\n> 就这样写\n> By. OrangeX4\n\n这是 `行内代码` 语法。\n\n代码块语法：\n\n''' python\nprint(\"Hello，World!\")\n'''\n\n注意要将 ' 替换成 `。\n```\n\n![](https://pic1.zhimg.com/80/v2-bdf324d9b4e6b5dc60337a4db3255a48_720w.png)\n\nMarkdown Preview Enhanced 拓展功能：\n\n```\n代码行数的显示：\n\n''' javascript {.line-numbers}\nfunction add(x，y) {\n  return x + y\n}\n'''\n\n注意要将 ' 替换成 `。\n```\n\n![](https://pic1.zhimg.com/80/v2-cfcbfe6cf86e1ecdd5707549f12215e8_720w.png)\n\n\n### 超链接和图片\n\n你可以用下面的语法插入超链接和图片：\n\n``` markdown\n[超链接名称](链接地址)\n\n![图片提示语](图片地址)\n\n例如，可以使用网址和图床：\n\n[OrangeX4's Blog](https://orangex4.cool/)\n\n![OrangeX's Avatar](https://orangex4.cool/images/icons/profile.jpg)\n\n也可以在本地用相对地址：\n\n[Other](other.md)\n\n![OrangeX's Avatar](images/profile.jpg)\n```\n\n![](https://pic2.zhimg.com/80/v2-8bc75ba8206a33037251aca5959bd931_720w.png)\n\n\n### 剪贴板图片插入\n\n看了上面的插入图片语法，也许你会觉得，「这也太麻烦了」。\n\n就插入一张图片，还要手动将图片上传到网上。或者把图片保存到本地，还要进行移动图片重新命名这类繁杂的工作。\n\n能不能像 Word 那样，直接 **剪贴板粘贴图片** 呢？实际上是可以的。\n\n只要安装了 **Paste Image** 插件，我们就可以使用 `Ctrl + Alt + V` 进行图片的粘贴。\n\n不过在正式使用之前，要做一点小调整：\n\n按下 `Ctrl + ,` 打开设置窗口，输入 `Paste Image Path` 并搜索，将框内的文本改成 `${currentFileDir}/images`。\n\n![](https://pic2.zhimg.com/80/v2-c35303b43639b37a18b8893e906d7435_720w.png)\n\n注意标题是 **Paste Image：Path**。\n\n设置好之后，就可以在 VS Code 中使用剪贴板粘贴功能了。**按下快捷键 `Ctrl + Alt + V`**，就能把图片自动保存到当前目录下，并以正确的格式粘贴到当前的 Markdown 文件中。\n\n### 表格\n\n你可以很方便地在做笔记的时候加入表格：\n\n``` markdown \n表格：\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| 内容 | 内容 |\n```\n\n**Markdown Preview Enhanced 拓展功能：**\n\n``` markdown \n拓展语法：\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| >    | 内容 |\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| ^    | 内容 |\n```\n\n![](https://pic4.zhimg.com/80/v2-fe477e9335bbff718c658057a86e0307_720w.png)\n\n\n**快捷键：**\n\n自动表格对齐：`Shift + Alt + F`\n\n### 注释\n\n注释不会被渲染出来. \n\n你可以随手做点草稿，如果还想保留着，但是不显示，就可以按下**快捷键** `Ctrl + \\` **将当前行注释 / 反注释**。\n\n``` markdown\n注释：\n\n<!-- 你看不见我 -->\n\n<!-- 多行注释\n就像这样 -->\n```\n\n<!-- $ -->\n\n## 四、延展阅读\n\n菜鸟教程上的 Markdown 教程。\n\n---\n\nMarkdown 教程 | 菜鸟教程\nhttps://www.runoob.com/markdown/md-tutorial.html\n\n---\n\n关于「双向链接」。\n\n---\n\n2020年，或许你应当试试这样记笔记\nhttps://idealclover.top/archives/625/\n\n---\n\n我的一篇知乎文章。\n\n---\n\n教程向: 在 VS Code 中用 Markdown 做「数字化」学习笔记\nhttps://zhuanlan.zhihu.com/p/366596107\n\n---\n\n\n## 五、参考文献\n\n1. 《软件随想录》 - 「给计算机系学生的建议」 - 「毕业前练好写作」\n2. Markdown - 维基百科，自由的百科全书 - https://zh.wikipedia.org/wiki/Markdown\n3. Markdown 教程 | 菜鸟教程 - https://www.runoob.com/markdown/md-tutorial.html\n4. 怎样引导新手使用 Markdown？ - 知乎 - https://www.zhihu.com/question/20409634\n5. Typora 官方中文站 - https://typoraio.cn/\n6. Obsidian - https://obsidian.md/\n7. Visual Studio Code - Code Editing. Redefined - https://code.visualstudio.com/\n8. 2020年，或许你应当试试这样记笔记 - idealclover - https://idealclover.top/archives/625/\n9. 坚果云 Markdown - https://www.jianguoyun.com/static/html/markdown-landing/index.html\n10. MWeb - 专业的Markdown写作、记笔记、静态博客生成软件 - MWeb - https://zh.mweb.im/\n11. 欢迎使用马克飞象 - 马克飞象 - 专为印象笔记打造的Markdown编辑器 - https://maxiang.io/\n12. 教程向: 在 VS Code 中用 Markdown 做「数字化」学习笔记 - https://zhuanlan.zhihu.com/p/366596107\n\n\n## 六、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-3/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 3 期、写作：使用 Markdown 记笔记入门 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-3/\n\n---\n\n\n","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"第 2 期、在编程之前：使用 VS Code 开发 C、C++ 与 Python","url":"/post/lesson-zero-2/","content":"\n# 第 2 期、在编程之前：使用 VS Code 开发 C、C++ 与 Python\n\n<!-- #! https://zhuanlan.zhihu.com/p/496072797 -->\n\nVS Code 并不是针对某一种语言而开发的，这也意味着 VS Code 并不是开箱即用的。想要让 VS Code 支持某种语言的开发，你需要自己手动安装对应的开发环境，并在 VS Code 中安装对应的插件。\n\n比较麻烦的就是 C 和 C++ 这类传统的编译型语言在 Windows 下开发环境的搭建，这也是本文的重点；而 Python 这类解释型语言开发环境的搭建就显得比较简单。\n\n<!-- more -->\n\n\n## 一、Windows 下 VS Code / C++ 开发环境最简单的搭建方式\n\n### 1、下载工具\n\n如果你使用 Windows 系统，想要以最快的方式搭建 VS Code / C++ 开发环境，你可以试试这个 [小工具](https://sdchao.lanzoui.com/iEeFip9ciwb)：\n\n---\n\nAutoVsCEnv_WPF V1.994.zip\nhttps://sdchao.lanzoum.com/iB7dE01231be\n\n---\n\n解压后，打开 `AutoVsCEnv_WPF.exe` 可执行文件，就会显示如下界面\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303200923.png)\n\n### 2、选择 MinGW 安装位置\n\n只需要选择一个平常软件安装的地方就可以了。\n\n比如对我来说就是: `D:\\Program\\MinGW`\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303201325.png)\n\n### 3、选择项目文件夹位置\n\n项目文件夹很重要，需要选择一个你容易找到的位置来存放。比如对我来说就是: `D:\\Project\\Cpp`。\n\n之后写 C++ 代码都要把文件放在这个文件夹里面，否则 VS Code 无法识别。\n\n如果你真的需要多个文件夹，可以复制这个文件夹里面的 `.vscode` 文件夹到其他位置。`.vscode` 文件夹保存有相应的 VS Code 配置。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303201353.png)\n\n# 4、用 VS Code 打开项目文件夹\n\n在 VS Code 打开你的项目文件夹，VS Code 就会自动提醒你安装插件，比如 `C/C++` 之类的，点确定就好。\n\nVS Code 推荐的插件一般直接安装就好，不会出什么差错。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303201656.png)\n\n## 5、运行 test.cpp\n\n在 VS Code 点开 `test.cpp`，按下 `F5`，如果能正常运行的话，恭喜你，你已经配置成功了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303201733.png)\n\n## 6、修改 launch.json 和 tasks.json\n\n但是先别急着高兴，为了一个更好的开发体验，你还需要替换一处文件: \n\n将 `.vscode/tasks.json` 里的内容替换为:\n\n```json\n{  \n  \"version\": \"2.0.0\",  \n  \"command\": \"g++\",  \n  \"type\": \"shell\",  \n  \"presentation\": {  \n    \"echo\": true,  \n    \"reveal\": \"never\",\n    \"focus\": false,  \n    \"panel\": \"shared\",  \n    \"showReuseMessage\": true,  \n    \"clear\": false  \n  },  \n  \"args\": [\"-m32\",\"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}.exe\"],  \n  \"problemMatcher\": \"$gcc\"\n```\n\n这样你就能正确使用 VS Code 的错误提示功能了。\n\n如果你想更进一步地了解 `launch.json` 和 `tasks.json` 相关的知识，可以看下文的「查询手册」部分。\n\n## 7、使用 VS Code 进行调试\n\n按下 `F5` 就能进行调试，在调试过程中，右键，然后选择「打开反汇编窗口」，还可以进行汇编代码层面的调试。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefined20220407152920.png)\n\n## 二、VS Code / Python 开发环境搭建\n\nVS Code 中 Python 环境开发环境搭建起来就比较简单。只需要安装好 Python，然后配置运行即可。\n\n### 1、安装 Python\n\n你可以到 [Python 官网](https://www.python.org/downloads/) 下载最新的 Python，就像正常软件一样安装即可。\n\n---\n\nDownload Python | Python.org\nhttps://www.python.org/downloads/\n\n---\n\n在安装的时候，如果有选项「加入到 Path 环境变量」，记得勾选上。\n\n### 2、在 VS Code 中配置环境\n\n在 VS Code 中打开你 Python 代码文件所在文件夹，创建「launch.json」文件。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303205228.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303205350.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303205428.png)\n\n除此之外，你还需要下载 VS Code 推荐你下载的 Python 对应的插件，直接安装即可。\n\n### 3、在 VS Code 中运行 Python 文件\n\n做完上述的配置之后，使用 VS Code 打开一个 Python 文件，按下 F5 即可运行该 Python 文件。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220303205932.png)\n\n\n## 三、查询手册\n\n我会在这部分列出一些 **不一定需要现在看完，可以需要时随时查询的内容**。这部分主要讲述了 VS Code 中 `launch.json` 和 `tasks.json` 的配置，主要是对 C++ 配置进行讲解，当然对其他语言如 Python 和 NodeJS 也有参考意义。\n\n### 1、C++ 运行、编译和调试的基础知识\n\n为了理解 `launch.json` 和 `tasks.json` 的配置，我们需要理解一些关于 C++ 运行、编译和调试的基础知识。\n\n实际上，要开发一个 C++ 程序，我们并不一定需要 IDE 才能开发。我们完全可以用记事本编写好一个 C++ 代码源文件，然后用命令行编译出对应的可执行程序，然后运行或调试。\n\n要编译一个 C++ 源文件，我们需要 **编译器**，常见的编译器有 `g++` 和 `clang`。Linux 下一般会有 `g++`，而 Windows 下我们安装了 MinGW，并配置好相应的 Path 系统变量后，也就能够使用 `g++` 编译器了。C++ 对应的编译器是 `g++`，而 C 语言对应的编译器是 `gcc`，两者使用方式十分相似。\n\n**C++ 编译命令**：\n\n```bash\ng++ <source_file> -o <executable_file>\n```\n\n**输出带有调试信息的可执行文件的 C++ 编译命令**：\n\n```bash\ng++ -g <source_file> -o <executable_file>\n```\n\n这条命令比上一条命令多了 `-g` 参数，其表明要在可执行文件中附带调试信息，这样我们才能够调试这个程序。\n\n**调试可执行程序**：\n\n```bash\ngdb <executable_file>\n```\n\n我们使用的调试器是 `gdb`，这是一个基于命令行的调试器，使用起来会有点麻烦，所以我们更多的还是用 VS Code 自带的调试功能。\n\n实际上，VS Code 的调试功能也是在后台开启一个 GDB 进程，然后通过 LSP 协议与 GDB 进程通信，以实现图形化的调试功能。\n\n### 2、launch.json 文件\n\n在 `.vscode` 文件夹下，有一个 `launch.json` 文件，这个文件放置调试器配置。配置好这个文件后，按下 F5 相当于执行 `gdb <executable_file>`。\n\n下面先举一个 **没有编译只有调试** 的 `launch.json` 配置的例子：\n\n```json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Launch\",  // 调试配置的名称，在菜单中显示\n            \"type\": \"cppdbg\",  // 调试配置的类型，不同编程语言不同，C/C++ 固定是 \"cppdbg\"\n            \"request\": \"launch\",  // 启动 \"launch\" 新进程或者附加 \"attach\" 到现有进程\n            \"targetArchitecture\": \"x86\",  // 目标架构，基本都是填 \"x86\"\n            \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",  // 调试的可执行文件名称，这里配置为 「目录 + 文件名 + .exe」，当然你也可以使用绝对路径\n            \"args\": [],  // 传给 gdb 的参数，设置为空\n            \"miDebuggerPath\": \"D:/Program/MinGW/bin/gdb.exe\",  // 安装的 MinGW 对应的 gdb 文件路径\n            \"setupCommands\": [\n                {   // 提供更好的 STL 库调试显示支持\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": false\n                }\n            ],\n            \"stopAtEntry\": false,  // 是否在程序加载后中断\n            \"cwd\": \"${fileDirname}\",  // 调试时的工作环境，当前设置为可执行文件对应的目录\n            \"externalConsole\": true  // 是否打开外部控制台\n        }\n    ]\n}\n```\n\n这个配置相当于打开一个新的控制台，然后执行 `gdb <executable_file>`。\n\n我们也可以 **加上编译与清理功能**：\n\n```json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Launch\",  // 调试配置的名称，在菜单中显示\n            \"type\": \"cppdbg\",  // 调试配置的类型，不同编程语言不同，C/C++ 固定是 \"cppdbg\"\n            \"request\": \"launch\",  // 启动 \"launch\" 新进程或者附加 \"attach\" 到现有进程\n            \"targetArchitecture\": \"x86\",  // 目标架构，基本都是填 \"x86\"\n            \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",  // 调试的可执行文件名称，这里配置为 「目录 + 文件名 + .exe」，当然你也可以使用绝对路径\n            \"args\": [],  // 传给 gdb 的参数，设置为空\n            \"miDebuggerPath\": \"D:/Program/MinGW/bin/gdb.exe\",  // 安装的 MinGW 对应的 gdb 文件路径\n            \"stopAtEntry\": false,  // 是否在程序加载后中断\n            \"cwd\": \"${fileDirname}\",  // 调试时的工作环境，当前设置为可执行文件对应的目录\n            \"externalConsole\": false,  // 是否打开外部控制台\n            \"preLaunchTask\": \"g++\",  // 在调试前执行 tasks.json 中的 \"g++\" 任务\n            \"postDebugTask\": \"clean\"  // 在调试后执行 tasks.json 中的 \"clean\" 清理任务\n        }\n    ]\n}\n```\n\n注意有文字内容的最后两行，我们通过 `\"preLaunchTask\": \"g++\"` 和 `\"postDebugTask\": \"clean\"` 配置了「编译」和「清理」功能，这两个功能对应我们接下来要讲的 `tasks.json` 文件对应的两个任务。\n\n同理，想要编译和调试多文件编译链接出的可执行文件，我们可以编写 Makefile 文件和使用 `make` 命令实现，然后编写 `make` 对应任务和修改 `preLaunchTask` 即可。\n\nVS Code 官方的 `launch.json` 指南（英文）：\n\n---\n\nConfigure launch.json for C/C++ debugging in Visual Studio Code\nhttps://code.visualstudio.com/docs/cpp/launch-json-reference\n\n---\n\n### 3、tasks.json 文件\n\n`tasks.json` 文件是 VS Code 与许多命令行工具协调工作的核心，其中就包括了我们上文提到的 `g++` 编译器和 `make` 工具。\n\n我们以 `g++` 为例：\n\n```json\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"g++\",  // 这个任务的名称，也就是我们在 \"preLaunchTask\" 处输入的名称\n            \"type\": \"shell\",  // 类型，可以选择 \"process\" 和 \"shell\"，唯一区别就是经不经过 shell 中转\n            \"command\": \"g++\",  // 命令名称，C++ 对应 \"g++\"，C 语言对应 \"gcc\"\n            \"args\": [  // 设定 g++ 命令的参数\n                \"-Wall\",  // 「警告」所有可能的问题\n                \"-Werror\",  // 将所有的「警告」视作「错误」\n                // \"-fexec-charset=GBK\",  // 默认使用 UTF-8，取消注释设定生成的程序使用 GBK 编码，不加这条会导致 Win 的 cmd 下输出中文乱码；繁体系统改为 BIG5\n                \"-g\",  // 生成调试相关信息\n                \"${file}\",  // 当前窗口对应的代码文件\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\"  // 输出的文件名称，应与 launch.json 中一致\n            ],\n            \"group\": {\n                \"kind\": \"build\",  // \"build\" 设定当前任务为构建任务，\"test\" 对应测试任务\n                \"isDefault\": true  // ctrl + shift + B 默认选择\n            },\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"never\",  // 执行任务时是否跳到对应 output 终端，可以设为 \"always\"、\"silent\" 和 \"never\"\n                \"focus\": false,  // 是否聚焦到对应 output 终端\n                \"panel\": \"shared\",  // 不同文件编译信息共享一个 output 终端\n            },\n            \"problemMatcher\": \"$gcc\"  // 错误匹配器，用于匹配编译器提示的警告或错误\n        }\n    ]\n}\n```\n\n其实我们也可以自己写一个 `problemMatcher`，但是一般没有必要，使用官方给的 `$gcc` 即可。\n\n```json\n\"problemMatcher\": {\n    \"owner\": \"cpp\",  // 对应的编程语言\n    \"fileLocation\": [\n        \"autoDetect\",  // 自动检测所在文件\n        \"${workspaceRoot}\"\n    ],\n    \"pattern\": {\n        \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",  // 错误信息对应的正则表达式\n        \"file\": 1,  // 下面这些数字都表示对应正则表达式的哪个「组」\n        \"line\": 2,\n        \"column\": 3,\n        \"severity\": 4,\n        \"message\": 5\n    }\n}\n```\n\n顺带一提，`problemMatcher` 还可以用于后台任务输出的识别，例如 `tsc --watch` 这类的后台任务，不过这个与 C++ 开发就没有关联了。\n\n同理，`make` 和 `clean` 任务可以这样写：\n\n```json\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"make\",\n            \"type\": \"shell\",\n            \"command\": \"cd ${fileDirname} ; make\",\n            \"args\": [],\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"never\",\n                \"focus\": false,\n                \"panel\": \"shared\",\n                \"showReuseMessage\": true,\n                \"clear\": false\n            },\n            \"problemMatcher\": \"$gcc\"\n        },\n        {\n            \"label\": \"clean\",\n            \"type\": \"shell\",\n            \"command\": \"taskkill /im cmd.exe ; del ${fileDirname}\\\\${fileBasenameNoExtension}.exe\",  // 终止 cmd 进程，并删除 exe 可执行文件\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"never\",\n                \"focus\": false,\n                \"panel\": \"shared\",\n                \"showReuseMessage\": true,\n                \"clear\": false\n            }\n        }\n    ]\n}\n```\n\nVS Code 官方的 `tasks.json` 指南（英文）：\n\n---\n\nTasks in Visual Studio Code\nhttps://code.visualstudio.com/Docs/editor/tasks\n\n---\n\n\n### 4、预定义变量\n\n在上文中我们用到了许多预定义变量，我们可以看看一些常见的预定义变量列表：\n\n我们先假设我们有一个文件 `/home/your-username/your-project/folder/file.ext`，和我们当前 VS Code 的工作区 `/home/your-username/your-project`。\n\n- ${workspaceFolder} - VS Code 工作区文件夹 - `/home/your-username/your-project`\n- ${workspaceFolderBasename} - VS Code 工作区文件夹名称 - `your-project`\n- ${file} - 编辑器当前打开的文件的路径 - `/home/your-username/your-project/folder/file.ext`\n- ${fileWorkspaceFolder} - 当前文件对应工作区文件夹 - `/home/your-username/your-project`\n- ${relativeFile} - 当前文件相对于工作区的路径 - `folder/file.ext`\n- ${relativeFileDirname} - 当前文件相对于工作区的路径目录名 - `folder`\n- ${fileBasename} - 当前文件名称 - `file.ext`\n- ${fileBasenameNoExtension} - 不包含后缀的当前文件名称 - `file`\n- ${fileDirname} - 当前文件路径目录名 - `/home/your-username/your-project/folder`\n- ${fileExtname} - 当前文件后缀名 - `.ext`\n- ${cwd} - 当前工作目录\n- ${lineNumber} - 光标对应行号\n- ${selectedText} - 当前选中文本\n- ${execPath} - VS Code 的可执行文件 `Code.exe` 的路径\n- ${defaultBuildTask} - 默认的构建任务名称\n- ${pathSeparator} - 目录分割符，Linux 和 MacOS 对应 `/`，Windows 对应 `\\`\n\n\nVS Code 官方的预定义变量文档：\n\n---\n\nVisual Studio Code Variables Reference\nhttps://code.visualstudio.com/docs/editor/variables-reference\n\n---\n\n\n## 四、延展阅读\n\n如果你想更进一步地掌握 VS Code 搭建 C++ 开发环境的方式，可以看看这个知乎问题。\n\n---\n\nVisual Studio Code 如何编写运行 C、C++ 程序？ - 知乎\nhttps://www.zhihu.com/question/30315894\n\n---\n\nW3Cschool 的 VS Code 配置 C++ 环境的方法步骤。\n\n---\n\nVS Code 配置 C++ 环境的方法步骤（MinGW）\nhttps://www.w3cschool.cn/article/89606693.html\n\n---\n\nMinGW 与 MinGW-W64 的关系。\n\n---\n\nMinGW vs MinGW-W64 及其它\nhttps://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md\n\n---\n\nVS Code 官方的 C++ 开发指南（英文）。\n\n---\n\nC/C++ for Visual Studio Code\nhttps://code.visualstudio.com/docs/languages/cpp\n\n---\n\nVS Code 官方的 `launch.json` 指南（英文）。\n\n---\n\nConfigure launch.json for C/C++ debugging in Visual Studio Code\nhttps://code.visualstudio.com/docs/cpp/launch-json-reference\n\n---\n\nVS Code 官方的 `tasks.json` 指南（英文）。\n\n---\n\nTasks in Visual Studio Code\nhttps://code.visualstudio.com/Docs/editor/tasks\n\n---\n\n\n## 五、参考文献\n\n1. SDchao/AutoVsCEnv_WPF - GitHub - https://github.com/SDchao/AutoVsCEnv_WPF\n2. AutoVsCEnv_WPF V1.994.zip - https://sdchao.lanzoum.com/iB7dE01231be\n3. Visual Studio Code 如何编写运行 C、C++ 程序？ - 知乎 - https://www.zhihu.com/question/30315894\n4. VS Code 配置 C++ 环境的方法步骤（MinGW）- https://www.w3cschool.cn/article/89606693.html\n5. MinGW vs MinGW-W64 及其它 - https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md\n6. C/C++ for Visual Studio Code - https://code.visualstudio.com/docs/languages/cpp\n7. Download Python | Python.org - https://www.python.org/downloads/\n8. Configure launch.json for C/C++ debugging in Visual Studio Code - https://code.visualstudio.com/docs/cpp/launch-json-reference\n9. Tasks in Visual Studio Code - https://code.visualstudio.com/Docs/editor/tasks\n10. Visual Studio Code Tasks Appendix - https://code.visualstudio.com/docs/editor/tasks-appendix\n11. Visual Studio Code Variables Reference - https://code.visualstudio.com/docs/editor/variables-reference\n\n\n## 六、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-2/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 2 期、在编程之前：使用 VS Code 开发 C、C++ 与 Python | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-2/\n\n---","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"第 1 期、在编程之前：如何挑选合适的 IDE","url":"/post/lesson-zero-1/","content":"\n# 第 1 期、在编程之前：如何挑选合适的 IDE\n\n<!-- #! https://zhuanlan.zhihu.com/p/496069865 -->\n\n**IDE** 的全称为 **Integrated Development Environment**（集成开发环境），是一系列与软件开发有关的工具整合而成的统一软件。如果要做一个比喻，那么我们可以认为 IDE 是编程人员手中的一套「武器」。\n\n在正式编程之前，了解不同 IDE 之间的优缺点，选择一个最为称手的 IDE，对我们后续的编程开发有很大的帮助。\n\n<!-- more -->\n\n## 一、程序的生成与 IDE 的组成\n\n在讨论 IDE 的组成之前，我们以 C 语言为例子，先看一下一个程序是怎么编写和生成的。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/lession-1-2.png)\n\n### 1、源文件（Source File）\n\n在我们开发一个 C 语言程序时，我们先是创建了一个空文件 `example.c`，在里面编写了代码（Code），保存之后就成为了一个 **源文件**（Source File）。\n\n如果我们用记事本打开这个源文件，会发现里面的代码能够正常显示，不会像可执行文件那样出现一堆乱码。所以，代码源文件本质上就是 **一个普通的文本文件**，我们可以使用任何的文本编辑器，甚至包括记事本，来编写我们的程序。\n\n将代码保存为源文件之后，我们的编程工作也就得以保存，也能在后续被编译器等工具找到，以便最后生成二进制可执行文件。\n\n不同的编程语言的源文件通过不同后缀名来识别，并且后缀名常常是编程语言自身名字的缩写，例如 C 语言为 `.c`、C++ 为 `.cpp`、Java 为 `.java`、Python 为 `.py`、JavaScript 为 `.js`。\n\nIDE 在我们编写代码的时候，提供代码高亮、自动补全、错误提示等功能，让我们能够更高效地编写程序。\n\n### 2、工程项目（Project）\n\n我们不可能始终将所有代码都写在一个源文件里面，这会对后续继续开发程序产生许多不便，既不符合封装代码的原则，也不利于多人协作开发。\n\n当我们开发一个大型程序或软件的时候，需要将代码写在多个源文件中，这些源文件相互关联和耦合，再加上一些项目相关的依赖和配置，就成为了一个 **工程项目**（Project）。\n\n现代 IDE 会提供完善的项目管理功能，例如代码版本控制功能，项目视图功能，资源管理功能等等。\n\n一个工程中大部分文件是 IDE 无关的，例如源文件，从一个 IDE 迁移到另一个 IDE 也能正常发挥作用。\n\n但是 IDE 也可能会在一个工程中留下一些 IDE 专属的配置文件，例如 VS Code 会在一个项目中留下 `.vscode` 目录，里面存放了一些 VS Code 专属的，和开发调试有关的配置文件。\n\n### 3、IDE 的组成\n\n从上图我们可以看出，IDE 主要由以下三部分组成：\n\n- **代码编辑器**：代码编辑器可以帮助我们更高效地编写代码，它提供 **代码高亮** 功能，以便更容易地识别代码中的不同成分，例如关键字，缩进，匹配括号，字符串，变量，常量等；不同编程语言不同的 **自动补全** 功能，能够像输入法一样，只需要输入少量内容，就能匹配到完整的内容；**错误提示** 功能，能够在我们编写代码的时候，就实时地进行错误静态检测，帮助我们减少语法错误。\n- **构建生成工具**：构建生成工具整合了一系列的 **构建工具**，帮助我们从项目的源文件生成我们最终需要的可执行文件。就 C 语言来说，IDE 就会整合 GCC 等工具，用 C 语言源文件生成可执行文件。除此之外，IDE 还可以帮助运行 **自动化测试**。\n- **调试器**：调试器可以帮助我们进入程序运行的最底层，通过 **设置断点**、**步进**、**步过** 和 **显示变量内容**，来掌握程序运行的任意一处细节。IDE 可以让调试器以图形化的方式展示，例如显示断点或当前执行代码在源文件中具体位置，优雅地展示相关的变量数据等。\n\n使用 IDE 最大的好处就是能够减少不同工具或软件的学习成本。不使用 IDE，我们实际上也能够进行编程，例如使用文本编辑器 Vim 编写 C 语言源文件，再使用 GCC 执行命令编译出可执行文件，最后使用 GDB 对程序进行调试。\n\n但对于一个初学者来说，同时掌握这一系列工具来编写程序，学习曲线十分陡峭，很容易望而生畏，丧失学习兴趣；或者是走入岐路，热衷于尝试不同的工具组合，而忽视了具体知识的学习。因此，我推荐初学者先使用 IDE 入门学习编程，在掌握了一定的知识之后，再去尝试个性化编程开发工具链。\n\n\n## 二、IDE 的评价维度\n\n评价一个 IDE 好坏的维度有很多，所以我们并不能说哪一个 IDE 就是最好的，哪一个 IDE 就是最差的。不过作为参考，我们还是可以通过一些调查报告了解到哪些 IDE 比较受欢迎。\n\n例如，在线问答网站 Stack Overflow 于 2021 年制作了一份调查，里面记录了哪些 IDE 比较受人欢迎。当然，这个榜单并不能非常准确地给出 IDE 之间的真实排名，因为 VS Code 这类通用的文本编辑器，一般都会比 PyCharm 这类专注于某一种语言的 IDE，有着更广泛的用户群体和更高的人气。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220220194122.png)\n\n你可以从这里找到这份榜单：\n\n---\n\nStack Overflow Developer Survey 2021\nhttps://insights.stackoverflow.com/survey/2021#integrated-development-environment\n\n---\n\n除了受欢迎程度，我们还可以具体地找出几个评价维度，来帮助我们选择一款最适合自己的 IDE。\n\n- **上手难度**：一些 IDE 的上手难度很高，但可能有着很高的可配置性；一些 IDE 上手简单，但可能就会产生可配置性过低的问题。上手难度也涉及到是否能够开箱即用的问题，一些 IDE 需要经过一系列开发环境配置，才能正式开始编程。\n- **支持的语言**：不同 IDE 支持的语言一般会有所不同。例如 IntelliJ 主要是用于 Java 开发，PyCharm 主要用于 Python 开发；而有一些大而全的 IDE 可能会支持很多语言，例如 Visual Studio；还有一些 IDE 的主体是文本编辑器，可以通过插件的方式支持几乎所有的编程语言，例如 VS Code 和 Vim。\n- **插件拓展**：一个 IDE 的优秀与否，有一类很关键的影响因素，那就是是否支持安装插件，插件开发是否简单易上手，以及是否拥有一个中心化的插件市场。如果支持插件，那么我们就有了个性化配置我们自己的 IDE 的能力；插件开发简单易上手，就更方便我们通过自己开发插件的方式满足我们的开发需求；有一个中心化的插件市场，除了能够提供一定的代码安全审查保障，还能够让我们即搜即用，更为方便快捷地使用插件。\n- **支持的操作系统**：一些 IDE 只支持一个操作系统，例如微软的旧款 Visual Studio 只支持 Windows；苹果的 Xcode 只支持 MacOS。另一些 IDE 的底层使用了跨平台的编程语言开发，例如 JetBrains 的 IntelliJ 和 PyCharm 使用 Java 开发，所以支持 Windows、MacOS 和 Linux；微软的 VS Code 使用 TypeScript 开发，也同时支持 Windows、MacOS 和 Linux。除了支持的操作系统外，还有应用目标的操作系统，例如 Android Studio 就是专为 Android 开发设计的 IDE。\n- **界面美观程度**：一些 IDE 过时且缺少维护，界面仍然沿用着老旧的设计，无论是字体还是高亮颜色，都并不适合现代化的代码编写。我们更推荐使用有着现代化 UI 设计的 IDE，既可以培养自身的美学素养，也可以有着更舒适的编程体验。\n- **自动化功能**：除了 IDE 常见的文本编辑、构建生成和调试功能之外，还有一些其他的 IDE 拥有的功能，例如代码重构、代码搜索、代码版本控制、持续集成与快捷键操作等功能，也会深刻地影响到 IDE 使用的体验。\n- **软件价格**：一些 IDE 的价格较高，没有收入来源的学生很难负担得起，虽然可以使用社区版或学生版，但是也会缺少一些功能。而另一些 IDE 完全免费，比较适合计算机类学生使用。\n- **是否开源**：一些 IDE 是开源的，这意味着可以通过社区贡献代码的方式进行开发和维护，也就不用担心以后会缺少维护，甚至我们可以自己动手改造这些 IDE。\n- **系统资源占用**：IDE 的系统资源占用也很关键。一些 IDE 过于庞大，会占用过多的存储空间；一些 IDE 由于采用的底层编程语言的缘故，会占用很多的内存，内存过小可能会导致闪退；一些 IDE 没有做好优化，打开一些项目或大文件的时候，启动就会需要很长的时间。\n\n综合考虑以上因素，我们才能更好地找到最适合我们的 IDE。\n\n\n## 三、不同 IDE 的简单评价\n\n在这部分，我们简单地使用上述的几个维度对一些常见 IDE 进行评价，并且以不是已经工作的编程行业从事者的眼光评价，而是以计算机类学生的眼光来评价这些 IDE。\n\n\n### 1、Visual Studio\n\n**推荐指数**：★★★\n\nVisual Studio 是微软家的老牌 IDE，在 Stack Overflow 的调查中名列第二位。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220220235624.png)\n\nVisual Studio 是一个庞大的软件，支持各种各样的编程语言，例如 C++ 和 C#。对于计算机学生来说，Visual Studio 主要的用途一般是 C++ 开发。\n\nVisual Studio 的优点是上手简单，开发 C++ 程序无需额外的配置，操作以 GUI 界面的各种菜单为主，并且提供与开发有关的丰富的功能。并且 Visual Studio 有着完整的开发工具链，无论是最基本的编译和调试功能，还是更进一步的测试和协作功能，Visual Studio 均有着完整的支持。\n\n但是我其实并不是十分推荐计算机类学生使用 Visual Studio。虽然 Visual Studio 有着强大的功能，但是它的体积也十分庞大，功能也太过复杂，对于开发构建的步骤也封装得过于严实，并且不支持 Linux 系统，不适合计算机类学生进一步的学习。\n\n一言以蔽之，计算机类学生使用 Visual Studio，有点「杀鸡用牛刀」。\n\n---\n\nVisual Studio 2022 IDE\nhttps://visualstudio.microsoft.com/zh-hans/vs/\n\n---\n\n\n### 2、Dev-C++ / Code::Blocks\n\n**推荐指数**：★★\n\nDev-C++ 和 Code::Blocks 是两款学习 C++ 时很有可能碰到的 IDE。一般来说都是老师给学生推荐这两款 IDE 之一，供学生入门 C++ 的学习。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221101905.png)\n\n对于刚入门的学生来说，使用这两款 IDE 是比较合适的。这两款 IDE 的特点都是对基础 C++ 开发的支持较好，开箱即用，不需要繁杂的开发环境配置。\n\n但是在开发一段时间之后，这两款 IDE 就不再适合了。首先是这两款 IDE 都已经比较旧了，界面 UI 已经显得有点过时，用它们编程体验不会太好；它们的自动补全和错误提示功能比不上现代的 IDE，会拖累你的开发速度；构建生成过程被封装了起来，很难自定义配置，有一些语言的新特性也不支持；调试功能过于老旧，用户体验不佳。\n\n所以我个人推荐初学者在使用了一两周这两款 IDE 之后，立刻切换到其他的 C++ IDE，例如 VS Code 或 Clion。\n\n---\n\nHome - Dev-C++ Official Website\nhttps://www.bloodshed.net/\n\n---\n\n---\n\nCode::Blocks - The free C/C++ and Fortran IDE\nhttps://www.codeblocks.org/downloads/\n\n---\n\n\n### 3、Visual C++ 6.0\n\n**推荐指数**：★\n\nVC 6.0 是微软很早的时候开发的一个 C++ IDE，但是微软已经不再维护它了。如果你们的学校还在使用 VC 6.0，说明你们学校的教学体系过于落后了。\n\nVC 6.0 支持 Win XP，但是在 Win7 和 Win10 下需要设置兼容模式才能运行，而且依然有可能因为依赖问题而出错。\n\n如果你准备使用 VC 6.0，请立刻放弃这个念头；如果你已经安装了 VC 6.0，请立刻卸载它，并安装其他的 IDE。在这里就不给出 VC 6.0 的下载链接了。\n\n\n### 4、Eclipse\n\n**推荐指数**：★★★\n\nEclipse 是一款跨平台开源免费的 IDE，最初主要用来进行 Java 开发，安装一些插件后也可以用作 Android、C++、Python 开发。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221105740.png)\n\nEclipse 本身只是一个框架平台，但有着众多插件的支持，所以有较佳的灵活性。\n\n虽然 Eclipse 曾经是「免费 Java IDE」的最好的选择，网络上也有许多相关的教程和博文，但过了那么年，Eclipse 也已经不是最好的选择了。\n\n被称为「Eclipse 之父」的 Erich Gamma 于 2011 年加入了微软公司，并带领开发了更为现代化的 Visual Studio Code。可以说，现在的 VS Code 已经能够很好地替代 Eclipse 了。\n\n---\n\nEclipse Downloads | The Eclipse Foundation\nhttps://www.eclipse.org/downloads/\n\n---\n\n\n### 5、IntelliJ IDEA\n\n**推荐指数**：★★★★\n\nIntelliJ IDEA 是 JetBrains 家的 Java IDE。如果你打算开发 Java 程序，并且有着足够存储空间和内存空间，学生版的 IntelliJ IDEA 应该是你最好的选择。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221105504.png)\n\nIDEA 上手简单，专注于 Java 开发，集成版本控制系统以及多种支持的语言与框架，无需另外安装插件，所以可以做到开箱即用。并且 IDEA 的智能代码补全优于一般的 IDE，可以很好地提高我们的开发效率。唯一的缺点是，JetBrains 家的 IDE 软件，都是闭源且收费的。但是我们可以使用免费的社区版，或者通过学生证明的方式使用学生版。\n\nIntelliJ IDEA 有一句话很能够说明它在 Java 开发者之间的受欢迎程度：「四分之三的 Java 开发者选择 IntelliJ IDEA」。\n\n---\n\nIntelliJ IDEA：JetBrains 功能强大的 Java IDE\nhttps://www.jetbrains.com/zh-cn/idea/\n\n---\n\n\n### 6、CLion\n\n**推荐指数**：★★★★\n\nCLion 是 JetBrains 家的 C/C++ IDE，专注于跨平台的 C/C++ 开发。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221224454.png)\n\nCLion 专注于跨平台的 C/C++ 开发，它也是一款支持全平台的、开箱即用的 C/C++ IDE。它有着 JetBrains 家 IDE 的一贯优点：有着优秀的智能代码补全和完善的调试器。缺点也依然是它的闭源与高昂的价格。\n\n之所以推荐指数比 Visual Studio 高一颗星，是因为它没有 Visual Studio 那么庞大的体积，并且支持 Linux 平台，我个人认为它是更适合学生学习 C++ 的一种选择。\n\n---\n\nCLion：JetBrains 出品的 C 和 C++ 跨平台 IDE\nhttps://www.jetbrains.com/zh-cn/clion/\n\n---\n\n\n### 7、PyCharm\n\n**推荐指数**：★★★★\n\nPyCharm 是 JetBrains 家的 Python IDE，有着各种项目完善的配置，开箱即用。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221225736.png\n)\n\nPyCharm 专注于 Python 开发，它也是一款支持全平台的、开箱即用的 C/C++ IDE。除了优秀的智能代码补全和完善的调试器，它还有很多默认的项目配置，例如 Web 开发、科学工具等。缺点也依然是它的闭源与高昂的价格。\n\n---\n\nPyCharm：JetBrains 为专业开发者提供的 Python IDE\nhttps://www.jetbrains.com/zh-cn/pycharm/\n\n---\n\n\n### 8、Vim\n\n**推荐指数**：★★★\n\nVim 其实是一款在类 Unix 操作系统下的文本编辑器，严格定义下甚至不能算一款 IDE。Vim 以它的极高的输入效率和吓人的入门难度而出名。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20140323224500265.png)\n\nVim 以它「仅需键盘」和「纯命令行」而出名。对于初学者来说，就连怎么退出 Vim 都是一个难题，Stack Overflow 就有这么一个问题：[How do I exit the Vim editor?](https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor)\n\n这是因为 Vim 有着非常陡峭的入门曲线，部分原因是它具有 6 种基本模式和 5 种派生模式。几乎所有的编辑器都会有插入和执行命令两种模式，但大多数的编辑器通过菜单、包括组合键（Shift、Ctrl 和 Alt）的快捷键和鼠标操作来执行命令，其余时候均为插入模式；而 Vim 刚进入就处在「普通模式」，在这个模式可以输入命令对应的字母组合来进行一些操作，且不需要按下组合键，例如只需要输入「dd」就能删除当前行，输入「i」就能进入插入模式。\n\nVim 的陡峭的学习曲线，意味着开始学习的时候可能会进展缓慢，但是一旦掌握一些基本操作之后，能大幅度提高编辑效率。并且 Linux 系统一般都默认带有 Vim，在一些特殊情况下，例如不能通过 SSH 远程连接服务器，只能使用服务器的一个终端的时候，掌握 Vim 的基本输入方法和保存退出方法就显得十分必要。\n\n如果想要给 Vim 加上一些相关的开发配置，例如高亮、定义跳转等功能，就需要经过一番配置。并且 Vim 没有一个中心化的插件市场，搜索和安装插件会显得有点麻烦，这也是 Vim 的一个缺点。\n\n其实现在大部分现代 IDE 都能够让你开启 Vim 的输入模式，例如 VS Code 就有 Vim 插件，让我们能够保留 Vim 的快捷输入方式的同时，也享受到现代 IDE 的好处。而且说实话，现代的 IDE 的快捷键也基本上覆盖了 Vim 的常见快捷操作了，输入速度完全比得上 Vim。所以我并不推荐初学者去学习 Vim，将学习 Vim 的精力放到其他地方会有更好的效果。\n\n---\n\ndownload : vim online\nhttps://www.vim.org/download.php\n\n---\n\n\n### 9、Visual Studio Code\n\n**推荐指数**：★★★★★\n\nVisual Studio Code 是一款由微软开发且跨平台的免费源代码编辑器，并且以它丰富的插件，能够支持几乎所有的编程语言而出名。网络上有着这么一句话：「VS Code 是一种生活方式」。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220221233356.png)\n\n从 Stack Overflow 在 2021 年的调查中我们可以看出，VS Code 是现在最受欢迎的 IDE，高达 71.06% 的人喜欢 VS Code 这一款 IDE，其受欢迎程度是第二名 33.03% 的两倍有余。为什么 VS Code 这么受欢迎？它和一般的 IDE 又有什么区别呢？\n\n我摘抄一段知乎上的回答来说明这个问题（做了少许修改），具体回答可以看这里：\n\n---\n\nVisual Studio Code 可以翻盘成功主要是因为什么？ - 韩骏的回答\nhttps://www.zhihu.com/question/363365943/answer/954586960\n\n---\n\n\n**学习曲线**\n\n对于任何人来说，特别是新手，一个工具的学习曲线也会影响到它的受欢迎程度。VS Code 在学习曲线上，一定是遥遥领先于 Vim 的。同时，VS Code 的使用文档相比于其他编辑器也是做的最好的，无论是“快速入门”还是每一个功能的使用，在官网上都写的一清二楚有条有理。官网还提供了 PDF 版的键盘快捷键参考表，让开发者轻松上手。此外，考虑到一些开发者是从 Vim、Sublime、IntelliJ 或是其他开发工具转来的，依旧习惯于原来开发工具的键盘快捷键。VS Code 也提供了各种键盘映射的插件，让你可以在 VS Code 中继续使用不同开发工具的快捷键，而不用重新学习 VS Code 的快捷键。\n\n**用户体验**\n\nVS Code 提供了许多良好的开箱即用的用户体验。与 Vim、Sublime 和 Atom 一样，VS Code 都提供了代码编辑的体验。此外，VS Code 在保持其轻量级代码编辑器的前提下，还内置了一些 IDE 中会有的重要功能：\n\n- Terminal：内置的 Terminal 使得开发者可以直接在 VS Code 中快速地运行脚本，而不需要在 VS Code 和系统的 Terminal 之间来回切换。\n- 调试器：直接在 VS Code 中调试代码，断点、call stacks、交互式的 debug console，使得调试变得异常轻松。\n- 版本控制：开箱即用的 Git 支持，让你方便地进行文件更改比较，管理你的源代码。\n \n特别是对于前端开发者来说，VS Code 有着非常好的支持。除了对 JavaScript 的智能提示、重构、调试等功能的支持，像 HTML, CSS, SCSS, Less 和 JSON 这些前端技术栈，都有着很棒的支持。\n\n**性能**\n\n天下武功唯快不破。相信从 IDE 转投 VS Code 的开发者，一定是对 VS Code 的性能非常满意。同为基于 Electron 开发的产品，VS Code 在性能的优化上要比 Atom 领先许多。VS Code 的插件进程与主进程相隔离，插件会延迟加载，还有 Text Buffer 的优化，还提升了大文件的加载与编辑速度，也减少了内存使用率。VS Code 本体只是一个文本编辑器，不会内置具体的开发环境，所以刚下载只会有 100 MiB 的大小，非常适合电脑存储空间并不大的学生使用。\n\n**插件**\n\nVS Code 有着丰富且快速增长的插件生态，如今，已经有超过一万个插件。不仅有中心化的插件市场，而且在 VS Code 编辑器里也可以轻松搜索插件，直接进行安装与管理。相比之下，Sublime 只有 5000 不到的插件，而且在编辑器里不能很方便地搜索管理插件；Vim 插件虽多，但因为没有一个中心化的插件市场，查找插件很麻烦；Atom 有 8000 多的插件，比 VS Code 少一些，虽然在编辑器内也是可以查找插件，但 VS Code 的搜索和浏览功能做的要比 Atom 要好。\n\n此外，VS Code 还推出了 Extension Packs，方便开发者一键安装多个插件。比较出色的 Extension Pack 有 Java Extension Pack、PHP Extension Pack、Vue.js Extension Pack 等，使得 VS Code 秒变 IDE。\n\n对于插件开发者而言，VS Code 底层使用的 Web 技术和 NodeJS 技术，在大大降低了插件开发难度的同时，也给插件开发者提供了基于 Web 的丰富显示方式。所以，你甚至可以使用 VS Code 来写文章，记日志，听音乐，甚至是打游戏。顺带一提，这篇与 IDE 有关的博文就是在 VS Code 上写的。\n\n**生态**\n\nVS Code 不仅仅是一个代码编辑器，它有着强大的生态。VS Code 把它的许多重要组件抽离出来，成为大家都可以复用的开源产品，与社区合作，把产品越做越好：\n\n- **Language Server Protocol**：它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。Eclipse, Atom, Sublime Text, Emacs 等主流 Editor/IDE 都已经支持了 LSP。LSP 已经成为了语言服务协议的事实标准。\n- **Debug Adapter Protocol**： DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。Eclipse, Emacs, Vim 等都已经支持了 DAP 。\n- **Monaco Editor**：作为 VS Code 的核心组件，Monaco Editor 在 GitHub 已经拥有了超过一万三千个 star 。国内比较有名的比如 Cloud Studio 和 Gitee Web IDE 都使用了 Monaco Editor。\n\nVS Code 作为 Visual Studio Family 的重要产品，与 Visual Studio IDE 一样，也有两大重要的功能：\n\n- **Visual Studio Live Share**：极大地方便了协作编程：实时共享代码编辑、跟随光标、团队调试、分享本地服务器、共享终端等等。\n- **Visual Studio IntelliCode**：通过 AI 赋能，根据上下文给出编程建议和智能提示，提高开发者的效率。\n\n最后，我简单总结一下，我认为 VS Code 是最适合计算机类学生的 IDE。VS Code 上手简单，并且也有着极高的可配置性。你可以使用 VS Code 进行 C、C++、Java、Python 和 JavaScript 的编程，也可以使用 VS Code 来写作业、论文和博客，几乎覆盖了计算机教学的方方面面。\n\n---\n\nVisual Studio Code - Code Editing. Redefined\nhttps://code.visualstudio.com/\n\n---\n\n\n## 四、不同编程语言 IDE 的选择\n\n对于一些常见的编程语言，我会给出一些我个人的选择。再次重申，这里的排名是站在计算机类学生进行学习的角度进行排名的，不代表业界真实项目中的选择。\n\n- **C/C++**：VS Code > CLion > Visual Studio > Code::Blocks = Dev-C++ > VC 6.0\n- **Java**：IntelliJ IDEA > VS Code > Eclipse\n- **Python**：VS Code = PyCharm\n- **JavaScript**：VS Code > WebStorm\n\n不过想要用 VS Code 来进行 C/C++ 编程，还是需要一些配置的，我会在下一篇博文中讲述如何使用 VS Code 来开发 C、C++ 和 Python 程序。\n\n\n## 五、延展阅读\n\nRedHat 的一篇文章简单地讲述了 IDE 的概念。\n\n---\n\nWhat is an IDE?\nhttps://www.redhat.com/en/topics/middleware/what-is-ide\n\n---\n\n一些与 C/C++ 语言编译器有关的概念。\n\n---\n\n什么是编译器？\nhttp://c.biancheng.net/view/450.html\n\n---\n\nStack Overflow 2021 年的开发者调查\n\n---\n\nStack Overflow Developer Survey 2021\nhttps://insights.stackoverflow.com/survey/2021#integrated-development-environment\n\n---\n\nVisual Studio Code 受欢迎的原因\n\n---\n\nVisual Studio Code 可以翻盘成功主要是因为什么？\nhttps://www.zhihu.com/question/363365943\n\n---\n\nVisual Studio Code 工程方面的亮点\n\n---\n\nVisual Studio Code有哪些工程方面的亮点\nhttps://zhuanlan.zhihu.com/p/35303567\n\n---\n\n\n## 六、参考文献\n\n1. What is an IDE? - https://www.redhat.com/en/topics/middleware/what-is-ide\n2. 什么是编译器？- http://c.biancheng.net/view/450.html\n3. Stack Overflow Developer Survey 2021 - https://insights.stackoverflow.com/survey/2021#integrated-development-environment\n4. 如何看待「年轻人不要用 Visual Studio」的言论？ - https://www.zhihu.com/question/24079888\n5. Visual Studio Code 可以翻盘成功主要是因为什么？ - https://www.zhihu.com/question/363365943\n6. Visual Studio 2022 IDE - 适用于软件开发人员的编程工具 - https://visualstudio.microsoft.com/zh-hans/vs/\n7. IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE - https://www.jetbrains.com/zh-cn/idea/\n8.  JavaScript 编程 - 2020 开发人员生态系统信息图 - https://www.jetbrains.com/zh-cn/lp/devecosystem-2021/javascript/\n9.  Eclipse - 维基百科，自由的百科全书 - https://zh.wikipedia.org/wiki/Eclipse\n10. Visual Studio Code有哪些工程方面的亮点 - https://zhuanlan.zhihu.com/p/35303567\n11. PyCharm：JetBrains为专业开发者提供的Python IDE - https://www.jetbrains.com/zh-cn/pycharm/\n12. CLion：JetBrains 出品的 C 和 C++ 跨平台 IDE - https://www.jetbrains.com/zh-cn/clion/\n13. Vim - 维基百科，自由的百科全书 - https://zh.wikipedia.org/wiki/Vim\n14. Visual Studio Code - Code Editing. Redefined - https://code.visualstudio.com/\n\n\n## 七、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。您可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n知乎专栏：\n\n---\n\n计算机学生的第零课 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n该篇文章首发于 [OrangeX4 的博客](https://orangex4.cool/post/lesson-zero-1/) 上，采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n---\n\n第 1 期、在编程之前：如何挑选合适的 IDE | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-1/\n\n---\n\n\n\n","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"计算机学生的第零课","url":"/post/lesson-zero-for-cs-students/","content":"\n# 计算机学生的第零课\n\n<!-- #! https://zhuanlan.zhihu.com/p/496066367 -->\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/template.png)\n\n作为一个计算机类专业的学生，我常常会感觉到，有一些知识点很少会在大学课程上被讲授，但是了解它们却又对我们学习计算机知识有着较大的帮助。\n\n这些知识点，要么过于零碎不成体系，难以作为一科课程进行专门讲授；要么过于偏向工程应用，不适应偏向底层原理知识讲解的大学授课模式；要么还是十分新兴的技术，还没有完全成熟，也就不适合在课堂上讲授。\n\n为此，我决定写一个系列的文章，简单介绍一些我认为会对计算机类专业学生非常有益，却又很少在课堂上讲授的知识点。这一系列文章可以作为计算机课堂教育的补充，也作为我自己个人学习经历的记录，也锻炼自己的写作能力。\n\n在写作这一系列文章的过程中，我会努力平衡理论与应用之间的关系，避免「不求甚解」，也避免「泛泛而谈」。例如，介绍一个新的应用技术时，我会尽可能从这门技术的产生原因写起，避免知其然而不知其所以然；涉及到软件工程中一些抽象的理论概念时，我会尽可能给出一些形象而具体的实例以便理解。\n\n此外，这一系列文章可能会穿插一些与计算机技术发展有关的历史。我认为了解一些相关的技术历史可以拓展个人的知识面，也能对未来技术发展的趋势有更好的把控。\n\n由于这是我个人的简单记录，很难保证囊括所有的内容，如有缺漏或错误，敬请谅解，也欢迎进行补充。\n\n<!-- more -->\n\n\n## 一、文章结构\n\n每篇文章，我会按照如下结构编写。\n\n零、简介，对要阐述的知识点进行简要说明，让读者能有一个大致的内容把握。\n\n一、引言，通过举一些例子，来说明一个知识点为什么被我们需要，引出知识点具体的内容。这部分可能被省略，也有可能与简介部分合并。\n\n二、文章主体，文章的主体部分，划分几个具体的层次或部分，逐一讲解。部分时候，会在标明出处的前提下，完全转载别人的文章作为主体部分。\n\n三、查询手册，可能存在的部分，放置一些繁杂琐碎的，不需要放置在正文部分的，可以在需要的时候再来查询的知识点。例如一些很少见的 API 与命令。\n\n四、延展阅读，我会在这部分介绍一些相关的文章或书籍等资料，可以作为进一步了解的方式。\n\n五、参考文献，写作这一篇文章时参考过的文献。\n\n\n## 二、目录\n\n这一系列文章是存在先后顺序的，推荐按顺序往下阅读。\n\n- [第 1 期、在编程之前：如何挑选合适的 IDE](https://orangex4.cool/post/lesson-zero-1/)\n- [第 2 期、在编程之前：使用 VS Code 开发 C、C++ 与 Python](https://orangex4.cool/post/lesson-zero-2/)\n- [第 3 期、写作：使用 Markdown 记笔记入门](https://orangex4.cool/post/lesson-zero-3/)\n- [第 4 期、写作：TeX、LaTeX 与排版系统](https://orangex4.cool/post/lesson-zero-4/)\n- [第 5 期、写作：LaTeX 和 Markdown 中的数学公式和 HyperSnips 快捷输入](https://orangex4.cool/post/lesson-zero-5/)\n- [第 6 期、写作：基于 VS Code 的 Markdown 写作技术栈](https://orangex4.cool/post/lesson-zero-6/)\n- [第 7 期、科研作图：写论文、作业时用得到的作图软件](https://orangex4.cool/post/lesson-zero-7/)\n- 未完待续 ......\n\n\n## 三、订阅方式\n\n这一系列文章首先发表于我的博客，欢迎关注。\n\n---\n\n方橙式的博客 | OrangeX4's Blog\nhttps://orangex4.cool/\n\n---\n\n如果你熟悉 RSS，也可以通过 RSS 来订阅我的博客。\n\n---\n\n方橙式的博客 - RSS\nhttps://orangex4.cool/atom.xml\n\n---\n\n我也会在知乎专栏同步发布，欢迎关注。\n\n---\n\n一只方橙 - 知乎\nhttps://www.zhihu.com/column/c_1479506700219150337\n\n---\n\n\n## 四、线路图\n\n以下是我初步打算涉及到的文章内容，后续仍然可能变动，你可以先将其看作一个简单的知识线路图。\n\n1.  在编程之前：如何挑选合适的 IDE\n2.  在编程之前：使用 VS Code 开发 C、C++ 与 Python\n3.  写作：使用 Markdown 记笔记入门\n4.  写作：TeX、LaTeX 与排版系统\n5.  写作：LaTeX 和 Markdown 中的数学公式和 HyperSnips 快捷输入\n6.  写作：基于 VS Code 的 Markdown 写作技术栈\n7.  科研作图：写论文、作业时用得到的作图软件\n8.  科学计算：Symbolab、Wolfram、Matlab 与 Python\n9.  技术与历史：与 Linux 系统有关的历史课\n10. Linux 安装：虚拟机、双系统和 WSL\n11. 面向终端的交互：Shell 基础与命令行入门\n12. 脚本：浅谈脚本与 Shell 脚本的编写\n13. 正则表达式：识别、提取、替换文本的优异工具\n14. 构建系统：经典的 make 命令和 Makefile 文件编写\n15. 软件工程：每个人都会出错，debug 占据了开发的主要时间\n16. 软件工程：测试样例生成与差分测试（DiffTest）\n17. 软件工程：系统开发的 KISS 法则，保持简单\n18. 终端文本编辑器：只需键盘的文本编辑器 Vim\n19. 可视文本编辑器：VS Code 的各种快捷操作\n20. 计算机系统：Windows 和 Linux 下的环境变量与 Path 环境变量\n21. 计算机系统：Linux 下的程序分析与性能分析\n22. 数据可视化：条形图、折线图、散点图、雷达图和火焰图\n23. 代码版本控制：简单的 Git 入门教程\n24. 技术与历史：GNU 与自由软件运动\n25. 开源代码平台：Github 与代码开源\n26. 问答平台：在 Stack Overflow 上寻找答案\n27. 在线评测平台：LeetCode、洛谷和相关的 OI Wiki\n28. 开源许可证：GPL、BSD、MIT、Mozilla、Apache 和 LGPL\n29. 代码阅读：在 GitHub 上阅读开源项目代码与 Git Commits 规范\n30. 写作：使用 Github 和 GitNotes 实现笔记云端存储\n31. 软件工程：调试（Debug）、日志（Log）与断言（Assert） \n32. 技术与历史：终端，桌面到网页；苹果，微软和谷歌\n33. 职业分工：前端，后端，桌面，移动，嵌入式、算法和数据岗位\n34. 万维网：HTML、CSS 和 JS 所构建的世界\n35. 设计模式：基于 Event 的事件分发模式\n36. 计算机网络：IP、TCP、URL 与 HTTP 协议\n37. 移动开发：Native App、Web App 与 Hybrid App\n38. 桌面开发：WPF、Qt 与 Electron\n39. 从前端到后端：以 JavaScript 为基础的 NodeJS\n40. 包管理：浅谈 apt、npm、pip 和 maven 的包管理\n41. 前端框架：React、Vue、Angular 和 Svelte\n42. 设计模式：MVC、MVP 和 MVVM\n43. 编程范式：面向过程、面向对象与函数式编程\n44. 软件工程：人月神话与没有银弹\n45. 数据描述：XML、JSON 与 YAML\n46. RSS: 基于 XML 的简易信息聚合\n47. 知识图谱：语义网络、RDF 与 OWL\n48. 云服务器：租用第一个云服务器\n49. 云服务器：使用 SSH 连接云服务器与 VS Code 远程开发\n50. 安全与密码学：哈希函数、对称加密与非对称加密\n51. Web 后端：NodeJS 的 Express，Python 的 Flask\n52. 数据库：简单的数据库入门与 SQL 语法讲解\n53. 爬虫：使用 Python 开发第一个爬虫\n54. 代码阅读：分析典型的 Web 项目架构\n55. 权限系统：OAuth 的四种授权模式与 JWT 标准\n56. 个人博客：基于 Hexo 和 Cloudflare 搭建个人博客\n57. 写作：中文技术文档的写作规范\n58. 写作：创作共用许可证 CC（Creative Commons licenses）\n59. 持续集成：使用 GitHub Actions 自动集成部署你的代码\n60. 软件工程：DevOps 理念与运维自动化\n61. 软件工程：软件开发的核心是封装和接口\n62. 软件测试：单元测试、集成测试、回归测试和模拟\n63. 软件工程：测试驱动开发的敏捷开发模式\n64. 元编程：宏、范型、装饰与反射\n65. 元编程：领域特定语言 DSL 与常见例子\n66. 容器化：简单的 Docker 入门教程\n67. Web 服务器：Nginx、Apache 与 Tomcat 简介\n\n\n## 五、文章声明\n\n该篇文章是 OrangeX4 所写的「计算机学生的第零课」系列文章其中的一篇。可以通过下方链接查看完整目录。\n\n---\n\n计算机学生的第零课 | OrangeX4's Blog\nhttps://orangex4.cool/post/lesson-zero-for-cs-students/\n\n---\n\n采用 [BY-NC](https://creativecommons.org/licenses/by-nc/4.0/deed.en) 许可协议，禁止商用，转载请注明出处。\n\n","tags":["Study","CS","Lesson"],"categories":["Lesson"]},{"title":"为 Hexo 博客中的 Markdown 添加卡片式链接支持","url":"/post/hexo-link-card/","content":"\n# 为 Hexo 博客中的 Markdown 添加卡片式链接支持\n\n我写了一个 [Hexo 插件](https://github.com/OrangeX4/hexo-link-card)，可以使用现有 Markdown 语法将链接转换为卡片式链接（网页卡片）.\n\n这个插件的 GitHub 地址在这里：\n\n---\n\nOrangeX4/hexo-link-card - GitHub\nhttps://github.com/OrangeX4/hexo-link-card\n\n---\n\n**卡片式链接的优点：**\n\n1. 在移动互联网的时代，有许多人通过智能手机浏览文章，通过卡片式链接打开新页面对他们更友好；\n2. 旧式的链接显示方式不够明显，很容易导致人们忽视了这是一条链接，卡片式链接能够突出显示，不容易被他人忽略；\n3. 许多平台，例如 Bilibili，知乎，微信公众号等平台，均有将链接转换为卡片式链接的功能，如果能在书写 Markdown 阶段，就将卡片式链接的书写考虑进去，能给后续发布带来很大的便利。\n\n<!-- more -->\n\n## 安装\n\n在你的 Hexo 项目下执行以下命令即可。\n\n``` sh\nnpm install hexo-link-card --save\n```\n\n## 语法\n\n我们定义如下语法：\n\n``` markdown\n---\n\nOrangeX4/hexo-link-card - GitHub\nhttps://github.com/OrangeX4/hexo-link-card\n \n---\n```\n\n注意，两个空行里不应该有空格，否则会显示失败。\n\n**这种语法有以下优点：**\n\n1. 书写简单，易于识别，符合 Markdown 语法的设计理念；\n2. 实现简单，只需要用 Javascript 的正则表达式替换和内置 HTML 功能即可实现；\n3. 与现有的 Markdown 语法兼容，即使是没有实现这种语法的 Markdown 显示页面，也能有一定的显示效果（以两行分割线替代卡片）。\n\n## 渲染效果\n\n<a target=\"_blank\" href=\"https://github.com/OrangeX4/hexo-link-card\" style=\"position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;\"><span class=\"LinkCard-contents\"><span style=\"display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;\">OrangeX4/hexo-link-card - GitHub</span><span style=\"display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;\"><span style=\"display: inline-flex; align-items: center;\"><svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewBox=\"0 0 24 24\" width=\"14\" height=\"14\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"></path></svg></span><span>https://github.com/OrangeX4/hexo-link-card</span></span></span></a>\n\n图片展示：\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220210201854.png)\n\n## 卡片式链接的 VS Code 支持\n\n我们可以让 VS Code 也支持卡片式链接的语法，只需要下载好 Markdown Preview Enhanced 插件，按下 `Shift + Ctrl + P` 按钮，输入 `preview extend parser`，即可打开配置文件。\n\n然后将\n\n``` js\n  onWillParseMarkdown: function(markdown) {\n    return new Promise((resolve, reject)=> {\n      return resolve(markdown)\n    })\n  },\n```\n\n改为\n\n``` js\n  onWillParseMarkdown: function(markdown) {\n    return new Promise((resolve, reject)=> {\n      return resolve(markdown.replace(/----*\\n\\n([^\\n]*)\\n([a-zA-Z]*:\\/\\/[^\\n]*)\\n\\n----*/g, `<a target=\"_blank\" href=\"$2\" style=\"position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;\"><span class=\"LinkCard-contents\"><span style=\"display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;\">$1</span><span style=\"display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;\"><span style=\"display: inline-flex; align-items: center;\"><svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewBox=\"0 0 24 24\" width=\"14\" height=\"14\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"></path></svg></span><span>$2</span></span></span></a>`))\n      // return resolve(markdown)\n    })\n  },\n```\n\n即可。\n","tags":["VS Code","Markdown","Blog","Hexo","Link Card"],"categories":["Product"]},{"title":"VS Code 通过 Remote - SSH 远程连接腾讯云服务器","url":"/post/cloud-server-in-vscode-ssh/","content":"\n# VS Code 通过 Remote - SSH 远程连接腾讯云服务器\n\n每当我切换到一个新环境，例如新电脑、新系统时，总是会忘记如何配置 VS Code 中的 Remote - SSH，也就很难连上腾讯云服务器进行开发。\n\n所以我特意将配置的步骤写成一篇博文，记录如下。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208204402.png)\n\n<!-- more -->\n\n## 一、创建密钥\n\n为了更方便地连上服务器，无需手动输入密码，也为了更高的安全性，我们应该采用密钥的方式用以身份验证。\n\n首先，点击 **密钥** 面板，选择 **创建密钥** 。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208191525.png)\n\n然后，我们使用已有的公钥创建密钥，已有公钥的获取方式是执行 `ssh-keygen -t rsa -C \"<你的邮箱地址>\"`，然后复制在 `.ssh` 文件夹下的 `id_rsa.pub` 的内容。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208203329.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208203153.png)\n\n紧接着，我们点击 **绑定/解绑实例**，并将我们的服务器实例选择进去。注意，此时我们的服务器实例应该处于关机状态，否则无法进行密钥绑定。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208192211.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208192620.png)\n\n\n## 二、配置 Remote - SSH\n\n在 VS Code 里，按下快捷键 `Shift + Ctrl + P` 打开命令面板，输入 `ssh open` 并打开 Remote - SSH 的配置文件。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208193008.png)\n\n然后我们在配置文件中改写为：\n\n``` txt\nHost <自定义配置名称>\n  HostName <你的主机名或域名>\n  User ubuntu\n  Port 22\n```\n\n例如我的就是：\n\n``` txt\nHost tencent-cloud\n  HostName 1.15.xx.xx\n  User ubuntu\n  Port 22\n```\n\n随后，不要忘记将你的服务器实例开机。\n\n最后，按下快捷键 `Shift + Ctrl + P` 打开命令面板，输入 `ssh connect`，就可以开启愉快的远程开发之旅了。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220208204402.png)\n","tags":["VS Code","SSH","Server"],"categories":["Technology"]},{"title":"为自己搭建 RSS 订阅提醒服务","url":"/post/inkrss-for-self/","content":"\n# 为自己搭建 RSS 订阅提醒服务\n\n## 缘由\n\n自己一直苦于关注的信息源太杂, 每次想要查看新的信息, 都得打开一堆网站和 APP (如别人的博客, Github, 微博, 知乎, B站之类的). 为了改善自己的订阅体验, 在 [@Mexii](https://blog.mexii.one/) 的帮助下, 我开始研究如何给自己搭建一个体验良好的 RSS 订阅提醒服务.\n\n最终的解决方案如下:\n\n- Inkrss (开源项目, RSS 订阅提醒的核心, 使用免费的 Cloudflare Workers)\n- Vercel (免费的 Serverless 云函数服务, 能够免费托管 NodeJS, Python 代码)\n- 企业微信 Server 酱 (免费开通企业微信, 然后使用 Server 酱进行信息提醒)\n- RssHub (为了更好的体验, 需要托管在自建的服务器中, 需要服务器)\n\n大致效果如下:\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216084132.png)\n\n<!-- more -->\n\n\n## RssHub\n\n### 介绍\n\n[RssHub](https://docs.rsshub.app/) 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。比如微博, 知乎, B站, Lofter, 番剧更新网站等等.\n\n使用 Docker 部署起来非常简单.\n\n### 安装\n\n运行下面的命令下载 RSSHub 镜像.\n\n``` sh\ndocker pull diygod/rsshub\n```\n\n然后运行 RSSHub 即可.\n\n``` sh\ndocker run -d --name rsshub -p 1200:1200 diygod/rsshub\n```\n\n在浏览器中打开 [http://localhost:1200/](http://localhost:1200/).\n\n您可以使用下面的命令来关闭 RSSHub:\n\n``` sh\ndocker stop rsshub\n```\n\n### 更新\n\n删除旧容器:\n\n``` sh\ndocker stop rsshub\ndocker rm rsshub\n```\n\n然后重复安装步骤.\n\n### 添加配置\n\n配置运行在 docker 中的 RSSHub, 最便利的方法是使用 docker 环境变量:\n\n以设置缓存时间为 5 分钟举例, 只需要在运行时增加参数: `-e CACHE_EXPIRE=300`\n\n``` sh\ndocker run -d --name rsshub -p 1200:1200 -e CACHE_EXPIRE=300 -e GITHUB_ACCESS_TOKEN=example diygod/rsshub\n```\n\n该部署方式不包括 puppeteer 和 redis 依赖, 如有需要请改用 Docker Compose 部署方式或自行部署外部依赖.\n\n\n## Inkrss\n\nInkrss 的介绍在这里: [https://github.com/pureink/inkrss](https://github.com/pureink/inkrss)\n\n它支持通过微信或者 Telegram 进行提醒. 按照它文档的描述, 如果要用微信进行提醒, 我们要:\n\n1. 开通企业微信, 然后使用 Server 酱进行提醒.\n2. 在 Vercel 挂载一个 xml2json 的服务 (由于 Cloudflare 的限制, 基本上大部分 NPM 包都是不可用的)\n3. 通过 Cloudflare Workers 挂载 Inkrss.\n\n其中它的文档描述已经很详细了, 在此就不多赘述. 但是其中有几个坑, 需要注意一下.\n\n### 不支持使用 IP 地址直接访问 RSS 订阅源\n\n因为我使用的是自己搭建的 RssHub, 我的服务器在国内而且又没有备案, 所以导致只能通过 IP 地址直接访问 Rss 订阅源.\n\n最后我采用的方法是, 魔改 Inkrss 和 Vercel 上的云函数服务. \n\n我在 Vercel 上的云函数服务的 `/app` 目录下加入了一个叫 `xml2xml.js`, 看起来有点多此一举的文件. 内容如下:\n\n``` javascript\nimport axios from 'axios'\n\nmodule.exports = async (req, res) => {\n    const { body } = req\n    const { data } = await axios.get(body.url)\n    res.send(data)\n}\n```\n\n然后在 inkrss 的 `schedule.js` 文件中修改为:\n\n``` js\nlet resp;\nif (sub[i].url.startsWith(\"http://\")) {\n    resp = await fetch(`${config.PARSE_URL}/api/xml2xml`, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\",\n        },\n        body: JSON.stringify({\n            url: sub[i].url,\n        }),\n    });\n} else {\n    resp = await fetch(sub[i].url);\n}\nconst text = await resp.text();\n```\n\n我默认如果是 HTTP 请求, 不是 HTTPS 请求, 就通过 Vercel 间接获取.\n\n### 未对无时间属性的订阅源特殊处理\n\n如果对一些没有时间属性的订阅源进行订阅, 它将永远不会提醒, 例如 RssHub 中的番剧更新订阅源 \"agefans\". 所以我们要进行一些处理: 如果不存在时间属性, 那么只要第一个 item 的标题改变了, 就进行提醒.\n\n修改后的代码如下 (在 `schedule.js` 文件下):\n\n``` js\nlet lastUpdateTime = sub[i].lastUpdateTime;\nfor (let j = 0; j < data.items.length && i < config.maxItemsCount; j++) {\n    if (data.items[j].pubDate) {\n        // console.log(\"pubData: \" + data.items[j].pubDate);\n        // console.log(\"lastUpdateTime: \" + sub[i].lastUpdateTime);\n        if (new Date(data.items[j].pubDate) > new Date(sub[i].lastUpdateTime)) {\n            if (new Date(data.items[0].pubDate) > new Date(lastUpdateTime)) {\n                lastUpdateTime = data.items[0].pubDate;\n            }\n            lastUpdateTime = data.items[0].pubDate;\n            await reply(sub[i], data.items[j]);\n        }\n    } else {\n        // console.log(\"reply for not null\");\n        sub[i].lastUpdateTime = new Date().toLocaleString();\n        await reply(sub[i], data.items[j]);\n        break;\n    }\n}\n```\n\n### 微信相关的提醒服务的优化\n\nInkrss 的作者本身并不用微信来提醒, 所以对微信的提醒服务相应的处理不够全面. 例如, 没有进行 URL 转义, 发送消息可能出错; 提醒时只有标题和链接, 没有内容的问题.\n\n在 `notifications/wechat.js` 文件下, 原来的代码是:\n\n``` js\nawait fetch(`${config.WECHAT_URL}&msg_type=text&msg=${feed.title}\\n${item.title}\\n${item.link}`)\n```\n\n只有标题和链接 没有内容 `item.contentSnippet`.\n\n我修改之后的代码为:\n\n``` js\nif (item.contentSnippet) {\n    await fetch(`${config.WECHAT_URL}&msg_type=text&msg=${encodeURI(feed.title)}\\n---------------------------------------\\n${encodeURI(item.title)}\\n\\n${encodeURI(item.contentSnippet)}\\n\\nLink: ${encodeURI(item.link)}`);\n} else {\n    await fetch(`${config.WECHAT_URL}&msg_type=text&msg=${encodeURI(feed.title)}\\n---------------------------------------\\n${encodeURI(item.title)}\\n\\nLink: ${encodeURI(item.link)}`);\n}\n```","tags":["Technology","Cloudflare"],"categories":["Technology"]},{"title":"简单方便, 在 VS Code 中使用 Latex 公式和 Python 进行科学计算","url":"/post/latex-sympy-calculator/","content":"\n# 简单方便, 在 VS Code 中使用 Latex 公式和 Python 进行科学计算\n\n## 简介\n\n**Latex Sympy Calculator** 是一款 VS Code 插件, 它能够帮助你在 VS Code 写 Latex 或 Markdown 的时候, 一键计算 Latex 书写的数学公式.\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/Ud246889e25e84421a60a86435e693bfaJ.gif)\n\n**当前支持的功能:**\n\n1. **算术:** 加 (+), 减 (-), 点乘 (·), 叉乘 (×), 除法 (/), 乘方 (^), 绝对值 (|x|), 开方 (√), 虚数 (i)...\n2. **字母表:** 英文字母 a - z, A - Z, 希腊字母 α - ω, 下标 (x_1), 重音符 (ā)...\n3. **常见函数:** 最大公约数 (gcd), 最小公倍数 (lcm), 下界 (floor), 上届 (ceil), 最大值 (max), 最小值 (min), 取对数 (log), 自然对数 (ln), 指数 (exp), 三角函数 (sin, cos, tan, csc, sec, cot, arcsin, sinh, arsinh)...\n4. **微积分:** 求极限 ($lim_{n\\to\\infty}$), 求导/求微分 ($\\frac{d}{dx}(x^2+x)$), 求积分 ($\\int xdx$)...\n5. **线性代数:** 矩阵 (Matrix), 行列式 (Determinant), 转置 (Transpose), 求逆 (Inverse), 初等变换 (Elementary Transformation)...\n6. **关系符:** 大于 (>), 小于 (<), 大于等于 (≥), 小于等于 (≤), 相等 (=)...\n7. **其他:** 二项式...\n\n当然, 实际上还有很多其他的功能, **只要是 Python Sympy 包支持的运算, 都可以通过这个插件来实现**.\n\n通过这个插件, 你就不再需要一字一句地将 Latex 转译成其他语言, 然后用 Matlab 或 MMA 等数学软件进行科学计算了. 简单的 **符号推导**, **矩阵运算**, **微积分**, **科学计算**, 完全可以利用这个插件来实现. \n\n如果你也在 VS Code 中用 **Latex** 或 **Markdown** 写数学公式, 那么这就是你 **必备的 VS Code 科学计算插件**.\n\n[插件的 GitHub 页面](https://github.com/OrangeX4/Latex-Sympy-Calculator).\n\n[latex2sympy2 包的 Github 页面](https://github.com/OrangeX4/latex2sympy). \n\n<!-- more -->\n\n---\n\n**PS: 如果你不希望在 VS Code 中使用, 也可以独立出来, 单独使用这个 latex2sympy2 包进行 Latex 公式的科学计算, 详情请拉到本文的最下方. 甚至你可以把这个包集成到其他环境, 可能的例子有 Typora 或其他 Latex 编辑器?**\n\n---\n\n\n## 在 VS Code 中安装\n\n在 VS Code 的插件商店中, 搜索 `Latex Sympy Calculator` 并安装 `Install`.\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20210927180008.png)\n\n安装完成之后, 暂时还不能直接使用, 你还需要 **安装 Python**, **安装 Flask 包** 和 **安装 latex2sympy2 包**.\n\n**安装 Python:**\n\n你可以去 [官网](https://www.python.org/downloads/) 下载 Python3.\n\n如果你是 Windows, 而且觉得官网网络连接不稳定, 可以去 [软件中心](https://pc.qq.com/detail/5/detail_24685.html) 下载.\n\n如果你是 Mac, 可以使用 `brew install python` 安装 Python3.\n\n如果你是 Linux, 可以执行以下命令安装 Python3 和 Pip3:\n\n``` sh\nsudo apt install python3\nsudo apt-get install python3-pip\n```\n\n**安装 Flask 和 latex2sympy2 包:**\n\n执行以下命令:\n\n``` sh\npip install latex2sympy2\npip install Flask\n```\n\n如果使用的是 Mac 或 Linux, 并且安装失败了, 可以尝试用 `pip3` 替代 `pip`.\n\n**检查是否安装成功:**\n\n在命令行中, 输入 `python` 进入 **Python 交互环境**, 然后输入以下代码:\n\n``` python\nimport latex2sympy2\nimport flask\n```\n\n如果没有报错, 就说明安装成功了.\n\n\n## 在 VS Code 中使用\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/Ud246889e25e84421a60a86435e693bfaJ.gif)\n\n如同这个动图所展示的一样, 你可以选中一些内容, 然后按下快捷键, 就会输出相应的结果.\n\n### 计算 Latex 公式并输出 Latex 结果\n\n你可以选中一段 Latex 公式, 然后按下 `Shift + Ctrl + Alt + E` (equal) 获取相应的结果, 大概如下:\n\n``` latex\n# 计算前\n\\frac{d}{dx}(x^3+x^2+1)\n\n# 计算后\n\\frac{d}{dx}(x^3+x^2+1) = x \\left(3 x + 2\\right) \n```\n\n你也可以选中一段 Latex 公式, 然后按下 `Shift + Ctrl + Alt + R` (replace) 获取相应的结果, 这个快捷键与上一个的唯一区别是, 它会直接替换掉你选中的公式, 大概如下:\n\n``` latex\n# 计算前\n\\frac{d}{dx}(x^3+x^2+1)\n\n# 计算后\nx \\left(3 x + 2\\right) \n```\n\n### 因式分解与展开\n\n你可以选中一段文本, 然后按下 `Shift + Ctrl + Alt + F` (factor) 来获取这段表达式的因式分解. 大概如下:\n\n``` latex\n# Before\nx^{2} + 2 x y + y^{2}\n\n# After\n(x + y)^{2}\n```\n\n你可以选中一段文本, 然后按下 `Shift + Ctrl + Alt + X` (expand) 来获取这段表达式的展开. 大概如下:\n\n``` latex\n# Before\n(x + y)^{2}\n\n# After\nx^{2} + 2 x y + y^{2}\n```\n\n### 计算 Latex 公式并输出数值结果\n\n你可以选中一些文本, 并按下 `Shift + Ctrl + Alt + N` (numerical) 来获取当前 Latex 公式的. 大概如下:\n\n``` latex\n# 计算前\n\\sqrt{2}\n\n# 计算后\n\\sqrt{2} = 1.41421356237310 \n```\n\n### 变量\n\n你可以**定义并赋值**一个变量. 使用 `Shift + Ctrl + Alt + D` (define) 快捷键和类似 `y = x + 1` 的语法实现这个功能.\n\n``` latex\n# 按下 Shift + Ctrl + D 进行变量定义与赋值\ny = x + 1\n\n# Shift + Ctrl + E\n# 计算前\n2y\n# 计算后\n2y = 2 x + 2\n\n# 你可以看出, y 被替换成了 x + 1 来参与计算\n```\n\nPS: 如果你计算的是 `y == x + 1`, 它不是变量定义与赋值, 它输出的是 `true` 或 `false`, 代表着这个等式是否成立.\n\n如果你想查看现有已定义的变量, 你可以按下 `Shift + Ctrl + P`, 然后输入 `latex-sympy-calculator: Show Current variances` 并运行, 然后你就会获取到类似这样的数据:\n\n``` latex\ny = x + 1\nz = 2x\n```\n\n如果你想清除这些已经定义的变量, 你可以按下 `Shift + Ctrl + P`, 然后输入 `latex-sympy-calculator: Reset Current variances` 并运行.\n\n如果你想要关闭虚数 `i` 的支持, 可以按下 `Shift + Ctrl + P`, 然后输入 `latex-sympy-calculator: Toggle Complex Number Support For Variances`.\n\n虚数功能类似这样: `x = 1 + 2i`, `\\int \\cos xe^{-ikx}dx`.\n\n### 矩阵符号\n\n你可以定义矩阵符号用于矩阵推导. 使用 `Shift + Ctrl + Alt + D` (define) 和类似 `X \\in \\mathbb{R}^{n \\times m}` 的语法即可.\n\n``` latex\n# Shift + Ctrl + D\nX \\in \\mathbb{R}^{n \\times m}\n\n# Shift + Ctrl + E\n# 计算前\nX X^{T} X\n# 计算后\nX X^{T} X\n\n# Shift + Ctrl + E\n# 计算前\nX^{-1} X\n# 计算后\nI\n```\n\n\n### 在 VS Code 中执行 Python 表达式\n\n你可以用快捷键 `Shift + Ctrl + Alt + P` 计算一个 Python 表达式.\n\n**支持所有的 Sympy 和 latex2sympy2 包的功能.**\n\n例如, 你可以获取当前已经定义的变量值:\n\n``` python\n# 运算前\nvar['y']\n\n# 运算后\nvar['y'] = x + 1\n```\n\n你可以解方程:\n\n``` python\n# 运算前\nsolve([2 * x - y - 3, 3 * x + y - 7],[x, y])\n\n# 运算后\nsolve([2 * x - y - 3, 3 * x + y - 7],[x, y]) = {x: 2, y: 1}\n```\n\n将 Latex 转成 Sympy 和将 sympy 转成 latex:\n\n``` python\n# Latex to Sympy\nexpr = latex2sympy(r'x^2 + 3x + 1')\n\n# Sympy to Latex\nlatex = latex(expr)\n\n# Latex to Latex\nresult = latex2latex(r'\\frac{d}{dx}(x^3+x^2+1)')\n```\n\n**举一个更综合的例子吧, 你可以带着运算过程, 进行特征值的求解:**\n\n``` latex\n对于矩阵: $A=\\begin{bmatrix}\t5 &6 &-3 \\\\\t-1 &0 &1 \\\\\t1 &2 &-1 \\\\\\end{bmatrix}$\n\n我们令 $B=\\lambda\\begin{bmatrix}1 &0 &0 \\\\0 &1 &0 \\\\0 &0 &1 \\\\\\end{bmatrix}-\\begin{bmatrix}\t5 &6 &-3 \\\\\t-1 &0 &1 \\\\\t1 &2 &-1 \\\\\\end{bmatrix}=\\left[\\begin{matrix}\\lambda - 5 & -6 & 3\\\\1 & \\lambda & -1\\\\-1 & -2 & \\lambda + 1\\end{matrix}\\right]$\n\n它的行列式是 $latex(var[\"B\"].doit().det()) = \\lambda^{3} - 4 \\lambda^{2} + 2 \\lambda + 4$\n\n对它进行因式分解可得: $latex(factor(var[\"B\"].doit().det())) = \\left(\\lambda - 2\\right) \\left(\\lambda^{2} - 2 \\lambda - 2\\right)$\n\n求出对应的特征值 $latex(solve(var[\"B\"].doit().det())) = \\left[ 2, \\  1 - \\sqrt{3}, \\  1 + \\sqrt{3}\\right]$\n\n或我们可以用 Sympy 直接计算出结果: $latex(var[\"A\"].eigenvals()) = \\left\\{ 2 : 1, \\  1 - \\sqrt{3} : 1, \\  1 + \\sqrt{3} : 1\\right\\}$\n\n我们再令 $\\lambda_1=2, \\lambda_2=1-\\sqrt{3}, \\lambda_3=1+\\sqrt{3}$\n\n所以可知 $B_1=\\lambda_1\\begin{bmatrix}1 &0 &0 \\\\0 &1 &0 \\\\0 &0 &1 \\\\\\end{bmatrix}-\\begin{bmatrix}\t5 &6 &-3 \\\\\t-1 &0 &1 \\\\\t1 &2 &-1 \\\\\\end{bmatrix}=\\left[\\begin{matrix}-3 & -6 & 3\\\\1 & 2 & -1\\\\-1 & -2 & 3\\end{matrix}\\right]$\n\n赋值给变量: $B_1=\\left[\\begin{matrix}-3 & -6 & 3\\\\1 & 2 & -1\\\\-1 & -2 & 3\\end{matrix}\\right]$\n\n用初等行变换化简:\n\n$latex(var[\"B_1\"].doit().rref()) = \\left( \\left[\\begin{matrix}1 & 2 & 0\\\\0 & 0 & 1\\\\0 & 0 & 0\\end{matrix}\\right], \\  \\left( 0, \\  2\\right)\\right)$\n\n对于特征值 $\\lambda_1=2$, 它的一个特征向量是 $\\xi_1=\\begin{pmatrix}-2\\\\1\\\\0\\end{pmatrix}$\n\n所以对于特征值 $\\lambda_1=2$, 它的全部特征向量是 $k_1\\xi_1 \\ (k_1\\neq 0, k_1\\in P)$\n\n同样地, 我们可以获取到所有的特征值和特征向量:\n\n$latex(var[\"A\"].eigenvects()) = \\left[ \\left( 2, \\  1, \\  \\left[ \\left[\\begin{matrix}-2\\\\1\\\\0\\end{matrix}\\right]\\right]\\right), \\  \\left( 1 - \\sqrt{3}, \\  1, \\  \\left[ \\left[\\begin{matrix}6 - 3 \\sqrt{3}\\\\-2 + \\sqrt{3}\\\\1\\end{matrix}\\right]\\right]\\right), \\  \\left( 1 + \\sqrt{3}, \\  1, \\  \\left[ \\left[\\begin{matrix}3 \\sqrt{3} + 6\\\\-2 - \\sqrt{3}\\\\1\\end{matrix}\\right]\\right]\\right)\\right]$\n```\n\n## 在非 VS Code 环境下使用\n\n**Sympy** 是一个使用 Python 书写的符号运算包, 可以通过它进行各种各样的科学计算. 想要使用 Sympy, 你需要先写出一个 Sympy 表达式.\n\nSympy 表达式可以使用自带的功能转为 Latex 公式, 但是 Sympy 没有提供自带的 Latex 公式转 Sympy 表达式的功能.\n\n所以我们需要另外一个, 我在开源项目的基础上进行过相应扩展的包: `latex2sympy2`. 它可以将 Latex 表达式转为 Sympy 表达式.\n\n### 安装 Sympy 和 latex2sympy2 包\n\n**执行以下命令:**\n\n``` sh\npip install latex2sympy2\npip install sympy\n```\n\n如果使用的是 Mac 或 Linux, 并且安装失败了, 可以尝试用 `pip3` 替代 `pip`.\n\n**检查是否安装成功:**\n\n在命令行中, 输入 `python` 进入 **Python 交互环境**, 然后输入以下代码:\n\n``` python\nimport latex2sympy2\nimport sympy\n```\n\n如果没有报错, 就说明安装成功了.\n\n### 计算 Latex 表达式并以 Latex 形式输出\n\n``` python\nfrom latex2sympy2 import latex2latex\n\nresult = latex2latex(r\"\\frac{d}{dx}(3x^2 + 2x + 1)\")\n\nprint(result)\n```\n\n### 将 Latex 表达式转为 Sympy 表达式\n\n``` python\nfrom latex2sympy2 import latex2sympy\nfrom sympy.abc import *\nfrom sympy import latex\n\nexpr = latex2sympy(r\"\\frac{d}{dx}(3x^2 + 2x + 1)\")\n\n# 直接打印表达式\nprint(expr)\n\n# 将这个表达式运算化简之后 (这里是求导), 加上 x 并输出\nprint(expr.doit() + x)\n\n# 在上一个语句的基础上, 转成 Latex 形式之后再输出\nprint(latex(expr.doit() + x))\n```\n\n### 其他语法\n\n更多的 Sympy 语法可以看看 [Sympy 的官方文档](https://docs.sympy.org/latest/index.html).\n\n里面有许多例子, 例如使用 `latex2sympy(\"\\sqrt{2}\").evalf()` 获取数值结果等功能, 这里就不多赘述.\n\n\n## 在其他编辑器中集成\n\n其实, 提供了这个 Python 包之后, 理论上只要一个编辑器**支持使用插件**, 并能够**调用相应的 Python 包**, 就能集成这个 Latex 公式科学计算的功能.\n\n例如, 如果你在使用 **Vim**, 你可以用 **UltiSnips** 插件调用这个 Python 包, 然后取得计算的结果并输出.\n\n再例如, 你想要在 **Typora** 中集成, 只要你想办法在 Typora 中写一个插件, 并调用相应的 Python 包和函数, 就能实现科学计算的功能. 由于 Typora 不开源, 并且对第三方插件还没有太好的支持, 所以我暂时没有办法为 Typora 实现相应的拓展.\n\n最后, 如果你**不想在任何编辑器中使用**, 只是想要一个**独立的软件或程序**, 带有简洁的 UI 和简洁的 Latex 公式计算功能, 可以跟我反馈, 我后续可能考虑写一个简单的软件.\n\n## 扩展 latex2sympy2 包的语法\n\n如果你认为 `latex2sympy2` 包还不能满足你的需求, 可以考虑帮忙扩展 `latex2sympy2` 的语法!\n\n[latex2sympy2 包的 Github 页面](https://github.com/OrangeX4/latex2sympy). \n\n`latex2sympy2` 是在 [augustt198/latex2sympy](https://github.com/augustt198/latex2sympy) 和 [purdue-tlt / latex2sympy](https://github.com/purdue-tlt/latex2sympy) 的基础上进行增强的项目.\n\n其中转译器使用了 [ANTLR](http://www.antlr.org/), 你可以使用它进行语法的扩展.\n\n其中语法定义在 `PS.g4` 文件中, 参考 ANTLR 的文档, 你可以轻易地定义一个新的语法. 在更新完语法之后, 你还需要在 `latex2sympy2.py` 中解析你的语法, 并转成 Sympy 表达式.\n\n更详细的描述在 [这里](https://github.com/purdue-tlt/latex2sympy). \n\n## End\n\n**最后, 感谢你看到这里!**","tags":["VS Code","Math","Python","Markdown","Latex","Product","Sympy","Calculator"],"categories":["Product"]},{"title":"在提问之前","url":"/post/before-asking-questions/","content":"\n# 在提问之前\n\n阅读[《提问的智慧》](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md)有感.\n\n每一个人, 特别是学计算机的人, 都要学会通过 STFW 和 RTFM 独立解决问题. 这是由多方原因决定的.\n\n<!-- more -->\n\n## 编程的复杂性\n\n编程在一般情况下并不是一件非常困难的工作, 但编程一定是一件复杂的工作.\n\n软件的本质是它的复杂性, 没有足够复杂度的软件, 是无法应对用户多样性的需求的. 既然软件成品尚且如此复杂, 在编程的过程自然更加地复杂, 你必须面对多种多样的情况, 处理数不胜数的 bugs, 在极大的努力下才能做出成果.\n\n编程的复杂性往往又会导致下面几种结果.\n\n首先, 编程的复杂性意味着人们必须共同协作, 共同编程. 我编写的程序, 往往建立在你建立的平台上, 使用着他提供的第三方库, 最后部署在她维护的不同系统的服务器上. 这个过程往往是充满了纰漏的: 我并不知道你的平台是否稳定, 他提供的第三方库里是否存在着 bugs 甚至是后门, 她使用的服务器也不一定完全兼容我写的代码.\n\n因为没有人能够真正完全掌握这浩如烟海的细节, 每个人能够掌控并了解的只有自己所写的那一部分, 将不同部分组合起来, 往往就会带来各种问题. 每个人写的代码不同, 遇到的问题自然也有所不同, 别人也并不了解你写的代码, 你也很难依靠别人给你一个详细的解答, 这时候, 请 STFW 和 RTFM 吧.\n\n其次, 编程的复杂性意味着我们的工作总是\"创造性\"的, 即使不是\"创造性\"的, 至少也是\"有差异的\".\n\n编程不像数学题, 大部分解答起来不困难的数学题都已经有了现成的答案, 剩下未解决的数学题往往都是非常困难的, 只有少数数学家敢于去挑战. 而编程不一样, 每一个程序, 每一个软件, 每一个应用, 都是不一样的. 即使看起来功能上大体相同, 也会在很多细节上, 或者底层实现上有相当大的差异. 再次提及这个观点: 绝大多数的编程任务并不困难, 但依然复杂.\n\n大部分编程任务并不困难, 这意味可以让更多不能成为顶尖数学家的普通人参与进编程任务中; 编程依然复杂, 这意味着不能简单通过寻找现成的\"答案\"来完成一个程序的编写, 即不能自动化地完成, 也就需要许多拥有一定编程知识和经验的程序员来完成一个个的编程任务. 这些编程任务都是\"创造性的\"或\"有差异的\", 这自然使得每一个程序员都要像\"创作\"一样, 独立解决问题.\n\n第三, 编程的复杂性意味着容易出现 bugs. 我们都是人类, 不是机器. 机器也许能够保证不犯错且二十四小时工作, 但是人类一定不行.\n\n每个人都会犯错, 这个事实, 在我们上中学学习数学并参加数学考试以来, 就已经人尽皆知了. 我们做数学题会算错数, 写语文作文时会写错字, 自然在编程的时候也很可能会写下许多的 bugs. 而且往往我们自己也很难发觉为什么会引起这种 bugs. 既然最了解自己写的代码的我们也很难找出 bugs, 自然也很难指望别人帮我们找出 bugs, 最终还是得靠自己 STFW 和 RTFM.\n\n## 用好互联网\n\nSTFW 的意思是用好网页搜索 (Search The Friendly Web). 我们生活在互联网的时代, 我们可以很方便地在网络上搜索, 分享信息. 也许你不能在网络上找到你丢失的一双袜子, 但是对于我们犯的蠢, 很有可能在网络上发现别人也曾经犯过相同的蠢.\n\n要善于利用出 bugs 时的报错信息, 有一些网站可以很容易地根据报错信息找出可能犯的错误, 例如网站 Stack Overflow. 即使没有现成的解答, 你也可以在相应的论坛, 或用 Github Issues 功能找到一些相关的信息.\n\n想要更广泛, 方便地找到这些信息, 用好搜索引擎也很重要. 我们要注意: 互联网上 90% 的内容是用英语书写的, 所以我们最好用英文来搜索, 不要用中文. 而且搜索引擎最好使用 Google 这些有口皆碑的搜索引擎. 最好不要用 Baidu 搜中文信息, 更不要用 Baidu 搜英文信息, 它对信息搜集的召回率和准确率都远低于 Google. 并且, 要用好一些额外的搜索功能, 例如\"用双引号括住关键词\"代表了搜索出来的网页一定要包括该关键词, 用 \"site:\" 功能实现对指定网站内容的搜索等等.\n\n除了搜索网页外, 我们还可以 RTFM, 即查看官方文档 (Read The Friendly Manual). 我们可以通过互联网找到相应的资源. 学会自己看文档, 对于编程来说, 非常重要.\n\n## 提问的方式\n\n如果经过 STFW 和 RTFM 之后, 还是找不到解决方案, 也许你可以考虑去询问他人了.\n\n但是, 请注意提问的方式!\n\n别人没有义务回答你的问题, 所以你必须想办法激起别人的兴趣, 让别人乐意回答.\n\n首先, 最重要的是准确描述问题. 准确描述问题非常重要, 你不能以一种模棱两可的方式进行提问, 例如 \"为什么我的电脑突然死机了\" 这种问题, 没有提供任何有用的信息, 自然也别想指望别人帮助你. 为了更好的描述问题, 你还需要讲述你为了解决这个问题所做出的努力, 例如加上 \"我尝试了网上搜索出来的方案一, 问题并没有解决\", 这样, 别人至少能排除一种可能的情况, 也可以知道你并非坐等其成的人. 除此之外, 最好描述你中遇到问题之前做的操作, 提供复现的方式 (例如可以复现的代码 repo), 这样能给别人帮你解决问题提供很大的便利.\n\n其次, 要注意询问的方式. 时刻牢记, 别人没有义务为你解答, 所以不要趾高气扬地提问, 也不要抱着一种理所应当的态度. 在解决问题之后, 至少要表示你的感谢, 否则别人很可能因为你的态度, 而在下一次你提问的时候拒绝帮助你. 还有, 尽量少用私人联系方式向他人提问, 更应该中论坛, 问答网站或 Github Issues 这类公共的地点提问, 这是为了方便帮助以后再次碰到类似问题的人, 这样他们就可以通过 STFW 找到答案, 避免了重复提问与重复回答.\n\n## 总结\n\n提问的智慧很重要, 而学会通过 STFW 和 RTFM 独立解决问题, 是避免发起不必要提问的好办法. 先学会独立解决问题, 这才是最好的提问的智慧.","tags":["Thoughts"],"categories":["Thoughts"]},{"title":"在 Markdown 中书写伪代码","url":"/post/markdown-pseudocode/","content":"\n# 在 Markdown 中书写伪代码\n\n## 0. 想法来源\n\n最近上算法课需要书写伪代码, 但伪代码一般都是通过 Latex 书写的, 但我又不想专门为了它去写 Latex, 所以就开始考虑如何在 Markdown 中书写伪代码.\n\n根据 \"Atwood's Law\" 原则:\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript.\n> \n> 任何可以用 JavaScript 来写的应用, 最终都将用 JavaScript 来写.\n\n我再次将目光投向前端, 寻找符合前端思想的解决方案.\n\n最终我选定了 VS Code + Markdown Preview Enhanced + pseudocode.js 的组合.\n\n(缺点是不能在 VS Code 中实时预览, 这个问题的主要原因是我不想再次魔改和维护别人写的插件了.)\n\n大概效果:\n\n![](https://pic4.zhimg.com/80/v2-baee81855005c2556010dcc197869157_720w.jpg)\n\n<!-- more -->\n\n## 1. 环境要求\n\n环境要求很简单, 你只需要安装好 VS Code 和 Markdown Preview Enhanced 插件, 这部分十分简单, 就不多说了.\n\n![](https://pic2.zhimg.com/80/v2-bb2b303c73fe56b828eef36f4728bae5_720w.jpg)\n\n## 2. 修改配置\n\n**这部分是最核心最重要的**, 我们要给 Markdown Preview Enhanced 插件加点魔改配置.\n\n按下快捷键 `Ctrl + Shift + P`, 打开 VS Code 命令窗口, 输入 `Markdown Preview Enhanced: Extend Parser` 命令并回车运行.\n\n![](https://pic1.zhimg.com/80/v2-8f640d22cf4355dfba0d367648bb77c4_720w.jpg)\n\n可以看见原来的代码长这样:\n\n![](https://pic4.zhimg.com/80/v2-5cdbd39df3a283a2003d2a9439339127_720w.jpg)\n\n我们用这些代码将原来的代码 `Ctrl + A` 和 `Ctrl + V` 完整替换成以下代码:\n\n``` javascript\nmodule.exports = {\n  onWillParseMarkdown: function(markdown) {\n    return new Promise((resolve, reject)=> {\n      return resolve(markdown)\n    })\n  },\n  onDidParseMarkdown: function(html, {cheerio}) {\n    return new Promise((resolve, reject)=> {\n      return resolve(`\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js\"\n    integrity=\"sha256-F/Xda58SPdcUCr+xhSGz9MA2zQBPb0ASEYKohl8UCHc=\" crossorigin=\"anonymous\">\n</script> \n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js\">\n</script>\n` + html + `\n<script>\nelements = document.getElementsByClassName(\"pseudocode\");\nfor (var i = 1; i <= elements.length; i++) {\n    setTimeout(function() {\n        var element = document.getElementsByClassName(\"pseudocode\")[0];\n        pseudocode.renderElement(element, { lineNumber: element.getAttribute(\"lineNumber\") == \"true\" });\n    }, i * 100);\n}\n</script>`)\n    })\n  },\n  onWillTransformMarkdown: function (markdown) {\n        return new Promise((resolve, reject) => {\n            return resolve(markdown);\n        });\n    },\n  onDidTransformMarkdown: function (markdown) {\n      return new Promise((resolve, reject) => {\n          return resolve(markdown);\n      });\n  }\n}\n```\n\n最后, `Ctrl + S` 保存这个配置文件.\n\n## 3. 写伪代码\n\n然后我们就可以在 Markdown 中写伪代码了, 你可以用下面这段代码测试:\n\n``` latex\n<pre class=\"pseudocode\">\n% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)\n\\begin{algorithm}\n\\caption{Quicksort}\n\\begin{algorithmic}\n\\PROCEDURE{Quicksort}{$A, p, r$}\n    \\IF{$p < r$} \n        \\STATE $q = $ \\CALL{Partition}{$A, p, r$}\n        \\STATE \\CALL{Quicksort}{$A, p, q - 1$}\n        \\STATE \\CALL{Quicksort}{$A, q + 1, r$}\n    \\ENDIF\n\\ENDPROCEDURE\n\\PROCEDURE{Partition}{$A, p, r$}\n    \\STATE $x = A[r]$\n    \\STATE $i = p - 1$\n    \\FOR{$j = p$ \\TO $r - 1$}\n        \\IF{$A[j] < x$}\n            \\STATE $i = i + 1$\n            \\STATE exchange\n            $A[i]$ with $A[j]$\n        \\ENDIF\n        \\STATE exchange $A[i]$ with $A[r]$\n    \\ENDFOR\n\\ENDPROCEDURE\n\\end{algorithmic}\n\\end{algorithm}\n</pre>\n```\n\n如果你需要加入 **行号** 功能, 可以像下面这样写:\n\n``` latex\n<pre class=\"pseudocode\" lineNumber=\"true\">\n% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)\n\\begin{algorithm}\n\\caption{Quicksort with lineNumber}\n\\begin{algorithmic}\n\\PROCEDURE{Quicksort}{$A, p, r$}\n    \\IF{$p < r$} \n        \\STATE $q = $ \\CALL{Partition}{$A, p, r$}\n        \\STATE \\CALL{Quicksort}{$A, p, q - 1$}\n        \\STATE \\CALL{Quicksort}{$A, q + 1, r$}\n    \\ENDIF\n\\ENDPROCEDURE\n\\PROCEDURE{Partition}{$A, p, r$}\n    \\STATE $x = A[r]$\n    \\STATE $i = p - 1$\n    \\FOR{$j = p$ \\TO $r - 1$}\n        \\IF{$A[j] < x$}\n            \\STATE $i = i + 1$\n            \\STATE exchange\n            $A[i]$ with $A[j]$\n        \\ENDIF\n        \\STATE exchange $A[i]$ with $A[r]$\n    \\ENDFOR\n\\ENDPROCEDURE\n\\end{algorithmic}\n\\end{algorithm}\n</pre>\n```\n\n语法基本类同 Latex 的 algorithmic 包, 语法详情参考 [这里](https://github.com/SaswatPadhi/pseudocode.js).\n\n## 4. 查看方式\n\n前面我也提到, 用这种奇葩的方式, 在 VS Code 的 MPE 插件中是不能实时预览的, 需要用浏览器打开.\n\n![](https://pic1.zhimg.com/80/v2-5c0df642bac92b4df3adc19cce6de138_720w.jpg)\n\n最后打印, 输出成 PDF 格式即可.\n\n![](https://pic2.zhimg.com/80/v2-db393007ba38bda0c9e8bb1d121a08c9_720w.jpg)\n","tags":["Study","VS Code","Math","Markdown","Technology"],"categories":["Technology"]},{"title":"Reversi 黑白棋的前端界面与 AI 实现","url":"/post/reversi/","content":"\n# Reversi 黑白棋的前端界面与 AI 实现\n\n## 1. 黑白棋\n\n**黑白棋**, 又叫翻转棋 (Reversi), 奥赛罗棋 (Othello), 苹果棋或正反棋 (Anti reversi). 黑白棋在西方和日本很流行. 游戏通过相互翻转对方的棋子, 最后以棋盘上谁的棋子多来判断胜负. 它的游戏规则简单, 因此上手很容易, 但是它的变化又非常复杂. \n\n### 在线网址: [https://reversi.orangex4.cool/](http://1.15.246.22/)\n\n<!-- more -->\n\n## 2. 游戏逻辑和前端界面\n\n### 2.1 双人对战\n\n拥有基本的黑白棋游戏判断逻辑, 和简洁的界面显示.\n\n用于在一台设备上自娱自乐 (并不.\n\n并且可以保存对局数据, 便于后续分析.\n\n![](https://pic4.zhimg.com/80/v2-884df6e1a408b852aca322efab86ba2b_720w.jpg)\n\n### 2.2 人机对战\n\n通过前后端分离的设计, 前端用前端全家桶实现, 后端使用 Python 语言, 便于整合黑白棋 AI 算法.\n\n目前已经有数位小伙伴把 AI 放到这里了!\n\n比如杰哥, czz 和阿伟.\n \n还有我自己的 AI: OrangeX5.\n\n![](https://pic2.zhimg.com/80/v2-bb45f31f1cce0e88eeff0aea67d46a69_720w.jpg)\n\n### 2.3 联机对战\n\n经过好几天的奋斗, 终于加入了联机功能!\n\n虽然实现的不是很优雅, 但是支持十个对局的 \"高 (di) 并发\" 应该没问题??\n\n![](https://pic1.zhimg.com/80/v2-9ef05663877ba5370081c80dad3aab94_720w.jpg)\n\n### 2.4 AI 对战\n\n我们可以让 AI 打 AI!\n\n这样就能快乐地以可视化的方式看 AI 打架了.\n\n(虽然服务器可能撑不住...)\n\n![](https://pic2.zhimg.com/80/v2-50aefcfc6dc4b6dc47de18666607edc1_720w.jpg)\n\n### 2.5 使用技术\n\n- 前端必备三个基础知识: **HTML + CSS + JS**\n- 前端框架: **React (React Hook + Typescript)**\n- 组件库: **Ant Design**\n\n![](https://pic2.zhimg.com/80/v2-72c6280fa30ef44ec93ae543f99b1d59_720w.jpg)\n\n### GitHub 地址: [https://github.com/OrangeX4/Reversi-Front](https://github.com/OrangeX4/Reversi-Front)\n\n\n## 3. 黑白棋 AI\n\nOrangeX5 使用了最朴实无华的算法.\n\n基本使用了以下的方法:\n\n1. **广度优先**, 深度设定为 4 ~ 6 层, 和蒙特卡洛的深度优先不同.\n2. **Alpha-Beta 剪枝**, 在深度一定的情况对结果没有影响, 但是可以加快运算效率.\n3. **缓存**, 对于一个纯函数 (pure function) 来说, 输入一定, 输出就一定, 所以可以缓存起来.\n4. **评估函数** (evaluate), 用于评估当前局面:\n   1. **角点策略**\n   2. **稳定子策略**\n   3. **前沿子策略**\n   4. **行动力策略**\n\n其实还有许多其他的策略, 因为实现起来没有上面的策略简单, 所以没有加进去.\n\n### 3.1 广度优先\n\n**广度优先搜索算法** (英语: Breadth-First Search, 缩写为 BFS), 又译作宽度优先搜索, 或横向优先搜索, 是一种图形搜索算法. 简单的说, BFS 是从根节点开始, 沿着树的宽度遍历树的节点. 如果所有节点均被访问, 则算法中止.\n\n对于棋类游戏来说, 我们自然不可能从一开始就把所有的局面都访问一遍, 因为可能性太多了, 对于黑白棋来说, 可达 $2^{60}=1152921504606846976$ 种, 即 $10^{10}$ 亿种可能性, 假设计算机每秒能够处理 $100$ 万 个局面, 也要 $10^{12}$ 秒, 即 **$10000$ 年**才能算出一步.\n\n所以我们不太可能直接运算到结尾, 那么我们就需要限定搜索的深度, 达到一定深度后, 用一种方式评估当前局面的好坏 (即评估函数 `evaluate`), 来确定要不要下这步子.\n\n假设我们已经能够评估一个局面的好坏, 那么我们怎么根据评估的结果, 来判断我们要下的地方呢?\n\n我们拿一个简单的例子来举例:\n\n![](https://pic3.zhimg.com/80/v2-90f8a1dc8c431ea5137f665a780a29aa_720w.jpg)\n\n图片来源: [www.dreamwings.cn](www.dreamwings.cn)\n\n在这张图中, **圆圈代表自己, 方块代表对手**, 其中 $A_1$ 是我们的一个可以下的棋, 我们可以下的位置是 $A_1, A_1', A_1''\\cdots$. 在这里我们考虑 $A_1$ 点, 我们要做的是, 得到 $A_1$ 这一步的分数.\n\n假设我们设定深度为 3 层, 在第 3 层的时候, 我们对当前局面进行评估, 即调用 `evaluate` 函数, 得到当前局面的得分, 在图中分别是 $A_2, A_3, A_4, A_5$.\n\n我们可以看出, 我们虽然想要选 $B_2$ 下的 $A_4$, 它的分数最高, 有 $20$ 分, 但是对手肯定不会让我们如愿以偿, 所以对手肯定是会选 $B_1$, 那么我们只能选最小值 $B_1$ 对应的最大值 $A_2$.\n\n或者说我们从对手的角度来理解, 我们取得高分, 即对手取得低分, 所以只要**在返回上一层**的时候将分数取负, 那就变成了对手的分数, 这时候我们可以**统一为取最大值**.\n\n\n### 3.2 Alpha-Beta 剪枝\n\n这种方法遍历层数过深的话, 还是会很慢. 所以我们需要想办法将其优化.\n\n![](https://pic3.zhimg.com/80/v2-e49a5ef3c84282e6c11c5e057719a13e_720w.jpg)\n\n在我们已经知道了 $B_1$ 点的分值是 $10$ 的时候, 如果我们求出 $A_4$ 点的分值是 $20$, 可以看出 $B_1=10<A_4=20$, 这时候知道, $B_2$ 已经有一个值大于 $B_1$ 了, 那么 $B_2>B_1$ 是必定成立的事, 由对手要选最小值我们可以知道, 一定不会选 $B_2$, 那么 $A_5$ 的局面自然也就不必评估了.\n\n这样, 我们就达到了减去无用枝叶的效果.\n\n更多内容可以前去 [Alpha-Beta 剪枝算法](http://www.soongsky.com/othello/computer/alpha_beta.php) 了解.\n\n这部分我的实现为:\n\n``` python\ndef alpha_beta(board, current, alpha, beta, depth, is_pass = False):\n    '''\n    alpha-beta 剪枝算法\n    参数:\n    board: 棋盘数据, 0 代表空格, 1 代表黑棋, -1 代表白棋;\n    current: 当前是谁下, 传入 1 或 -1;\n    alpha: 区间 [alpha, beta] 中的下限 alpha, 通过 -alpha 变成下层的 beta;\n    beta: 区间 [alpha, beta] 中的上限 beta, 用于判断是否剪枝;\n    depth: 深度, 一般设为 4 ~ 6;\n    is_pass: 用于判断上次是否也无子可下, 上次和这次均无子可下的话, 游戏结束.\n    返回值:\n    best_value: 评分;\n    best_position: 对应的位置, 如 (0, 2).\n    '''\n    # 开始递归判断\n    best_value = -inf\n    best_position = (-1, -1)\n    movables = get_movables(board, current)\n    for movable, reversals in movables.items():\n        # 初始化\n        value = 0\n        new_board = get_new_board(board, current, movable, reversals)\n        if depth == 0:\n            # 深度为 0 时, 评估当前局面, 并且取反以表示当前分数\n            value = -evaluate(new_board, -current)\n        else:\n            # 深度不为 0 时, 递归调用\n            value = -alpha_beta(new_board, -current, -beta, -alpha, depth - 1)[0]\n        # 如果触发剪枝\n        if value >= beta:\n            return value, movable\n        # 如果优于前面的下法\n        if value > best_value:\n            best_position = movable\n            best_value = value\n            # 更新下限\n            if value > alpha:\n                alpha = value\n    # 无子可下的情况\n    if len(movables) == 0:\n        if is_pass:\n            # 游戏结束, 直接获取最后结果, 并且得分是像 10000 这种极端分数\n            best_value = get_score(board, current)\n        else:\n            # 没结束的话, 就继续呗\n            best_value = -alpha_beta(board, -current, -beta, -alpha, depth, True)[0]\n    \n    # 处理意外情况, 随便选一个\n    if best_position == (-1, -1) and len(movables.keys()) > 0:\n        movables.keys()[randint(0, len(movables) - 1)]\n    return best_value, best_position\n```\n\n### 3.3 缓存\n\n函数式编程有一个很重要的原则: 尽量使用**纯函数** (pure function).\n\n什么是**纯函数**? 纯函数就是, **给定相同的输入**, 一定**有相同的输出**, 且**没有任何副作用**的函数. 数学函数就是真正的纯函数, 如三角函数 `sin`, 给定相同的输入 `x`, 一定会有相同的输出 `y`.\n\n纯函数有什么好处呢? **可控, 没有副作用, 支持高并发, 可以很方便地缓存**.\n\n**支持高并发**是因为, 每个用户均有自己的数据, 他们不需要争夺对同一个数据的使用和修改权, 所以可以很方便地将纯函数部署到不同的服务器上, 而不用担心资源共享, 服务器通信和资源锁之类的麻烦问题.\n\n而**缓存**就更为简单了, 这是一种用空间换时间的策略. 对于运算复杂耗时长的纯函数来说, 我们只需要, **在每一次运行这个函数时**, 把 **输入到输出的映射** 记录在一个哈希表中, 下一次运行这个函数的时候, 可以先看看这个输入在不在哈希表中, 在的话, 直接使用表中的数据, 这就是缓存.\n\n要实现这个缓存策略非常简单, 对于这个 Alpha-Beta 算法, 我们可以实现下面的方法:\n\n``` python\n# 进行 Hash 缓存\nhash_board_map = {}\n\ndef set_hash_board(board, current, depth, alpha, beta, value, pos):\n    hash_board_map[tuple([tuple([0 if piece == 0 else (1 if piece == current else -1) for piece in line]) for line in board] + [depth, alpha, beta])] = (value, pos)\n\ndef get_hash_board(board, current, depth, alpha, beta):\n    key = tuple([tuple([0 if piece == 0 else (1 if piece == current else -1) for piece in line]) for line in board] + [depth, alpha, beta])\n    return hash_board_map.get(key)\n```\n\n然后只需要修改一下原来的 Alpha-Beta 剪枝函数, 就可以加入缓存的功能:\n\n``` python\ndef alpha_beta(board, current, alpha, beta, depth, is_pass = False):\n    # 查看缓存中有没有, 有就直接返回\n    cache = get_hash_board(board, current, depth, alpha, beta)\n    if cache:\n        return cache\n    # 保存好 alpha, beta, 便于后续缓存\n    saved_alpha = alpha\n    saved_beta = beta\n    \n    # 开始递归判断\n    # ...\n    # 此处省略中间的代码\n    # ...\n\n    # 在返回之前保存数据到缓存中\n    set_hash_board(board, current, depth, saved_alpha, saved_beta, best_value, best_position)\n    return best_value, best_position\n```\n\n### 3.4 评估函数\n\n我们需要在达到预定的深度之后, 计算当前局面的分数, 所以我们需要一个**评估函数** (evaluate).\n\n想要正确评估出当前局面的好坏, 我们需要考虑各种因素, 使用多种策略.\n\n#### 3.4.1 角点策略\n\n这是一张黑白棋下棋优先级的图:\n\n![](https://pic4.zhimg.com/80/v2-cf439e403c012936d3f0723216d45777_720w.jpg)\n\n我们可以看出, 四个角的点的优先级是最高的, 即可以占就一定要占, 且尽量不让对手占领.\n\n为什么呢? 因为角点是最经典的稳定子, 这跟我们下面要说的稳定子策略也有关系. 并且只要占领了角点, 就很容易将别人下的棋子翻转过来.\n\n并且根据角点, 我们还可以了解到, 与角点相邻的点最好别下, 否则对手很容易就能占领角点, 进而将你的棋子翻转. 与角点相隔一个格的点也是比较好的点, 因为这样可以诱惑对方下临角点, 进而你可以占领角点.\n\n#### 3.4.2 稳定子策略\n\n**稳定子**是什么? \n\n**稳定子**就是不管怎么样下都不会被对手翻转的棋子, 称为稳定子. 角点是最经典的稳定子, 当你下了角点之后, 角点旁边的边点也是稳定子. 所以, 如果要简化计算, 我们可以只关注角和边的稳定子.\n\n#### 3.4.3 前沿子策略\n\n**前沿子**, 又称为**边缘子**, 和**内部子**概念相反.\n\n**内部子**是八面均不为空的棋子, 即被棋子包裹着, 不会被对手翻转 (但是仍可能被自己翻转), 我们需要多下这种棋, 可以给一定的正面评分.\n\n**前沿子**是八面至少有一面为空的棋子, 这种棋可以给一定的负面评分.\n\n#### 3.4.4 行动力策略\n\n在前期, 很少能走到边和角, 这时候的策略应该以什么为标准呢?\n\n我们可以以**行动力**为标准.\n\n什么是**行动力**? **行动力**即当前可以放置的位置的个数. 自己的行动力越高, 就越可能找到一个好的落子让自己有更好的局面; 对手的行动力越低, 就越容易被迫走出一个 \"坏子\".\n\n在前期如果以行动力为标准的话, 就很容易导致自己在前期的子**比较少**, 因为前期自己的子越少, 行动力一般越高, 四面八方都可以放. 这就隐含了另一个策略, **消失策略**: 在棋盘比试的前期,己方的子越少往往意味着局势更优. 因此在前期可采用使己方的子更少的走子.\n\n#### 3.4.5 具体实现\n\n``` python\ndef evaluate(board, current):\n    '''\n    评估函数, 用于评估当前局面.\n    常用策略有角点, 稳定子, 前沿子, 行动力.\n    '''\n    # 行动力, 即可以走的步数\n    mobility = len(get_movables(board, current).keys())\n\n    # 前沿子, 即周围至少有一个空格的棋子, 这种棋子容易被吃掉\n    frontier = 0\n    def is_frontier(i, j):\n        for dy, dx in [(dy, dx) for dy in range(-1, 2) for dx in range(-1, 2) if dy != 0 or dx != 0]:\n            if board[i + dy][j + dx] != 0:\n                return True\n        return False\n    # 遍历时可以去掉边缘\n    for i in range(1, 7):\n        for j in range(1, 7):\n            # 棋盘上的棋子不为空时, 判断前沿子\n            if not board[i][j] == 0 and is_frontier(i, j):\n                # 容易被吃掉, 所以应该要取反\n                frontier -= board[i][j] * current\n\n    # 角点和稳定子\n    corner = 0\n    steady = 0\n    corner_map = [\n        # 角点 i, j, 偏移方向 dy, dx\n        [0, 0, 1, 1],\n        [0, 7, 1, -1],\n        [7, 0, -1, 1],\n        [7, 7, -1, -1]\n    ]\n    for corner_i, corner_j, dy, dx in corner_map:\n        if board[corner_i][corner_j] == 0:\n            # 角点为空时, 如果下了临角点或对角点, 这些点很危险\n            corner += board[corner_i][corner_j + dx] * current * -3\n            corner += board[corner_i + dy][corner_j] * current * -3\n            corner += board[corner_i + dy][corner_j + dx] * current * -6\n            # 角点为空时, 如果下了隔角点, 这些点很好\n            corner += board[corner_i][corner_j + 2 * dx] * current * 4\n            corner += board[corner_i + 2 * dy][corner_j] * current * 4\n            corner += board[corner_i + dy][corner_j + 2 * dx] * current * 2\n            corner += board[corner_i + 2 * dy][corner_j + dx] * current * 2\n        else:\n            i, j = corner_i, corner_j\n            # 角点的权值\n            corner += board[corner_i][corner_j] * current * 15\n            # 角点不为空时, 处理稳定子, 为了简化运算, 仅仅考虑边稳定子\n            current_color = board[corner_i][corner_j]\n            while 0 <= i <= 7 and board[i][corner_j] == current_color:\n                steady += current * current_color\n                i += dy\n            while 0 <= j <= 7 and board[corner_i][j] == current_color:\n                steady += current * current_color\n                j += dx\n    \n    \n    # 以一定的权重相乘之后返回\n    return 8 * corner + 12 * steady + 8 * mobility + 4 * frontier\n```\n\n### 3.5 其他\n\n一些辅助用的函数, 获取可以走的位置和创建新棋盘, 外加 AI 的使用:\n\n``` python\nfrom math import inf\nfrom random import randint\nfrom copy import deepcopy\nfrom typing import List\n\ndef fsj_ai(board: List[List[int]], current: int, newest: List[int], reversal: List[List[int]], prompt) -> List[int]:\n    '''\n    输入参数:\n    board: 二维数组, 8 x 8 的棋盘数据, 0 代表空, 1 代表黑棋, 2 代表白棋.\n    current: 当前你的棋子颜色, 1 代表黑棋, 2 代表白棋.\n    最重要的就是上面两个, 其他输入无关紧要.\n    newest: 对方下的最后一个棋子位置.\n    reversal: 对方上一次翻转的棋子.\n    prompt: 当前你可以下的位置, 即提示. 一般来说你并不需要它.\n\n    返回:\n    返回你要下的位置, 例如 [2, 1] 或 (2, 1), 要注意是从 0 开始的.\n    '''\n\n    # 获取可放置位置的数据\n    board = [[-1 if piece == 2 else piece for piece in line] for line in board]\n    current = -1 if current == 2 else current\n\n    # 如果可以放角点, 直接放角点\n    movables = get_movables(board, current)\n    # for corner in [(0, 0), (0, 7), (7, 0), (7, 7)]:\n    #     if corner in movables.keys():\n    #         return corner\n    \n    # alpha-beta 剪枝\n    # 可行点的个数到迭代深度的映射\n    movables_number = len(movables.keys())\n    if movables_number < 5:\n        return alpha_beta(board, current, -10000, 10000, 6)[1]\n    elif movables_number < 10:\n        return alpha_beta(board, current, -10000, 10000, 5)[1]\n    else:\n        return alpha_beta(board, current, -10000, 10000, 4)[1]\n\ndef get_movables(board, current):\n    # 对于一个方向是否可以放置, 比如向右边是 dy = 0, dx = 1 的情况\n    def get_movable_by_step(i, j, dy, dx):\n        result = []\n        isEnd = False\n        while True:\n            i += dy\n            j += dx\n            if 0 > i or i > 7 or 0 > j or j > 7 or board[i][j] == 0:\n                break\n            elif board[i][j] == -current:\n                result.append((i, j))\n                isEnd = True\n            elif board[i][j] == current and isEnd == False:\n                break\n            elif board[i][j] == current and isEnd == True:\n                return result\n        return []\n\n    # 八个不同的方向是否可行\n    def get_movable_for_all_direction(i, j):\n        result = []\n        for dy, dx in [(dy, dx) for dy in range(-1, 2) for dx in range(-1, 2) if dy != 0 or dx != 0]:\n            result += get_movable_by_step(i, j, dy, dx)\n        return result\n\n    # 对棋盘的每一个空格进行判断\n    result = {}\n    for i in range(8):\n        for j in range(8):\n            lst = get_movable_for_all_direction(i, j)\n            if board[i][j] == 0 and len(lst) > 0:\n                result[(i, j)] = lst\n    return result\n    \n\ndef get_new_board(board, current, newest, reversals):\n    board = deepcopy(board)\n    board[newest[0]][newest[1]] = current\n    for reversal in reversals:\n        board[reversal[0]][reversal[1]] = current\n    return board\n\ndef get_score(board, current):\n    black_count = 0\n    white_count = 0\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 1:\n                black_count += 1\n            elif board[i][j] == -1:\n                white_count += 1\n    # 反正赢了就不用考虑比分来估值了\n    return (black_count - white_count) * current * 10000\n```\n\n## 4. 参考\n\n1. [黑白棋 - 维基百科](https://zh.wikipedia.org/wiki/%E9%BB%91%E7%99%BD%E6%A3%8B)\n2. [miniAlphaGo-for-Reversi - GitHub](https://github.com/avartia/miniAlphaGo-for-Reversi)\n3. [黑白棋中的 AI - 千千](https://www.dreamwings.cn/reversi/3013.html)\n4. [黑白棋天地](http://www.soongsky.com/othello/computer/index.php)\n\n","tags":["Study","AI","Game"],"categories":["Product"]},{"title":"k-means 聚类算法","url":"/post/kmean/","content":"\n# k-means 聚类算法\n\n## 1. 概念\n\nK-means 算法是一种无监督学习的聚类算法, 其基本思想是, 在几何空间上靠得越近的点就越相似.\n\n## 2. 步骤\n\n1. 将数据集归一化, 即将数据范围变为 $[0,1]$, 用于保证欧氏距离计算的准确性.\n2. 选择 $k$ 个初始点, 用这 $k$ 个和样本维度相等的初始点作为聚类的中心点 (质点), 记作 $a_{i}, i=1,2,\\cdots,k$.\n3. 对数据集中每一个样本 $x_{i}$ 计算它到这 $k$ 个样本之间的距离, 并将其分到距离最近的中心点对应的类别中. 然后形成 $k$ 个聚类 $C_{i}$.\n4. 对于每一个聚类 $C_{i}$, 重新计算它的聚类中心 $\\displaystyle a_{i}=\\frac{1}{|C_{i}|}\\sum_{x\\in C_{i}}x$, 即聚类里所有点的质心.\n5. 重复第 3. 步骤, 直至这 $k$ 个中心点稳定, 不再变化.\n6. 这 $k$ 个新中心点所对应的分类即无监督学习分类结果.\n\n类似过程如图所示.\n\n![](https://pic3.zhimg.com/80/v2-c7e92ede16a431e0439138c56bdc2e26_720w.jpg)\n\n<!-- more -->\n\n## 3. 实现\n\n``` python\nfrom typing import Tuple\nfrom sklearn import datasets  # 读取 sklearn 自带的数据集\nfrom sklearn.decomposition import PCA  # PCA 降维\nimport matplotlib.pyplot as plt  # 用于可视化分析\nimport numpy as np\n\niris = datasets.load_iris()  # 读取 iris 数据集\nX = iris.data \ny = iris.target\n\n# 归一化\nX = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))\n\n# 取欧式距离\ndef get_distance(first_sample: np.ndarray, second_sample: np.ndarray):\n        return ((first_sample - second_sample) ** 2).sum()\n\n# 生成随机的 k 个样本, 用于 k-means 初始化\ndef generate_X_samples(k: int, X: np.ndarray):\n    return X[[np.random.randint(0, X.shape[0]) for _ in range(k)]]\ncenters = generate_X_samples(3, X)\n\n# 第一次样本分类\ndef get_sample_class(sample: np.ndarray, centers: np.ndarray):\n    distances = [get_distance(sample, center) for center in centers]\n    return distances.index(max(distances))\n\npredict_y = np.array([get_sample_class(sample, centers) for sample in X])\n\n# 重新计算中心\nold_centers = generate_X_samples(3, X)\nindex_dict = {}\ndef recalculate_centers(X: np.ndarray, last_predict_y: np.ndarray) -> Tuple[np.ndarray]:\n    index_dict = {}\n    for i in range(len(last_predict_y)):\n        if last_predict_y[i] in index_dict:\n            index_dict[last_predict_y[i]].append(i)\n        else:\n            index_dict[last_predict_y[i]] = [i]\n    return np.array([X[index].sum(axis=0) / len(X[index]) for index in index_dict.values()]), index_dict\n\n# 一直计算直至稳定\nwhile not np.allclose(old_centers[:len(centers)], centers):\n    old_centers = centers\n    centers, index_dict = recalculate_centers(X, predict_y)\n    predict_y = np.array([get_sample_class(sample, centers) for sample in X])\n\n# 可视化\n# 降维\npca=PCA(n_components=2)\nnew_X = pca.fit_transform(X)\n\n# 画图\nfor index in index_dict.values():\n    part = new_X[index]\n    x = part[:, 0]\n    y = part[:, 1]\n    plt.scatter(x, y, alpha=0.6)\nplt.show()\n```\n\n所做出来的图:\n\n![](https://pic2.zhimg.com/80/v2-550123e11525dc3fd69becbdeb2b0fe1_720w.jpg)\n\n## 4. 问题\n\n在代码实现中, 我选取的 $k$ 值为 $3$, 但是在最后的显示中, 却只分成了 $2$ 个类别.\n\n我们分析这个问题发生的原因:\n\n虽然我们设定了 $3$ 个初始点, 但是在某一个迭代过程中, 本来属于第 $3$ 个点的数值点, 全部都被前两个点抢走了. 也就是说, 在数据集中没有和第 $3$ 个点相近的样本点.\n\n这个问题的出现和数据集的选取, 初始点位置的选取都有关系.","tags":["Study","Math","Machine Learning"],"categories":["Study"]},{"title":"kNN 近邻分类算法及简单的 Python 实现","url":"/post/knn/","content":"\n# kNN 近邻分类算法及简单的 Python 实现\n\n## 1. 概念\n\n**kNN 算法**是一种分类和回归算法, 这里我们讨论 kNN 算法在**分类问题**中的应用.\n\n简而言之, kNN 算法, 即给定一个**含分类标记训练数据集 (training data)**, 对于一个新的未分类的新**测试样本 (testing sample)**, 找到和这个测试样本**最邻近的 k 个训练样本 (training samples)**, 则我们将这 k 个训练样本中**出现次数最多的类别**看作是这个**新测试样本的类别**, 这就完成了我们的分类问题.\n\n![](https://pic3.zhimg.com/80/v2-da8fdace2b9c450b1f7a415843aa2e72_720w.jpg)\n\n<!-- more -->\n\n例如该图, 图中的 `蓝色圆圈` 和 `绿色方块` 是两种已知的类别, 图中是它们样本点的分布. 我们的任务是, 确认中间的未知类别的 `红色三角` 是属于 `蓝色圆圈` 还是 `绿色方块` 类别.\n\n我们采用 kNN 算法的思想考虑这个问题.\n\n当 k = 1 时, 我们可以看出, 和 `红色三角` 最近的 1 个训练样本是 `蓝色圆圈`, 则我们断言 `红色三角` 属于 `蓝色圆圈` 类别. \n\n当 k = 3 时, 我们可以看出, 和 `红色三角` 最近的 3 个训练样本中有 2 个是 `绿色方块`, 则我们断言 `红色三角` 属于 `绿色方块` 类别. \n\n当 k = 5 时, 我们可以看出, 和 `红色三角` 最近的 5 个训练样本中有 3 个是 `蓝色圆圈`, 则我们断言 `红色三角` 属于 `蓝色圆圈` 类别. \n\n我们可以看到, **当我们选取不同的 k 值时, 会出现不同的分类结果.**\n\n了解了 kNN 的基本概念之后, 我们还要完善具体的实现细节, 细节决定成败嘛. 我们可以考虑几个问题:\n\n1. 如何计算两个样本之间的距离? \n2. 如何平衡各个特征维度在距离计算中影响 (归一化)?\n3. 如何选取 k 值?\n4. 如何优化算法的运算效率?\n5. 如何确定样本不同特征的重要性?\n6. 是否需要降维?\n7. ...\n\n我们一个一个地考虑这些问题 (慢慢地更新).\n\nPS: 我们还可以发现 kNN 算法的一个特点, 它并不需要任何的显式的训练过程. 其实, 它是 **懒惰学习 (lazy learning)** 的代表算法, 训练过程仅仅是保存数据, 即训练时间为 0, 但是后续运算时消耗资源和消耗时间较大.\n\n\n## 2. 距离的计算\n\n通过线性代数课程的学习, 我们知道, 对于 $n$ 维向量空间 $\\mathbb{R}^{n}, \\alpha=(a_1,a_2,\\cdots ,a_{n}), \\beta=(b_1,b_2,\\cdots ,b_{n})$, 距离 $L_{p}$ 定义为:\n\n$$\nL_{p}(\\alpha,\\beta)=\\left( \\sum_{i=1}^{n}|a_{i}-b_{i}|^{p}\\right)^{\\frac{1}{p}}\n$$\n\n当 $p=2$ 时, 称为**欧氏距离 (Euclidean distance)**, 即\n\n$$\nL_{2}(\\alpha,\\beta)=\\left( \\sum_{i=1}^{n}|a_{i}-b_{i}|^{2}\\right)^{\\frac{1}{2}}\n$$\n\n当 $p=1$ 时, 称为**曼哈顿距离 (Manhattan distance)**, 即\n\n$$\nL_{1}(\\alpha,\\beta)=\\sum_{i=1}^{n}|a_{i}-b_{i}|\n$$\n\n当 $p=+\\infty$ 时, 它是各个坐标距离的最大值, 即\n\n$$\nL_{\\infty}(\\alpha,\\beta)=\\max_{i}|a_{i}-b_{i}|\n$$\n\n最常用的是欧氏距离, 我们在中学和大学期间便经常使用. 这里我们也是使用欧式距离来衡量两个样本之间的距离, 而且因为只是要判断距离的大小, 没有必要开平方, 即有\n\n$$\nL^{2}(\\alpha,\\beta)=\\sum_{i=1}^{n}(a_{i}-b_{i})^{2}\n$$\n\n**相应的 python 实现:**\n\n``` python\nimport numpy as np\nfrom sklearn import datasets  # 读取 sklearn 自带的数据集\n\niris = datasets.load_iris()  # 读取 iris 数据集\nx1 = iris.data[0]  # 第一个样本\nx2 = iris.data[1]  # 第二个样本\n\n# 计算两个样本之间的距离平方\ndistance = ((x1 - x2) ** 2).sum()\n\n# 查看结果\nprint('x1:', x1)\nprint('x2:', x2)\nprint('distance:', distance)\n```\n\n输出为\n\n``` text\nx1: [5.1 3.5 1.4 0.2]\nx2: [4.9 3.  1.4 0.2]\ndistance: 0.2899999999999997\n```\n\n## 3. 数据归一化\n\n假设我们有一堆样本, 但是这些样本的两个维度的数值差距较大, 如下图\n\n![](https://pic2.zhimg.com/80/v2-8f1f90433255f54095f9863a5b613cfd_720w.jpg)\n\n当 k = 3 时, \n\n**左图**表明 `红色三角` 应该属于 `蓝色圆圈` 类别; \n\n**右图**却告诉我们, `红色三角` 应该属于 `绿色方块` 类别.\n\n明明看起来像是同一批的数据, 为什么会有不同的结果呢?\n\n我们观察左图, 左图的数据呈现出长方形的形状, 其中**长度远远大于宽度**. 而右图的数据是经过左图**归一化**而来, 长方形被压缩成了正方形, **长度等于宽度**.\n\n那么左图和右图哪一种比较合理呢?\n\n我们不妨假设一种极端情况: 有那么一批数据, 它的样本有两个维度, 其中 $x$ 特征维度上的数据是 $10^{3}$ 级别的, 而 $y$ 特征维度上的数据仅仅是个位级别的. 此时, 我们再去衡量两个点之间的距离.\n\n我们发现, 判断两个点是否是最近的时候, **它们在 $y$ 维度上的数据对距离几乎没有任何影响, 它们相当于只是用 $x$ 维度上的数据衡量两点的距离, 数据退化成了一维了**.\n\n我们辛辛苦苦收集来的数据, 却只用到了其中的一半, 这怎么行?\n\n所以**我们需要对原始数据进行归一化**.\n\n归一化的方法有很多, 在这里, 我们可以使用简单的**线性归一化**:\n\n$$\nx_{i}'=\\frac{x_{i} - \\min\\{x\\}}{\\max\\{x\\}-\\min\\{x\\}}\n$$\n\n这样可以将数据线性映射到区间 $[0, 1]$ 上.\n\n**相应的 python 实现:**\n\n``` python\nimport numpy as np\nfrom sklearn import datasets  # 读取 sklearn 自带的数据集\n\niris = datasets.load_iris()  # 读取 iris 数据集\ndata = iris.data\n\n# 计算公式 x' = (x - min(x)) / (max(x) - min(x))\ndata = (data - data.min(axis=0)) / (data.max(axis=0) - data.min(axis=0)) \n\n# 查看结果\nprint(data[:5])\n```\n\n输出为:\n\n``` text\n[[0.22222222 0.625      0.06779661 0.04166667]\n [0.16666667 0.41666667 0.06779661 0.04166667]\n [0.11111111 0.5        0.05084746 0.04166667]\n [0.08333333 0.45833333 0.08474576 0.04166667]\n [0.19444444 0.66666667 0.06779661 0.04166667]]\n```\n\n## 3. k 折交叉验证法\n\n**交叉验证法** 即先将数据集 $D$ 分成 $k$ 个大小相斥的互斥子集 $D_{i}$, 然后再将每一个分别作为测试集, 其余作为验证集进行训练和测试, 最后取平均值, 用于判断算法的好坏.\n\n这里我们采用 5 折交叉验证, 如图\n\n![](https://pic4.zhimg.com/80/v2-2fe496e0b5534d903ff976bc86622c53_720w.jpg)\n\n**相应的 python 代码实现:**\n\n``` python\nfrom sklearn import datasets  # 读取 sklearn 自带的数据集\nfrom sklearn.model_selection import KFold  # 使用 sklearn 内含的 k 折函数\nimport numpy as np\n\niris = datasets.load_iris()  # 读取 iris 数据集\nX = iris.data\ny = iris.target\n\n# 初始化 k 折函数, 第一个参数是多少折, 第二个参数是随机数种子, 用于生成相同的随机数, 并且要设置 shuffle=True 才能生效\nkf = KFold(n_splits=5, random_state=2021, shuffle=True)\nfor i, (train_index, test_index) in enumerate(kf.split(X)):\n    print(f'\\nKFold {i+1}:')\n    print(\"Test index:\", test_index)\n\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n    print(\"Shape of X_train:\", X_train.shape)\n    print(\"Shape of X_test:\", X_test.shape)\n    print(\"Shape of y_train:\", y_train.shape)\n    print(\"Shape of y_test:\", y_test.shape)\n```\n\n输出为:\n\n``` text\nKFold 1:\nTest index: [  0   2   4   6   8  12  13  22  23  28  30  35  42  43  55  61  65  66\n  69  72  73  74  80  91 112 113 115 125 133 134]\nShape of X_train: (120, 4)\nShape of X_test: (30, 4)\nShape of y_train: (120,)\nShape of y_test: (30,)\n\nKFold 2:\nTest index: [ 16  24  29  34  39  45  46  56  58  59  64  67  68  77  81  83  88  92\n  97 104 105 108 118 127 129 132 136 143 146 149]\nShape of X_train: (120, 4)\nShape of X_test: (30, 4)\nShape of y_train: (120,)\nShape of y_test: (30,)\n\nKFold 3:\nTest index: [  3  18  20  26  31  32  37  47  48  60  75  79  84  86  87  95  96  98\n  99 100 103 107 114 117 119 122 126 139 142 144]\nShape of X_train: (120, 4)\nShape of X_test: (30, 4)\nShape of y_train: (120,)\nShape of y_test: (30,)\n\nKFold 4:\nTest index: [  9  10  11  15  17  19  25  27  36  40  41  50  51  53  71  76  78  82\n  89  90 111 121 131 135 137 138 141 145 147 148]\nShape of X_train: (120, 4)\nShape of X_test: (30, 4)\nShape of y_train: (120,)\nShape of y_test: (30,)\n\nKFold 5:\nTest index: [  1   5   7  14  21  33  38  44  49  52  54  57  62  63  70  85  93  94\n 101 102 106 109 110 116 120 123 124 128 130 140]\nShape of X_train: (120, 4)\nShape of X_test: (30, 4)\nShape of y_train: (120,)\nShape of y_test: (30,)\n```\n\n\n## 4. kNN 算法简单实现\n\n根据上面描述的过程和代码, 我们可以实现一个基本的 kNN 算法.\n\n大致过程为:\n\n1. 导入数据集, 并进行线性归一化;\n2. 进行 5 折交叉验证, 划分训练集和测试集;\n3. 对每一个测试集的样本, 遍历所有训练集的样本并算出距离;\n4. 选出最近的 k 个邻居, 进行投票统计类别;\n5. 求正确率的平均值, 最后算出总的正确率.\n\n**具体的 python 代码实现:**\n\n``` python\nfrom sklearn import datasets  # 读取 sklearn 自带的数据集\nfrom sklearn.model_selection import KFold  # 使用 sklearn 内含的 k 折函数\nfrom collections import Counter  # 用于后续投票\nimport matplotlib.pyplot as plt  # 用于可视化分析\nimport numpy as np\n\niris = datasets.load_iris()  # 读取 iris 数据集\nX = iris.data \ny = iris.target\n\nclass knn_classifier:\n\n    def __init__(self, X_train: np.ndarray, y_train: np.ndarray, k: int):\n        '''\n        初始化 kNN 模型. \n        X_train: 训练数据的特征;\n        y_train: 训练数据的标签;\n        k: kNN 中 k 的取值, 即选取多少个邻居.\n        '''\n\n        # 进行数据归一化\n        # 计算公式 x' = (x - min(x)) / (max(x) - min(x))\n        self._min = X_train.min(axis=0)\n        self._max = X_train.max(axis=0)\n        self._X_train: np.ndarray = (X_train - self._min) / (self._max - self._min)\n        self._y_train: np.ndarray = y_train\n        self._k: int = k\n\n    def get_distance(self, first_sample: np.ndarray, second_sample: np.ndarray):\n        return ((first_sample - second_sample) ** 2).sum()\n\n    # kNN 分类算法的实现\n    def classify_sample(self, X_sample: np.ndarray):\n        '''\n        给定一个测试样本 X_sample, 通过 kNN 算法来预测它的类别并返回. \n        X_sample: 一个测试样本.\n        '''\n\n        # 进行数据归一化\n        # 计算公式 x' = (x - min(x)) / (max(x) - min(x))\n        X_sample = (X_sample - self._min) / (self._max - self._min)\n\n        # 简单的遍历计算距离, 待优化\n        distances = [self.get_distance(X_train_sample, X_sample) for X_train_sample in self._X_train]\n\n        # 从小到大取出前 k 个数据的下标, 使用 np.argsort 函数\n        index = np.argsort(distances)[:self._k]\n        # 进行投票, 选出出现次数最多的类别\n        count = Counter(y[index])\n        return count.most_common()[0][0]\n\n\n# 使用 k 折函数和 knn 的结合\ndef k_fold_knn(X: np.ndarray, y: np.ndarray, *, k: int, k_fold: int = 5) -> float:\n    '''\n    使用 k 折交叉验证来计算分类结果准确率, 返回准确率.\n    X: 数据集的特征;\n    y: 数据集的标签;\n    k: kNN 中 k 的取值, 即选取多少个邻居.\n    k_fold: 进行多少折验证, 默认为 5 折.\n    '''\n    # 初始化 k 折函数, 第一个参数是多少折, 第二个参数是随机数种子, 用于生成相同的随机数, 并且要设置 shuffle=True 才能生效\n    kf = KFold(n_splits=k_fold, random_state=2021, shuffle=True)\n    # 用于保存每一折算出来的正确率\n    results = []\n    for train_index, test_index in kf.split(X):\n        # 每一折的训练集\n        X_train, X_test = X[train_index], X[test_index]\n        y_train, y_test = y[train_index], y[test_index]\n        knn = knn_classifier(X_train, y_train, k=k)\n\n        # 获取预测分类结果\n        y_predict = [knn.classify_sample(X_test_sample) for X_test_sample in X_test]\n\n        # 将预测分类结果与正确分类数据比对,\n        # 正确则为 1.0, 错误则为 0.0, 最后取平均值\n        results.append(sum([1.0 if y_predict[i] == y_test[i] else 0.0 for i in range(len(y_test))]) / len(y_test))\n\n    return sum(results) / len(results)\n\n# 进行超参数 k 的 5 折交叉验证测试\nk_values = range(1, 30, 2)\nk_accuracy = [k_fold_knn(X, y, k=k) for k in k_values]\n\n# 输出最优的 k 值\nprint('The best k is', k_values[k_accuracy.index(max(k_accuracy))])\nprint('The best accuracy is', max(k_accuracy))\n\n# 生成折线图, 用于分析\nplt.rcParams['font.sans-serif'] = ['SimHei']  # 用来正常显示中文标签\nplt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号\n\n# 'b': 颜色蓝色, 'o': 点形圆形, '-': 线形实线, 线条宽度为 2\nplt.plot(k_values, k_accuracy, 'bo-', linewidth=2)\nplt.xlabel('k')  # 横坐标轴的标题\nplt.ylabel('accurate')  # 纵坐标轴的标题\nplt.grid()  # 显示网格\nplt.title('不同的 k 值的 kNN 分类准确率') # 图形的标题\n\n# 显示图形\nplt.show()\n```\n\n输出为:\n\n``` text\nThe best k is 15\nThe best accuracy is 0.8733333333333334\n```\n\n![](https://pic2.zhimg.com/80/v2-a828249046b88239b19649870fbdab4d_720w.jpg)\n\n我们可以看出, 对于 iris 数据集来说, **最优的 k 值为 15, 准确率可达 0.87**.\n\n对于这个 3 分类问题, 这能算是一个不错的模型.\n\n","tags":["Study","Math","Machine Learning"],"categories":["Study"]},{"title":"PCA 主成分分析与数据降维","url":"/post/pca/","content":"\n# PCA 主成分分析与数据降维\n\n## 简介\n\n**PCA (Principal Component Analysis) 主成分分析**是一种重要的数据分析方式, 常常用于高维数据降为低维数据.\n\nPCA 可以用两种方式进行数学推导, 分别称为**最大可分型**和**最近重构型**, 前者基于基变换之后的方差最大, 后者基于点到划分平面的距离最小. 在这里, 我们使用最大可分型的方式进行数学推导.\n\n本文大部分数学推导基于[【机器学习】降维——PCA —— 知乎@阿泽](https://zhuanlan.zhihu.com/p/77151308), 但是做了更为完整易懂的解释, 并且附上了以 [iris 数据集 (鸢尾花卉数据集)](https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data) 为案例的相应的 python 代码实现.\n\n<!-- more -->\n\n## 投影\n\n对于两个向量 $\\alpha=(x_1, y_1), \\beta=(x_2,y_2)$\n\n我们知道其点乘的的几何意义为\n\n$$\n\\alpha\\cdot \\beta=x_1x_2+y_1y_2=|\\alpha||\\beta|\\cos\\theta\n$$\n\n其中 $\\theta$ 为 $\\alpha$ 与 $\\beta$ 的夹角.\n\n点乘的几何意义可以理解为, $\\alpha$ 在 $\\beta$ 方向的的投影长度乘以 $\\beta$ 的长度, 如图所示:\n\n![](https://pic2.zhimg.com/80/v2-d352bfa9af9fe255877e64946c8db32d_720w.png)\n\n那么我们就可以得知, $\\alpha$ 在 $\\beta$ 方向上的投影长度为\n\n$$\n|\\alpha|\\cos\\theta=\\frac{\\alpha\\cdot \\beta}{|\\beta|}\n$$\n\n若 $\\beta$ 等于单位向量 $e$, 满足 $|e|=1$, 则有\n\n$$\n|\\alpha|\\cos\\theta=\\alpha\\cdot e\n$$\n\n使用 python 和 numpy 书写, 即为\n\n``` python\nimport numpy as np\n\nbase = np.array([1 / np.sqrt(2), 1 / np.sqrt(2)])\nalpha = np.array([1, 2])\n\nshadow = alpha @ base\n```\n\n\n## 基的变换\n\n我们令 $\\alpha=(x_1, y_1)$, 其实就默认隐含了坐标系和基的概念.\n\n这里, 我们默认使用了 $(1,0)$ 和 $(0,1)$ 作为两个基向量, 实际上我们完全可以使用其他正交的单位向量作为基向量.\n\n例如, 我们使用 $e_1=\\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\\\end{pmatrix}$ 和 $e_2=\\begin{pmatrix} -\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\\\end{pmatrix}$ 作为一组新的基, 对向量 $\\alpha=\\begin{pmatrix} 1 \\\\ 2 \\\\\\end{pmatrix}$ 进行分析.\n\n由上面投影的概念和几何关系可知, 向量 $\\alpha$ 在新的基向量 $e_1,e_2$ 下的新坐标就是 $\\alpha$ 到 $e_1, e_2$ 方向上的投影:\n\n![](https://pic1.zhimg.com/80/v2-8f46f7b45846a96f8a8b8e3d5f81d48c_720w.png)\n\n由上述的求投影的公式可知, 新坐标 $(x', y')$ 可以这样求得\n\n$$\nx'=\\alpha\\cdot e_1=\\alpha^Te_1=1\\cdot \\frac{1}{\\sqrt{2}}+2\\cdot \\frac{1}{\\sqrt{2}}=\\frac{3}{\\sqrt{2}}\n$$\n\n$$\ny'=\\alpha\\cdot e_2=\\alpha^Te_2=1\\cdot \\left(-\\frac{1}{\\sqrt{2}}\\right)+2\\cdot \\frac{1}{\\sqrt{2}}=\\frac{1}{\\sqrt{2}}\n$$\n\n即在 $e_1, e_2$ 下的坐标为 $(\\frac{3}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}})$.\n\n我们可以用矩阵描述这个变换, 其中左边的矩阵的两个行向量分别为两个新的基 $e_1,e_2$:\n\n$$\n\\begin{pmatrix} \\frac{1}{\\sqrt{2}} &\\frac{1}{\\sqrt{2}} \\\\ -\\frac{1}{\\sqrt{2}} &\\frac{1}{\\sqrt{2}} \\\\\\end{pmatrix}\\begin{pmatrix} 1 \\\\ 2 \\\\\\end{pmatrix}=\\begin{pmatrix} \\frac{3}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\\\end{pmatrix}\n$$\n\n对于多个向量 $\\alpha_1(1, 2), \\alpha_2(2,3), \\alpha_3(3,4)$ 一起做坐标变换, 可以用矩阵写为\n\n$$\n\\begin{pmatrix} \\frac{1}{\\sqrt{2}} &\\frac{1}{\\sqrt{2}} \\\\ -\\frac{1}{\\sqrt{2}} &\\frac{1}{\\sqrt{2}} \\\\\\end{pmatrix}\\begin{pmatrix} 1 & 2 &3 \\\\ 2 & 3 & 4 \\\\\\end{pmatrix}=\\begin{pmatrix} \\frac{3}{\\sqrt{2}} & \\frac{5}{\\sqrt{2}} & \\frac{7}{\\sqrt{2}}\\\\ \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}}\\\\\\end{pmatrix}\n$$\n\n推广之, 对于 $r$ 个新的基 $e_1,e_2,\\cdots ,e_{r}$ 和 $m$ 个要转换坐标的向量 $\\alpha_1, \\alpha_2, \\cdots \\alpha_{m}$, 我们有\n\n单个向量坐标变换:\n\n$\\begin{pmatrix} e_1^T \\\\ e_2^T \\\\ \\vdots \\\\ e_{r}^T \\\\\\end{pmatrix}\\begin{pmatrix} \\alpha_1\\\\\\end{pmatrix}=\\begin{pmatrix} e_1\\alpha_1 \\\\ e_2\\alpha_1 \\\\ \\vdots \\\\ e_{m}\\alpha_1 \\\\\\end{pmatrix}$\n\n多个向量坐标变换:\n\n$\\begin{pmatrix} e_1^T \\\\ e_2^T \\\\ \\vdots \\\\ e_{r}^T \\\\\\end{pmatrix}\\begin{pmatrix} \\alpha_1 &\\alpha_2 &\\cdots  &\\alpha_{m} \\\\\\end{pmatrix}=\\begin{pmatrix} e_1^T\\alpha_1 & e_1^T\\alpha_2 &\\cdots & e_1^T\\alpha_{m} \\\\ e_2^T\\alpha_1 & e_2^T\\alpha_2 &\\cdots & e_2^T\\alpha_{m} \\\\ \\vdots & \\vdots & \\ddots &\\vdots \\\\ e_{m}^T\\alpha_1 & e_{m}^T\\alpha_2 &\\cdots & e_{m}^T\\alpha_{m}  \\\\\\end{pmatrix}$\n\n对于数据分析, 我们可以认为每一个 $\\alpha_{i}$ 均代表一个样本数据, 一共 $m$ 个样本.\n\n\n## 降维\n\n在坐标变换中, 如果我们能找到一个好的基向量, 就可以将数据聚集在坐标轴附近.\n\n举一个极端的例子, 对于新的基向量 $e_1(\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}), e_2(-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}})$ 和要进行坐标转换的向量 $\\alpha_1=\\begin{pmatrix} 1 \\\\ 1 \\\\\\end{pmatrix}, \\alpha_2=\\begin{pmatrix} 2 \\\\ 2 \\\\\\end{pmatrix}, \\alpha_3=\\begin{pmatrix} 3 \\\\ 3 \\\\\\end{pmatrix}$\n\n我们有\n\n$\\begin{pmatrix} \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} \\\\ -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}}\\end{pmatrix}\\begin{pmatrix} 1 &2 &3 \\\\ 1 &2 &3 \\\\\\end{pmatrix}=\\begin{pmatrix} \\sqrt{2} &2\\sqrt{2} &3\\sqrt{2} \\\\ 0 & 0 & 0 \\\\\\end{pmatrix}$\n\n我们可以发现, 新坐标的非零部分全部聚集到了 $e_1$ 对应的方向上, $e_2$ 对应方向的数值全部为零, 我们可以认为信息全部聚集到了 $e_1$ 维度上, 如图:\n\n![](https://pic4.zhimg.com/80/v2-4a5112c24c028e164151b212a901a533_720w.png)\n\n如果我们去除 $e_2$ 维度, 只保留 $e_1$ 维度的数据, 即降低了一个维度, 数据依然没有任何损失\n\n$\\begin{pmatrix} \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}}\\end{pmatrix}\\begin{pmatrix} 1 &2 &3 \\\\ 1 &2 &3 \\\\\\end{pmatrix}=\\begin{pmatrix} \\sqrt{2} &2\\sqrt{2} &3\\sqrt{2} \\end{pmatrix}$\n\n如图所示:\n\n![](https://pic4.zhimg.com/80/v2-1bf31710293da26327f62c90b5f1072b_720w.png)\n\nPCA 主成分分析要做的就是找到最合适的基向量, 使得尽可能多的信息保留在少数几个维度里, 达到低损耗降维的效果.\n\n那么如何选取最合适的基向量呢? 我们可以从方差入手.\n\n\n## 方差和协方差\n\n假定现在我们有两组数据, 分别是 $\\alpha=\\begin{pmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{m} \\\\\\end{pmatrix}, \\beta=\\begin{pmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_{m} \\\\\\end{pmatrix}$, 并称 $x_{i}=\\begin{pmatrix} a_{i} \\\\ b_{i} \\\\\\end{pmatrix}$ 为其中一个样本, 所以我们一共有 $m$ 个样本.\n\n举个例子, 我们可以认为 $\\alpha=\\begin{pmatrix} 1 \\\\ 3 \\\\ 5 \\\\\\end{pmatrix}$ 是房子面积, $\\beta=\\begin{pmatrix} 2 \\\\ 5 \\\\ 8 \\\\\\end{pmatrix}$ 是房子价格, 其中第二个样本为 $\\begin{pmatrix} 3 \\\\ 5 \\\\\\end{pmatrix}$.\n\n我们知道求方差的公式为\n\n$$\n\\text{Var}(\\alpha)=\\frac{1}{m}\\sum_{i=1}^{m} (a_i-\\mu)^{2}\n$$\n\n其中 $\\mu$ 为均值\n\n$$\n\\mu=\\frac{1}{m}\\sum_{i=1}^{m} a_{i}\n$$\n\n相应的 python 实现:\n\n``` python\nimport numpy as np\n\nalpha = np.array([1., 3., 5.])\naverage = np.mean(alpha)\nvariance = ((alpha - average) ** 2).sum() / len(alpha)\n```\n\n为了简化公式, 我们可以将原式数据进行\"中心化\", 即将每一个数据都减去它的均值, 此时 $\\alpha=\\begin{pmatrix} a_1-\\mu \\\\ a_2-\\mu \\\\ \\vdots \\\\ a_{m}-\\mu \\\\\\end{pmatrix}$ 则方差公式可以简化为\n\n$$\n\\text{Var}(\\alpha)=\\frac{1}{m}\\sum_{i=1}^{m} a_{i}^{2}\n$$\n\n相应的 python 实现:\n\n``` python\nimport numpy as np\n\nalpha = np.array([1., 3., 5.])\nalpha -= np.mean(alpha)\nvariance = (alpha ** 2).sum() / len(alpha)\n```\n\n方差描述的是数据的离散程度, 而协方差描述表示两个变量的相关性.\n\n协方差公式为:\n\n$$\n\\text{Cov}(\\alpha,\\beta)=\\frac{1}{m}\\sum_{i=1}^{m}(a_{i}-\\mu_{\\alpha})(b_{i}-\\mu_{\\beta})\n$$\n\n经过\"中心化\"之后, 协方差公式可以简化为:\n\n$$\n\\text{Cov}(\\alpha,\\beta)=\\frac{1}{m}\\sum_{i=1}^{m}a_{i}b_{i}\n$$\n\n相应的 python 实现:\n\n``` python\nimport numpy as np\n\nalpha = np.array([1., 3., 5.])\nbeta = np.array([2., 5., 8.])\nalpha -= np.mean(alpha)\nbeta -= np.mean(beta)\ncovariance = (alpha * beta).sum() / len(alpha)\n```\n\n当协方差大于 $0$ 时, 两个向量正相关, 当协方差小于零时, 两个向量负相关, 当协方差等于 $0$ 时, 两个向量线性无关.\n\n\n## 主成分分析\n\n要推导出 PCA 最佳的基向量, 我们需要制定一个优化标准.\n\n由几何意义我们可以很简单地看出, **所选取的基向量越好, 数据在该方向上的投影的离散程度越大**.\n\n![](https://pic3.zhimg.com/80/v2-24d707e135d74776e5d3d1509f881bfe_720w.png)\n\n受到最小二乘法的启发, 我们可以以最大化方差为目标.\n\n对于一个基向量 $e=\\begin{pmatrix}e_1\\\\e_2\\\\\\vdots\\\\e_n\\end{pmatrix}$, 我们将所有的样本点 $x_{i}=\\begin{pmatrix}x_{i1}\\\\x_{i2}\\\\\\vdots\\\\x_{in}\\end{pmatrix}, i=1,2,\\cdots,m$ 投影到 $e$ 方向上.\n\n即有 $x_{i}$ 在基 $e$ 下的投影长度坐标值 $\\displaystyle x_{i}^Te=\\sum_{j=1}^{n}e_{j}x_{ij}$\n\n如图:\n\n![](https://pic1.zhimg.com/80/v2-27fae780877642d4956e337cf862e640_720w.png)\n\n则在**这个基向量方向上的方差**为\n\n$$\n\\begin{aligned}\n\\text{Var}(x)\n&=\\frac{1}{m}\\sum_{i=1}^{m} (x_{i}^Te)^{2} \\\\\n\\end{aligned}\n$$\n\n我们只需要将该方差最大化, 解出基向量 $e$ 对应的值, 即转化成了一个求极值的问题.\n\n因为 $x_{i}^Te$ 是标量, 所以有 $(x_{i}^Te)^T=x_{i}^Te$\n\n$$\n\\begin{aligned}\n\\text{Var}(x)\n&=\\frac{1}{m}\\sum_{i=1}^{m} (x_{i}^Te)^{2} \\\\\n&=\\frac{1}{m}\\sum_{i=1}^{m} (x_{i}^Te)^T(x_{i}^Te) \\\\\n&=\\frac{1}{m}\\sum_{i=1}^{m} e^T(x_{i}x_{i}^T)e \\\\\n&=e^T\\left(\\frac{1}{m}\\sum_{i=1}^{m}x_{i}x_{i}^T\\right)e \\\\\n\\end{aligned}\n$$\n\n我们令 $\\displaystyle P=\\frac{1}{m}\\sum_{i=1}^{m}x_{i}x_{i}^T$, 为了更好地说明问题, 我们可以先令 $x_{i}=\\begin{pmatrix} a_{i} \\\\ b_{i} \\\\\\end{pmatrix}$\n\n$$\n\\begin{aligned}\nP\n&=\\frac{1}{m}\\sum_{i=1}^{m}x_{i}x_{i}^T \\\\ \n&=\\frac{1}{m}\\sum_{i=1}^{m}\\begin{pmatrix} a_{i}^{2} &a_{i}b_{i} \\\\ a_{i}b_{i} &b_{i}^{2} \\\\\\end{pmatrix} \\\\\n&=\\begin{pmatrix} \\displaystyle \\frac{1}{m}\\sum_{i=1}^{m}a_{i}^{2} &\\displaystyle \\frac{1}{m}\\sum_{i=1}^{m}a_{i}b_{i} \\\\ \\displaystyle \\frac{1}{m}\\sum_{i=1}^{m}a_{i}b_{i} &\\displaystyle \\frac{1}{m}\\sum_{i=1}^{m}b_{i}^{2} \\\\\\end{pmatrix} \\\\\n&=\\begin{pmatrix} \\text{Var}(a) &\\text{Cov}(a,b) \\\\ \\text{Cov}(a,b) & \\text{Var}(b) \\\\\\end{pmatrix}\n\\end{aligned}\n$$\n\n即 $P$ 对角线上的元素为 $x_{i}$ 在各个方向的方差, 同时对角线之外的元素为各个方向元素之间的协方差. 这个结论从 $2$ 维推广到 $n$ 维也成立.\n\n对于求最值问题:\n\n$$\n\\begin{cases} \\max\\{e^TP e\\} \\\\ s.t. e^Te=1 \\end{cases}\n$$\n\n使用拉格朗日乘数法可构造出\n\n$$\nL(e)=e^TP e+\\lambda(1-e^Te)\n$$\n\n对于 $e$ 求导化简可得\n\n$$\nPe=\\lambda e\n$$\n\n**即有 $\\lambda$ 是 $P$ 的特征值, $e$ 是 $P$ 的特征向量**, 仅在此时取得极值.\n\n并且将 $Pe=\\lambda e$ 代回原式有\n\n$$\n\\text{Var}(x)=e^TPe=e^T\\lambda e=\\lambda e^Te=\\lambda\n$$\n\n即**方差等于 $P$ 的特征值 $\\lambda$**. 那么我们可知, 我们要找的最大方差便是 $P$ 的最大特征值, 第二大方差即 $P$ 的第二大特征值, 依次类推. 它们对应的特征向量即我们需要的基向量.\n\n我们称 $P$ 为协方差矩阵, 它是一个实对称矩阵, 根据线性代数相关的知识, 我们知道它有一个性质:\n\n**一个 n 行 n 列的实对称矩阵一定可以找到 n 个单位正交特征向量.** 我们令这 $n$ 个特征向量分别为 $e_1,e_2,\\cdots,e_n$, 按照特征值由大到小的顺序从左到右排列, 再将这 $n$ 个列向量排列成为矩阵 $E=\\begin{pmatrix}e_1&e_2&\\cdots&e_n\\end{pmatrix}$, 则有\n\n$$\nE^TPE=\\begin{pmatrix} \\lambda_1 & & & \\\\  &\\lambda_2 & & \\\\  & &\\ddots & \\\\  & & &\\lambda_n \\\\\\end{pmatrix}\n$$\n\n可见, 使用 $n$ 个单位正交的特征向量作为新的基向量, 在新坐标中满足: **方差 (对角线元素) 最大**和**协方差 (非对角线元素) 最小**.\n\n我们令 $X=\\begin{pmatrix} x_{1} & x_{2} & \\cdots & x_{m} \\end{pmatrix}=\\begin{pmatrix} x_{11} & x_{21} & \\cdots & x_{m1} \\\\  x_{12} & x_{22} & \\cdots & x_{m2}  \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\  x_{1n} & x_{2n} & \\cdots & x_{mn}  \\\\\\end{pmatrix}$, 每一列都是一个样本.\n\n则 $P$ 可以记作\n\n$$\nP=\\frac{1}{m}XX^T\n$$\n\n我们只需要解出 $\\displaystyle \\frac{1}{m}X^TX$ 的特征值和特征向量即可.\n\n然后对于新的基矩阵 $E=\\begin{pmatrix}e_1&e_2&\\cdots&e_n\\end{pmatrix}$, 根据投影和基变换的概念我们可以求出变换后的坐标:\n\n$$\nX'=E^TX\n$$\n\n如果我们只选取前 $k$ 个特征值和特征向量, 取得新的基矩阵 $E_{k}=\\begin{pmatrix}e_1&e_2&\\cdots&e_k\\end{pmatrix}$, 则\n\n$$\nX'=E_k^TX\n$$\n\n便达到了降维的效果.\n\n\n## 求解步骤\n\n我们有 $m$ 个 $n$ 维的样本数据.\n\n1. 将原始数据转化成为一个 $n$ 行 $m$ 列的数据矩阵 $X$;\n2. 每一行减去均值, 进行\"中心化\";\n3. 求出协方差矩阵 $\\displaystyle P=\\frac{1}{m}XX^T$;\n4. 求出协方差矩阵的特征值和特征向量, 并按特征值由大到小排列;\n5. 选取前面 $k$ 个特征向量, 排列形成矩阵 $E_{k}=\\begin{pmatrix}e_1&e_2&\\cdots&e_k\\end{pmatrix}$\n6. 计算 $X'=E_{k}^TX$, $X'$ 即为降维过后的数据.\n\n\n## 示例\n\npython 与 numpy 的实现, 在这里我们使用 [iris 数据集 (鸢尾花卉数据集)](https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data):\n\n``` python\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\n\n# 1. Loading dataset into Pandas DataFrame and get numpy data\nurl = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\"\ndf = pd.read_csv(url, names=['sepal length','sepal width','petal length','petal width','target'])\ndata = df.iloc[:, :4].to_numpy()\n\ndef pca(data, n_component):\n    data = data.T\n\n    # 2. Subtract the mean\n    data -= data.mean(axis = 1).reshape(-1, 1)\n \n    # 3. Get the covariance matrix: 1/m * XX^T\n    cov_matrix = 1 / len(data[0]) * data @ data.T\n \n    # 4. Calculate the eigenvalue and eigenvector\n    eigenvalues, eigenmatrix = np.linalg.eig(cov_matrix)\n \n    # 5. Sort eigenmatrix by eigenvalues\n    eigenmatrix = eigenmatrix[sorted(range(len(eigenvalues)),  key=lambda v: -eigenvalues[v])]\n \n    # 6. Get data after dimensionality reduction\n    new_data = eigenmatrix.T[:n_component] @ data\n    return new_data\n\nnew_data = pca(data, 2)\n\nprint(new_data.T[:5])\n\n# 7. Draw scatter plot\nx = new_data[0]\ny = new_data[1]\nplt.scatter(x, y, alpha=0.6)\nplt.show()\n```\n\n输出为:\n\n``` text\n[[-2.68420713 -0.32660731]\n [-2.71539062  0.16955685]\n [-2.88981954  0.13734561]\n [-2.7464372   0.31112432]\n [-2.72859298 -0.33392456]]\n```\n\n![](https://pic3.zhimg.com/80/v2-2f7b0125f9528ea473f2c9a5a9dba006_720w.png)\n\n使用 sklearn 实现:\n\n``` python {cmd}\nimport pandas as pd \nfrom sklearn.decomposition import PCA \nimport matplotlib.pyplot as plt\n\n# 1. Loading dataset into Pandas DataFrame and get numpy data\nurl = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\"\ndf = pd.read_csv(url, names=['sepal length','sepal width','petal length','petal width','target'])\ndata = df.iloc[:, :4].to_numpy().T\n\n# 2. Use sklearn\npca=PCA(n_components=2)\nnew_data = pca.fit_transform(data.T).T\n\nprint(new_data.T[:5])\n\n# 3. Draw scatter plot\nx = new_data[0]\ny = new_data[1]\nplt.scatter(x, y, alpha=0.6)\nplt.show()\n```\n\n输出为:\n\n``` text\n[[-2.68420713 -0.32660731]\n [-2.71539062  0.16955685]\n [-2.88981954  0.13734561]\n [-2.7464372   0.31112432]\n [-2.72859298 -0.33392456]]\n```\n\n![](https://pic3.zhimg.com/80/v2-2f7b0125f9528ea473f2c9a5a9dba006_720w.png)\n\n可见两者结果一致.\n\n我们再将其投影到 3 维坐标观察:\n\n``` python\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 1. Loading dataset into Pandas DataFrame and get numpy data\nurl = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\"\ndf = pd.read_csv(url, names=['sepal length','sepal width','petal length','petal width','target'])\ndata = df.iloc[:, :4].to_numpy()\n\ndef pca(data, n_component):\n    data = data.T\n\n    # 2. Subtract the mean\n    data -= data.mean(axis = 1).reshape(-1, 1)\n \n    # 3. Get the covariance matrix: 1/m * XX^T\n    cov_matrix = 1 / len(data[0]) * data @ data.T\n \n    # 4. Calculate the eigenvalue and eigenvector\n    eigenvalues, eigenmatrix = np.linalg.eig(cov_matrix)\n \n    # 5. Sort eigenmatrix by eigenvalues\n    eigenmatrix = eigenmatrix[sorted(range(len(eigenvalues)),  key=lambda v: -eigenvalues[v])]\n \n    # 6. Get data after dimensionality reduction\n    new_data = eigenmatrix.T[:n_component] @ data\n    return new_data\n\nnew_data = pca(data, 3)\n\nprint(new_data.T[:5])\n\n# 7. Draw 3d scatter plot\nfig = plt.figure()\nax = Axes3D(fig)\nx = new_data[0]\ny = new_data[1]\nz = new_data[2]\nax.scatter(x, y, z, alpha=0.6)\nplt.show()\n```\n\n输出为\n\n``` text\n[[-2.68420713 -0.32660731 -0.02151184]\n [-2.71539062  0.16955685 -0.20352143]\n [-2.88981954  0.13734561  0.02470924]\n [-2.7464372   0.31112432  0.03767198]\n [-2.72859298 -0.33392456  0.0962297 ]]\n```\n\n![](https://pic3.zhimg.com/80/v2-761a9bc961533295fe56b1e6cb815fb6_720w.png)\n\n## 参考\n\n1. [【机器学习】降维——PCA —— 知乎@阿泽](https://zhuanlan.zhihu.com/p/77151308)\n2. [如何通俗易懂地讲解什么是 PCA 主成分分析？ —— 知乎@马同学](https://www.zhihu.com/question/41120789/answer/481966094)\n3. 《机器学习》周志华\n4. [NumPy 中文](https://www.numpy.org.cn/)\n5. [Principle Component Analysis (PCA) for Data Visualization](https://github.com/mGalarnyk/Python_Tutorials/blob/master/Sklearn/PCA/PCA_Data_Visualization_Iris_Dataset_Blog.ipynb)\n6. [主成分分析(PCA)——基于python+numpy](https://blog.csdn.net/zhili8866/article/details/52947303)","tags":["Study","Math","Machine Learning"],"categories":["Study"]},{"title":"在 VS Code 中用 Markdown 做「数字化」学习笔记","url":"/post/notes-in-markdown/","content":"\n# 教程向: 在 VS Code 中用 Markdown 做「数字化」学习笔记\n\n<!-- #! https://zhuanlan.zhihu.com/p/366596107 -->\n\n**VS Code** 配上 **Markdown** 语言, 就能写出酷炫, 便捷, 且适应互联网的「数字化」学习笔记.\n\n![](https://pic4.zhimg.com/80/v2-9e0a1762c0f90f507c3fb5cd6a34878b_720w.png)\n\n这个教程是我这段时间踩过各种各样的坑之后, 总结 VS Code 做学习笔记的最佳实践. \n\n**如果你对在 VS Code 中做笔记有什么好的主意, 欢迎留下你的意见, 我会第一时间在教程中加入!**\n\n<!-- more -->\n\n## 环境搭配\n\n### 安装 VS Code\n\n前往 [官网](https://code.visualstudio.com/) 下载 VS Code, 点击 `Download`, 就会自动开始下载:\n\n![](https://pic3.zhimg.com/80/v2-ae734fcbf9a73da5c8e4139894527ff6_720w.png)\n\n如果网速较慢, 你也可以在 [腾讯软件中心](https://pc.qq.com/detail/16/detail_22856.html) 下载.\n\n进入安装界面, 将选项全部勾选, 点 **下一步** 和 **安装**, 直到安装完成即可.\n\n\n### 中文支持 (选做)\n\n如果你不想看英文, 想要中文版本的 VS Code, 你可以安装一个中文支持插件. 虽然我个人不太喜欢, 但是每个人都有自己的喜好嘛.\n\n打开 VS Code, 点击插件面板, 输入 `Chinese`, 选择出现的第一个插件进行 `Install` 安装.\n\n![](https://pic4.zhimg.com/80/v2-8d2c22cec01a715a2f035de69999e4ef_720w.png)\n\n安装好后, 按照右下角提示重启 VS Code.\n\n![](https://pic1.zhimg.com/80/v2-a5af8faf9a404a1750fb887cd0fd4ce0_720w.png)\n\n可以看出, 界面以及变为中文了.\n\n![](https://pic3.zhimg.com/80/v2-e3ae1c57c90f3ffa38d53248ce56a4fe_720w.png)\n\n\n### 安装 Markdown 相关插件\n\n为了良好的记笔记体验, 你需要安装和 Markdown 相关的 VS Code 插件:\n\n你可以下载我整理的这个 Extension Pack, 它包括了下面这些插件:\n\n* Markdown Preview Enhanced \n* Markdown All in One\n* Better Markdown & Latex Shortcuts \n* Latex Sympy Calculator\n* Python Brackets\n* Orangex4 Snippets\n* Paste Image\n* Vscode Icons\n\n就像安装中文支持那样操作, 点击插件面板, 搜索 `Markdown-Notes-Pack`, 点击 `Install` 进行安装, 可能会花一点时间.\n\n![](https://pic4.zhimg.com/80/v2-c5f60e9494fc02b6a8674e8465cb1523_720w.png)\n\n\n## 第一个 Markdown 文件: Hello World!\n\n### 新建笔记工作区\n\n工作区是什么? \n\n工作区就是一个文件夹, 在你做笔记的时候, 工作区应该是你的笔记的根文件夹.\n\n例如, 我在 D 盘创建了一个文件夹 `D:\\Notes`, 那么我的工作区就应该是这个 `D:\\Notes` 文件夹.\n\n你可以像我一样, 在 D 盘新建一个 `Notes` 文件夹, 并在 VS Code 中打开这个文件夹.\n\n![](https://pic4.zhimg.com/80/v2-c3051dc7620b59b58882f06359a17c47_720w.png)\n\n![](https://pic1.zhimg.com/80/v2-00f078a786cd4c6dc41de0ca3e0030d0_720w.png)\n\n### 在工作区子笔记文件夹\n\n我个人比较喜欢将笔记按照不同的课程放在不同的文件夹下, 比如在我们的 Markdown 学习之旅中, 我们可以先新建一个文件夹叫 `Learn`.\n\n![](https://pic2.zhimg.com/80/v2-9ee788e031f18af8557b066934c97e89_720w.png)\n\n![](https://pic2.zhimg.com/80/v2-c30e7615741ed3eed65441a60fa37c39_720w.png)\n\n新建一个文件, 命名为 `test.md`, **注意后缀一定要是 `.md`!!!** 这样表明它是一个 **Markdown** 文件. 你的所有笔记文件都应该以 `.md` 作为后缀. \n\n![](https://pic2.zhimg.com/80/v2-13abf5b6bd3966927b6dea7f34eac6ed_720w.png)\n\n### 写下第一行 Markdown 笔记\n\n输入笔记内容:\n\n``` markdown\n# Hello, World!\n```\n\n(注意, # 和 文本之间要**加入空格**!)\n\n然后**按照先后顺序**按下快捷键 `Ctrl + K, V`, 然后在右边就会出现预览窗口.\n\n(注意, 快捷键按下时要**连贯**, 并且按下 `V` 的同时**不用按** `Ctrl` 键!)\n\n\n![](https://pic4.zhimg.com/80/v2-cb29c8506f57b405526fd27997b579ff_720w.png)\n\n如果正常地显示出了标题 \"Hello, World!\", 那么恭喜你, 第一个 Markdown 笔记写成功了!\n\n\n## 修改预览窗口背景 (选做)\n\n相信聪明的你已经发现了一个问题: \n\n**为什么我的预览窗口是白色的, 太刺眼了! 为什么你的预览窗口和代码窗口颜色一样?**\n\n诶, 别急, 这就告诉你. 这里的预览窗口的 **Markdown Preview Enhanced** 插件生成的. 你只需要修改一下这个插件的配置就可以了.\n\n按下快捷键 `Ctrl + ,`, 就会打开设置窗口.\n\n在搜索框输入 `Preview Theme`, 看见标题为 Preview Theme 的选项, 在下拉框中选择 `atom-dark.css`, 就能让预览窗口的颜色改变了. \n\n(当然, 颜色还是和 VS Code 有一点差别, 就不要在意这些细节啦) \n\n![](https://pic3.zhimg.com/80/v2-45e9f6416764f8cce0e64e5b80620c22_720w.png)\n\n\n## Markdown 语法\n\n纯粹的 Markdown 语法其实非常简单, 70 行的语法介绍就可以写完.\n\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n每写完一个段落要隔一行空行.\n\n就像这样, 隔了一行空行.\n\n---\n\n分割线\n\n**重点加粗**\n\n*斜体*\n\n~~删除线~~\n\n---\n\n列表:\n\n* 无序列表\n  * 嵌套无序列表\n  * 嵌套无序列表\n* 无序列表\n* 无序列表\n\n1. 有序列表 1\n   1. 嵌套有序列表 1\n   2. 嵌套有序列表 2\n2. 有序列表 2\n3. 有序列表 3\n\n---\n\n引用文本:\n\n> 引用别人说的话\n> 就这样写\n> By. OrangeX4\n\n---\n\n这是 `行内代码` 语法.\n\n代码块语法:\n\n''' python\nprint(\"Hello, World!\")\n'''\n\n请将 ' 替换成 `.\n\n---\n\n[超链接名称](链接地址)\n\n![图片提示语](图片地址)\n\n---\n\n表格:\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| 内容 | 内容 |\n\n---\n\n注释:\n\n<!-- 你看不见我 -->\n```\n\n### 标题\n\n你可以用\n\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n段落.\n```\n\n或\n\n``` markdown\n一级标题\n=======\n\n二级标题\n-------\n```\n\n的方式表示标题, 个人更推荐前一种方式. (不用对齐, 强迫症福音!)\n\n### 段落\n\n```markdown\n段落和段落之间要隔一行.\n\n就像这样.\n```\n\n### 分割线\n\n``` markdown\n三条横线 (或更多的横线) 表示分割线.\n\n---\n\n就像这样.\n```\n\n![](https://pic2.zhimg.com/80/v2-35c44fb7437e3c4e676e0f0af8cd5045_720w.png)\n\n\n### 加粗, 斜体和删除线\n\n做笔记的时候, 我们常常会有这样的要求, \"加粗, 斜体和删除线\", 作为笔记的\n\n``` markdown\n**重点加粗**\n\n*斜体*\n\n~~删除线~~\n```\n\n**Markdown Preview Enhanced 拓展功能:**\n\n``` markdown\n==高亮==\n```\n\n![](https://pic2.zhimg.com/80/v2-a81b2adc3d8820855e1c6a761d3bdb1d_720w.png)\n\n\n**快捷键:**\n\n选中文本之后, 按下 `Ctrl + B` 可以给选中文本加粗.\n\n同理 `Ctrl + I` 可以让选中文本变为斜体.\n\n\n### 列表\n\n列表是记笔记时非常基本的元素, 在 Markdown 中, 可以用很方便的格式书写列表:\n\n``` markdown\n* 无序列表\n  * 嵌套无序列表\n  * 嵌套无序列表\n* 无序列表\n* 无序列表\n\n1. 有序列表 1\n   1. 嵌套有序列表 1\n   2. 嵌套有序列表 2\n2. 有序列表 2\n3. 有序列表 3\n```\n\n**Markdown Preview Enhanced 拓展功能:**\n\n``` markdown\n任务列表:\n\n- [x] 已经完成的事 1\n- [x] 已经完成的事 2\n- [x] 已经完成的事 3\n- [ ] 仍未完成的事 4\n- [ ] 仍未完成的事 5\n```\n\n![](https://pic4.zhimg.com/80/v2-dceae97b65a98286e995a6f59b1989b3_720w.png)\n\n**快捷键:**\n\n要进行**缩进** (书写嵌套列表), 你可以使用 VS Code 的快捷键 `Ctrl + [` 和 `Ctrl + ]`.\n\n这个快捷键可以将代码向左或向右进行缩进!\n\n\n### 引用和代码\n\n``` markdown\n引用文本:\n\n> 引用别人说的话\n> 就这样写\n> By. OrangeX4\n\n这是 `行内代码` 语法.\n\n代码块语法:\n\n''' python\nprint(\"Hello, World!\")\n'''\n\n注意要将 ' 替换成 `.\n```\n\n![](https://pic1.zhimg.com/80/v2-bdf324d9b4e6b5dc60337a4db3255a48_720w.png)\n\nMarkdown Preview Enhanced 拓展功能:\n\n```\n代码行数的显示:\n\n''' javascript {.line-numbers}\nfunction add(x, y) {\n  return x + y\n}\n'''\n\n注意要将 ' 替换成 `.\n```\n\n![](https://pic1.zhimg.com/80/v2-cfcbfe6cf86e1ecdd5707549f12215e8_720w.png)\n\n\n### 超链接和图片\n\n你可以用下面的语法插入超链接和图片:\n\n``` markdown\n[超链接名称](链接地址)\n\n![图片提示语](图片地址)\n\n例如, 可以使用网址和图床:\n\n[OrangeX4's Blog](https://orangex4.cool/)\n\n![OrangeX's Avatar](https://orangex4.cool/images/icons/profile.jpg)\n\n也可以在本地用相对地址:\n\n[Other](other.md)\n\n![OrangeX's Avatar](images/profile.jpg)\n```\n\n![](https://pic2.zhimg.com/80/v2-8bc75ba8206a33037251aca5959bd931_720w.png)\n\n### 剪贴板图片插入\n\n看了上面的插入图片语法, 也许你会觉得, **好麻烦啊**.\n\n我就插入一张图片, 居然还要把图片上传到网上. 或者把图片保存到本地, 还要移动图片, 命名什么的.\n\n就不能像 Word 那样, 直接**剪贴板粘贴图片**吗? \n\n万能的 VS Code 当然可以做到类似的事!\n\n其实, 使用你已经安装了的 **Paste Image** 插件就行.\n\n不过在使用之前, 你要做一点小调整:\n\n按下 `Ctrl + ,` 打开设置窗口, 输入 `Paste Image Path` 并搜索, 将框内的文本改成 `${currentFileDir}/images`.\n\n![](https://pic2.zhimg.com/80/v2-c35303b43639b37a18b8893e906d7435_720w.png)\n\n注意标题是 **Paste Image: Path**, 不要弄错了!\n\n设置好之后, 你就可以使用剪贴板粘贴功能了!\n\n**按下快捷键 `Ctrl + Alt + V`**,\n\n就能把图片自动保存到当前目录下, 并以正确的格式粘贴到当前的 Markdown 文件中.\n\n\n### 表格\n\n你可以很方便地在做笔记的时候加入表格:\n\n``` markdown \n表格:\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| 内容 | 内容 |\n```\n\n**Markdown Preview Enhanced 拓展功能:**\n\n``` markdown \n拓展语法:\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| >    | 内容 |\n\n| 表头 | 表头 |\n| ---- | ---- |\n| 内容 | 内容 |\n| ^    | 内容 |\n```\n\n![](https://pic4.zhimg.com/80/v2-fe477e9335bbff718c658057a86e0307_720w.png)\n\n\n**快捷键:**\n\n自动表格对齐: `Shift + Alt + F`\n\n### 注释\n\n注释不会被渲染出来. \n\n你可以随手做点草稿, 如果还想保留着, 但是不显示, 就可以按下**快捷键** `Ctrl + \\` **将当前行注释 / 反注释**.\n\n``` markdown\n注释:\n\n<!-- 你看不见我 -->\n\n<!-- 多行注释\n就像这样 -->\n```\n\n有一点很重要的就是, **VS Code 会在你每次修改代码之后, 重新渲染一遍**.\n\n**如果有很多很多的数学公式, 渲染会很慢**, 这时候有两个建议:\n\n* **分成多个文件, 避免单文件过大!**\n* **将你暂时不看的部分注释掉, 加快渲染速度!**\n\n## 数学公式支持\n\nMarkdown 的数学公式吸纳了大部分的 Latex 语法, 你可以以一种简单的方式在 VS Code 中书写数学公式.\n\n``` markdown\n行内公式: \n\n单位圆 $x^2+y^2=1$\n\n公式块:\n\n$$\n\\begin{cases}\nx=\\rho\\cos\\theta \\\\\ny=\\rho\\sin\\theta \\\\\n\\end{cases}\n$$\n```\n\n![](https://pic4.zhimg.com/80/v2-42be969f982a47db9a53e087232ac2c3_720w.png)\n\n**VS Code 有着非常便捷好用的自动补全功能**, 只需要简单地打出你想打的内容的几个字母 (**乱序**也行), 再使用 `↑ ↓` 进行选择, 最后按下回车就可以打出你想要的内容.\n\n再使用 **HyperSnips 插件**, 就能够写得飞快.\n\n![](https://pic3.zhimg.com/80/v2-17cd3912fe219cdd7c8696af431eb456_720w.png)\n\n还有, **不要在公式内使用中文**, 除非是 `\\text{中文}` (但是也不推荐) \n\n### 1. 上标和下标\n\n``` latex\n上标 $x^2 + y^{12} = 1$\n\n上标 $x_1 + y_{12} = 1$\n```\n\n![](https://pic2.zhimg.com/80/v2-a527faa78367be526a55992ebfae09f9_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\nxsr  =>  x^{2}\n\nxtp  =>  x^{...}\n\nx1  =>  x_1\n\nxii  =>  x_i\n\nxsb  =>  x_{...}\n```\n\n\n### 2. 分式\n\n``` latex\n较小的行内行分数 $\\frac{1}{2}$\n\n展示型的分式 $\\displaystyle\\frac{x+1}{x-1}$\n```\n\n其中 `\\displaystyle` 用于将行内展示转为块状展示.\n\n![](https://pic1.zhimg.com/80/v2-6068b9817b165318fbb44912601a1450_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\n1/  =>  \\frac{1}{...}\n\n(1 + 2)/  =>  \\frac{(1+2)}{...}\n\n//  =>  \\frac{...}{...}\n```\n\n\n### 3. 根式\n\n``` latex\n开平方 $\\sqrt{2}$\n\n开 $n$ 次方 $\\sqrt[n]{2}$\n```\n\n![](https://pic4.zhimg.com/80/v2-7f43224f74cae008fa950a82252e0903_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\nhsq  =>  \\sqrt{...}\n```\n\n### 4. 空格\n\n数学公式中的 **空格和换行** 都会在编译时 **被忽略**，想要实现「空格」的效果，需要用特别的命令。\n\n``` latex\n紧贴 $a\\!b$\n\n没有空格 $ab$\n\n小空格 $a\\,b$\n\n中等空格 $a\\;b$\n\n大空格 $a\\ b$\n\nquad 空格 $a\\quad b$\n\n两个 quad 空格 $a\\qquad b$\n```\n\n![](https://pic2.zhimg.com/80/v2-3d5d3d55a6cc7fa4108a3d72287ec509_720w.png)\n\n\n### 5. 累加, 累乘和积分\n\n``` latex\n累加 $\\sum_{k=1}^n\\frac{1}{k}  \\quad  \\displaystyle\\sum_{k=1}^n\\frac{1}{k}$\n\n累乘 $\\prod_{k=1}^n\\frac{1}{k}  \\quad  \\displaystyle\\prod_{k=1}^n\\frac{1}{k}$\n\n积分 $\\displaystyle \\int_0^1x{\\rm d}x  \\quad  \\iint_{D_{xy}}  \\quad  \\iiint_{\\Omega_{xyz}}$\n```\n\n![](https://pic2.zhimg.com/80/v2-107c58a00665db46695c759d10926ded_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\nsum  =>  \\sum_{...}\n\nprod  =>  \\prod_{<n=1>}^{<\\infty>} ...\n\nint  =>  \\int\n\ndint  =>  \\int_{<-\\infty>}^{<\\infty>} ... \\mathrm{d}x\n```\n\nTips：按下 Tab 键可以跳转光标。\n\n\n### 6. 括号修饰\n\n用 `\\left` 和 `\\right` 可以让括号适配内部大小\n\n``` latex\n圆括号 $\\displaystyle \\left(\\sum_{k=1}^{n}\\frac{1}{k} \\right)^2$\n\n方括号 $\\displaystyle \\left[\\sum_{k=1}^{n}\\frac{1}{k} \\right]^2$\n\n花括号 $\\displaystyle \\left\\{\\sum_{k=1}^{n}\\frac{1}{k} \\right\\}^2$\n\n尖括号 $\\displaystyle \\left\\langle\\sum_{k=1}^{n}\\frac{1}{k} \\right\\rangle^2$\n```\n\n![](https://pic3.zhimg.com/80/v2-2564e223b37d79424ff60ecf1ee4e5b6_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\n@(  =>  \\left( ... \\right)\n\n@[  =>  \\left[ ... \\right]\n\n@{  =>  \\left\\{ ... \\right\\}\n\n@<  =>  \\left< ... \\right>\n\nset  =>  \\{ ... \\}\n```\n\n### 7. 多行算式对齐\n\n``` latex\n居中:\n\n$$\n\\begin{aligned}\ny &=(x+5)^2-(x+1)^2 \\\\\n&=(x^2+10x+25)-(x^2+2x+1) \\\\\n&=8x+24 \\\\\n\\end{aligned}\n$$\n\n左对齐:\n\n$\n\\begin{aligned}\ny &=(x+5)^2-(x+1)^2 \\\\\n&=(x^2+10x+25)-(x^2+2x+1) \\\\\n&=8x+24 \\\\\n\\end{aligned}\n$\n```\n\n![](https://pic4.zhimg.com/80/v2-2ce4065baebaa934da5963574f65bce7_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\nali  =>\n\\begin{aligned}\n... \\\\\n\\end{aligned}\n```\n\n如果你安装了 `Better Markdown & Latex Shortcuts` 插件，你还可以按下 `Shift + Ctrl + Alt + C` 可以将行公式转为 aligned 环境。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/aligned.gif)\n\n\n### 8. 方程组\n\n``` latex\n$$\n\\begin{cases}\nk_{11}x_1+k_{12}x_2+\\cdots+k_{1n}x_n=b_1 \\\\\nk_{21}x_1+k_{22}x_2+\\cdots+k_{2n}x_n=b_2 \\\\\n\\cdots \\\\\nk_{n1}x_1+k_{n2}x_2+\\cdots+k_{nn}x_n=b_n \\\\\n\\end{cases}\n$$\n```\n\n![](https://pic1.zhimg.com/80/v2-a085a39d41c0af5ded6b328907e662ec_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\ncase  =>\n\\begin{cases}\n... \\\\\n\\end{cases}\n```\n\n### 9. 矩阵\n\n\n``` latex\n矩阵:\n\n$$\n\\begin{pmatrix}\n1 & 1 & \\cdots & 1 \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\end{pmatrix}\n\n\\quad\n\n\\begin{bmatrix}\n1 & 1 & \\cdots & 1 \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\end{bmatrix}\n$$ \n\n行列式: \n\n$$\n\\begin{vmatrix}\n1 & 1 & \\cdots & 1 \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 1 & \\cdots & 1 \\\\\n\\end{vmatrix}\n$$\n```\n\n![](https://pic3.zhimg.com/80/v2-8f249643b32b0fd0375dc8f8c8b40d86_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\nbmat2  =>  \\begin{bmatrix} ... & ... \\\\ ... & ... \\\\\\end{bmatrix}\n\nvec2  =>  \\begin{pmatrix} ... \\\\ ... \\\\\\end{pmatrix}\n```\n\ntips：按下 Tab 键可以切换到下一个位置。\n\n### 10. 特殊字符\n\n![](https://pic2.zhimg.com/80/v2-842b02c54dd7d8e0571609414e79bdc1_720w.png)\n\n更多特殊符号可以 [上网查询](https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols)\n\n可以搜索 \"Latex 符号表\"\n\n**HyperSnips 自动扩展**：\n\n```markdown\nalpha  =>  \\alpha\n\nSigma  =>  \\Sigma\n```\n\n\n### 11. 公式编号与引用\n\n``` latex\n$$\nx+2 \\tag{1.2}\n$$\n\n$$\n\\begin{equation}\nx^n+y^n=z^n\n\\end{equation}\n$$\n\n由公式 $(1.2)$ 可得到结论\n```\n\n![](https://pic2.zhimg.com/80/v2-e602d10556b445efba976af2ee0b4209_720w.jpg)\n\n### 12. 零碎的重要语法\n\n* 点乘 `$\\cdot$`, 叉乘 `$\\times$`, 异或 `$\\otimes$`, 直和 `$\\oplus$`, 加减 `$\\pm$`, 复合 `$\\circ$`. \n* 小于等于 `$\\leq$`, 大于等于 `$\\geq$`, 不等 `$\\neq$`, 恒等 `$\\equiv$`, 约等 `$\\approx$`, 等价 `$\\cong$`, 相似 `$\\sim$`, 相似等于 `$\\simeq$`, 点等 `$\\doteq$`.\n* 逻辑与 `$\\land$`, 逻辑或 `$\\lor$`, 逻辑非 `$\\lnot$`, 蕴涵 `$\\to$`, 等价 `$\\leftrightarrow$`.\n* 因为 `$\\because$`, 所以 `$\\therefore$`, 存在 `$\\exist$`, 任意 `$\\forall$`.\n* 左小箭头 `$\\leftarrow$`, 右小箭头 `$\\rightarrow$`, 左大箭头 `$\\Leftarrow$`, 右大箭头 `$\\Rightarrow$`, 右长箭头 `$\\xrightarrow[fgh]{abcde}$`.\n* 属于 `$\\in$`, 包含于 `$\\subset$`, 真包含于 `$\\subseteq$`, 交 `$\\cap$`, 并 `$\\cup$`, 空集 `$\\empty$`\n* 短向量 `$\\vec{x}$`, 长向量 `$\\overrightarrow{AB}$`, 上横线 `$\\overline{p}$`.\n* 无限 `$\\infty$`, 极限 `$\\lim$`, 微分 `${\\rm d}$`, 偏导 `$\\partial$`, 点求导 `$\\dot{y}$`, 点二阶导 `$\\ddot{y}$`, 变化量 `$\\Delta$`, 梯度 `$\\nabla$`.\n* 横省略 `$\\cdots$`, 竖省略 `$\\vdots$`, 斜省略 `$\\ddots$`.\n* 常见函数 `$\\sin$`, `$\\cos$`, `$\\tan$`, `$\\arcsin$`, `$\\arccos$`, `$\\arctan$`, `$\\ln$`, `$\\log$`, `$\\exp$`.\n\n![](https://pic1.zhimg.com/80/v2-1063f781baa2bed9e7ebb32428719650_720w.png)\n\n**HyperSnips 自动扩展**：\n\n```markdown\n**  =>  \\cdot\nxx  =>  \\times\notimes  =>  \\otimes\n<=  =>  \\le\n!=  =>  \\neq\n==  =>  \\equiv\n~~  =>  \\thickapprox\nsim  =>  \\sim\nland  =>  \\land\nlor  =>  \\lor\nbec  =>  \\because\nthr  =>  \\therefore\nEE  =>  \\exists\nAA  =>  \\forall\ninn  =>  \\in\nsse  =>  \\subseteq\nsqs  =>  \\sqsubseteq\ncap  =>  \\cap\ncup  =>  \\cup\nempty  =>  \\empty\noo  =>  \\infty\nlim  =>  \\lim_{<n> \\to <\\infty>}\ndd  =>  \\mathrm{d}\npart  =>  \\frac{\\partial <V>}{\\partial <x>}\nDelta  =>  \\Delta\nnabla  =>  \\nabla\n...  =>  \\cdots\nsin  =>  \\sin\n```\n\n还有特别重要的数集、向量、矩阵符号：\n\n```markdown\nRR  =>  \\mathbb{R}\nNN  =>   \\mathbb{N}\ntxt  =>  \\text{...}\nxbar  =>  \\bar{x}\nxhat  =>  \\hat{x}\nxhvec  =>  \\vec{x}\nxhdot  =>  \\dot{x}\nXbb  =>  \\mathbb{X}\nXbs  =>  \\boldsymbol{X}\nXbm  =>  \\bm{X}\nXbf  =>  \\mathbf{X}\nXsf  =>  \\mathsf{X}\nXcal  =>  \\mathcal{X}\nXfrak  =>  \\mathfrak{X}\nXrm  =>  \\mathrm{X}\n```\n\n## 输出为 PDF\n\n我们在右侧预览栏右键菜单, 选择 **在浏览器中打开**.\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220309084552.png)\n\n在浏览器中右键选择 **打印**.\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220309084746.png)\n\n就能够 **输出为 PDF** 了.\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220309084857.png)\n\n## 类似 UltiSnips 的自动补全\n\n也许你曾经看过这篇文章：\n\n[机器之心：世界上最好的编辑器Vim：1700多页数学笔记是如何实时完成的](https://zhuanlan.zhihu.com/p/61036165)\n​\n于是你很想试一下, 然后就被 Vim 和 Latex 给劝退了。\n\n但是实际上, VS Code 完全能够替代 Vim, Markdown 在记笔记方面也完全能够替代 Latex. 通过 VS Code 插件 HyperSnips for Math, 你就可以像用 UtliSnips 一样使用各种神奇的 Snippets.\n\n插件安装: [HyperSnips for Math - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=OrangeX4.hsnips)\n\n![](https://pic1.zhimg.com/80/v2-f9d96f22a34351d73eaa8cfe3447df68_720w.jpg)\n\n安装完成后, 按下快捷键 `Ctrl + Shift + P`, 输入命令 `Open Snippets Directory`, 就可以打开一个文件夹. 在该文件夹新建一个文件 `markdown.hsnips`, 并将 [这个网址](https://github.com/OrangeX4/OrangeX4-HyperSnips/blob/main/markdown.hsnips) 里面的内容输入进去, 保存, 就可以使用了.\n\n例如, 你可以在数学环境中输入: `(1+2)/`, 它会自动变为 `\\frac{1+2}{}`.\n\n你也可以创建自己的 Snippets, 按照格式, 发挥想象来写就好!\n\n先看个 **普通例子**:\n\n```hsnips\nsnippet RR \"R\" iAm\n\\mathbb{R}\nendsnippet\n```\n\n这是一个在数学环境中自动展开的 Snippet, 它有三个标示符 `iAm`, 分别代表 \"在词语内部也会触发\", \"自动展开\" 和 \"数学环境\".\n\n这个例子会在数学环境内, 自动将 `RR` 展开成为 `\\mathbb{R}`, 代表 \"实数\".\n\n再看个 **正则表达式** 的例子:\n\n``` hsnips\nsnippet `((\\d+)|(\\d*)(\\\\)?([A-Za-z]+)((\\^|_)(\\{\\d+\\}|\\d))*)/` \"Fraction no ()\" Am\n\\frac{``rv = m[1]``}{$1}$0\nendsnippet\n```\n\n其中 `rv = m[1]` 是 JavaScript 代码, 表示将正则表达式的第一个组 `m[1]` 输出给 \"返回值\" `rv`, 然后输出出去.\n\n这是一个在数学环境中自动展开的 Snippet, 它有两个标示符 'Am', 分别代表 '自动展开' 和 '数学环境'. 用处是:\n\n```\n1/    --->    \\frac{1}{}\n```\n\n相比于原来的 HyperSnips, 最大特点是, 它只会在数学环境 `$...$`, `$$...$$`, `\\(...\\)` 和 `\\[...\\]` 中自动展开!\n\n**还有 `${VISUAL}` 语法:**\n\n```\nsnippet fr \"frac\" iAm\n\\\\frac{${1:${VISUAL}}}{$2}\nendsnippet\n```\n\n这个语法会保存最近选中的内容, 然后替换掉 `${VISUAL}` 部分.\n\n要开启在 markdown 下的 **自动补全提示**, 请使用 `Shift + Ctrl + P` 然后输入 `open settings json` 打开配置文件, 然后加入以下部分:\n\n```json\n\"[markdown]\": {\n    \"editor.quickSuggestions\": true\n},\n```\n\n## VS Code 快捷键\n\n**快捷键**是用 VS Code 记笔记的**精髓**之一, 每一个都**非常重要**!\n\n请务必**认真记住**这些快捷键!!!\n\n### 原生快捷键\n\n1. **通用操作**\n   1. `Ctrl + C`, 复制当前文本\n   2. `Ctrl + V`, 粘贴当前文本\n   3. `Ctrl + Z`, 撤销\n   4. `Ctrl + Shift + Z`, 反撤销\n   5. `Shift + Alt + F`, 整理代码\n   6. `Ctrl + /`, 将当前行注释 / 反注释, **当多行文本被选中时**, 将多行文本注释\n2. **光标操作**\n   1. `Ctrl + ←` 将光标向左移动一个**单词**\n   2. `Ctrl + →` 将光标向右移动一个**单词**\n   3. `Ctrl + Alt + ↑`, 向上加入一个光标\n   4. `Ctrl + Alt + ↓`, 向下加入一个光标\n   5. `Ctrl + Alt + U`, 撤销上次光标操作\n3. **界面移动**\n   1. `Ctrl + ↑` 向上移动当前界面\n   2. `Ctrl + →` 向下移动当前界面\n4. **选中操作**\n   1. `Shift + ←` 向左选中 / 反选中一个**字符** **(重要)**\n   2. `Shift + →` 向右选中 / 反选中一个**字符** **(重要)**\n   3. `Ctrl + Shift + ←` 向左选中 / 反选中一个**单词** **(重要)**\n   4. `Ctrl + Shift + →` 向右选中 / 反选中一个**单词** **(重要)**\n   5. `Ctrl + D` **当前有选中文本时**, 将下一个与其相同的文本加入选中 **(重要)**\n5. **文本行操作**\n   1. `Ctrl + C` **当前无选中文本时**, 复制当前行\n   2. `Shift + Alt + ↑` 向上**复制**当前行, **当多行文本被选中时**, 向上复制多行 **(重要)**\n   3. `Shift + Alt + ↓` 向下**复制**当前行, **当多行文本被选中时**, 向下复制多行 **(重要)**\n   4. `Alt + ↑` 向上**移动**当前行, **当多行文本被选中时**, 将当前多行文本向上移动 **(重要)**\n   5. `Alt + ↓` 向下**移动**当前行, **当多行文本被选中时**, 将当前多行文本向下移动 **(重要)**\n\n### 插件增加的快捷键\n\n1. **Markdown 语法**\n   1. `Ctrl + B` **当前有选中文本时**, 将文本加粗\n   2. `Ctrl + I` **当前有选中文本时**, 将文本变为斜体\n   3. `Ctrl + M` 进入数学公式模式 (加入美元符)\n2. **图片粘贴**\n   1. `Ctrl + Alt + V` 粘贴剪贴板图片 (本地)\n   2. `Ctrl + Alt + V` 粘贴剪贴板图片 (图床)\n3. **光标操作**\n   1. `Ctrl + Alt + U` 将多选光标变为单选\n4. **选中操作**\n   1. `Shift + Alt + ←` 向左**复制**当前选中文本 **(重要)**\n   3. `Shift + Alt + →` 向右**复制**当前选中文本 **(重要)**\n   4. `Alt + ←` 向左**移动**当前选中文本一个**字符** **(重要)**\n   5. `Alt + →` 向右**移动**当前选中文本一个**字符** **(重要)**\n   6. `Ctrl + Alt + ←` 向左**移动**当前选中文本一个**单词** **(重要)**\n   7. `Ctrl + Alt + →` 向右**移动**当前选中文本一个**单词** **(重要)**\n5. **计算器功能**\n   1. `Ctrl + Shift + Alt + E` 计算当前选中表达式, **用等号连接**并输出\n   2. `Ctrl + Shift + Alt + R` 计算当前选中表达式, 并**替换当前选中表达式**\n   3. `Ctrl + Shift + Alt + D` 定义当前选中表达式, **无输出**\n\n## 科学计算\n\n使用我开发的一个插件 `Latex Markdown Calculator` , 可以很方便地在 VS Code 中用 Latex 公式语法进行科学计算。\n\n即选中一段数学表达式, 按下一个快捷键就能帮你计算出结果, 一些简单的计算再也不用打开电脑自带的计算器和 Matlab~\n\n因为是基于 Python Sympy 的, 所以现在它已经有很多强大的功能了。\n\n比如说：符号运算, 求积分, 求微分, 基于矩阵的符号运算(如行列式, 点乘, 转置, 求逆等功能), 解方程...\n\n快捷键为 `Shift + Ctrl + Alt + E`, 详细内容请查看插件的说明文档.\n\n![](https://pic4.zhimg.com/80/v2-59abfbec7f2ac3d8d0c435cfc1c8551f_720w.jpg)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/Ud246889e25e84421a60a86435e693bfaJ.gif)\n\n\n## 云端存储\n\n### 安装 Git\n\n你可以前往 [官网](https://git-scm.com/downloads) 下载 Git, 有 Windows 版本, 也有 Mac 版本和 Linux 版本.\n\n![](https://pic4.zhimg.com/80/v2-8a602441e83fc0189ae0e72808098f7f_720w.png)\n\n如果你网速不佳, 也可以去 [腾讯软件中心](https://pc.qq.com/detail/13/detail_22693.html) 下载.\n\n安装过程中, 基本上一直点 `Next` 就好.\n\n![](https://pic3.zhimg.com/80/v2-34b7f438ee06c3e73733bc31288fa246_720w.png)\n\n安装好了之后, 按下 `Win` 键, 输入 `cmd`, 回车, 便出现了命令行.\n\n输入\n\n``` sh\ngit\n```\n\n命令, 回车, 若输出如图显示, Git 就安装成功了.\n\n![](https://pic2.zhimg.com/80/v2-ad0cf1a51c73590fef6439bffbcbf859_720w.png)\n\n### 版本控制\n\n我们使用 Git 来实现版本控制, 或者是笔记保存效果.\n\n**每次你更改了笔记, 在传到云端之前, 都要进行一次笔记保存 Commit.**\n\n![](https://pic4.zhimg.com/80/v2-4ba2ef6abc6c42bca770d7f6cb6d7b3b_720w.png)\n\n![](https://pic3.zhimg.com/80/v2-33f93621f386a3268826818c32fa2d86_720w.png)\n\n![](https://pic1.zhimg.com/80/v2-22533f0c8bcdbed49dff8ff9a3033c94_720w.png)\n\n### 上传到 GitHub\n\nGitHub 是世界上最大的代码托管平台, 你当然也可以把你的笔记托管在 GitHub 上.\n\n你可以看我的这篇 [GitHub 简易指南](https://orangex4.cool/post/github-tutorials-for-beginner/), 加深对 GitHub 的理解.\n\n要上 GitHub, 你可能需要一点小技巧, 这我就不教你了.\n\n不然你也可以选择国内的 Gitee 或者国内能访问的 GitLab.\n\n看完这篇指南之后, 你大概就知道怎么把笔记托管到云端了, 而且, 完全免费噢.\n\n(虽然可能麻烦了点)\n\n### 上传云端\n\n**如果你设置好了 GitHub**, 需要上传到云端了, 你可以 Git Push 上去.\n\n![](https://pic1.zhimg.com/80/v2-a2d66edb0b0aa77346c631c5da853d78_720w.png)\n\n\n## 在线浏览\n\n**如果你把你的笔记上传到了云端**, 你就可以**随时随地**地查看你的笔记, 并且可以很方便地**分享给别人**.\n\n比如, 你要看我的笔记, 可以访问这个链接:\n\n[https://notes.orangex4.cool/?git=gitlab](https://notes.orangex4.cool/?git=gitlab)\n\n如果你把你的笔记上传到了 GitHub, 想要查看, 你可以用这个网址:\n\n[https://notes.orangex4.cool/](https://notes.orangex4.cool/)\n\n并且仿照这个格式:\n\n[https://notes.orangex4.cool/?git=github&github=typoverflow/note](https://notes.orangex4.cool/?git=github&github=typoverflow/note)\n\n大概格式是: \n\nhttps://notes.orangex4.cool/?git=github&github=用户名/笔记仓库\n\n你就有了这种效果的笔记!\n\n![](https://pic4.zhimg.com/80/v2-28ed5a7053e44ce56d5b833868bd3a97_720w.png)\n\n\n## Markdown 进阶 (选看)\n\n**Markdown Preview Enhanced** 提供了非常强大的功能, 你可以访问 [MPE 简介](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/) 获取更多相关的信息.\n\n例如说, 你可以:\n\n### 自动目录\n\n只需要使用语法\n\n``` markdown\n[TOC]\n```\n\n就能自动生成目录.\n\n### 画图\n\n#### 流程图\n\n![](https://pic3.zhimg.com/80/v2-d2a6caacfbf8ce0f00f1ee729184dda2_720w.png)\n\n#### 时序图\n\n![](https://pic4.zhimg.com/80/v2-b1d18378ba1422488aa744d58f47e2c3_720w.png)\n\n#### 其他\n\n你可以自己访问 [MPE 简介](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/) 获取更多相关的信息.\n\n\n### 代码块\n\n你可以在 Markdown 中运行 **Python**, **Javascript** 之类的代码!\n\n甚至可以运行 **Latex**!\n\n![](https://pic2.zhimg.com/80/v2-80956add1dd781c1d2c5f04ba2fda215_720w.png)\n\n详见 [Code Chunk](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/code-chunk).\n\n\n### 软件推荐\n\n#### Snipaste\n\n超良心的截图软件, 而且可以**贴图到屏幕上**, 写作业神器!\n\n![](https://pic2.zhimg.com/80/v2-b667ec70d66fb596f3ec05d93e291545_720w.png)\n\n\n#### GeoGebra\n\n[GeoGebra 官网](https://www.geogebra.org/)\n\n你可以很方便地画函数图像!\n\n![](https://pic2.zhimg.com/80/v2-10ae9e60b9c785e2e64d0a0d288f7095_720w.png)\n\n#### Drawio\n\n超良心的免费画图软件, 你可以用它画**流程图**, **电路图**之类的各种图.\n\n对齐功能超赞, 而且完全免费!\n\n而且可以**不用下载, 在线使用!**\n\n当然你要离线用也可以下离线版本, 甚至可以下载对应的 VS Code 插件!\n\n[Drawio 官网](https://app.diagrams.net/)\n\n![](https://pic2.zhimg.com/80/v2-69c96f7b31a21fc477b31ef8a4cbd171_720w.png)\n\n\n\n## 总结\n\n暂时想到的就这些啦, 更多的内容后续再补充, 也欢迎给我提交意见~","tags":["Study","VS Code","Notes"],"categories":["Study"]},{"title":"VS Code 用来记笔记究竟能有多酷炫?","url":"/post/notes-in-vscode/","content":"\n# VS Code 用来记笔记究竟能有多酷炫?\n\n<!-- #! https://zhuanlan.zhihu.com/p/366596949 -->\n\n很少有人发现, **VS Code** 配上 **Markdown** 语言, 就能写出酷炫, 便捷, 且适应互联网的「数字化」学习笔记.\n\n我尝试用 VS Code 写了一段时间的笔记, 非常顺手, 而且管理起来非常方便, 我做的笔记就像这样:\n\n![](https://pic4.zhimg.com/80/v2-9e0a1762c0f90f507c3fb5cd6a34878b_720w.png)\n\n使用 VS Code 做的「数字化」笔记, 你可以很容易的看出和其他的笔记软件完全不一样, 简直是笔记界的一股泥石流 (不是).\n\n事实上, 笔记要做成这样并不难, 只要尝试写几天, 就能轻松上手!\n\n下面是用 VS Code 记笔记的优势!\n\n<!-- more -->\n\n## 完全免费\n\n相对于其他笔记软件, VS Code 有一个非常显著的优势: 它是免费的! I am free!\n\n而且使用 VS Code 记笔记, 你不需要买 iPad 和 Apple Pencil, 随便一个笔记本电脑, 不管是 Windows 系统还是 Mac, 甚至是 Linux, 你都可以用 VS Code 来做笔记.\n\n我用 VS Code 做笔记的一个重要原因, 就是它很适合我这种追求技术的人 (绝对不是因为买不起 iPad, 手动狗头).\n\n## 整洁美观\n\n并不是所有人都能写出一手好字的, 特别是对于我这种从小就被别人吐槽字难看的人 (悲).\n\n快看我的笔记多整洁好看 (不是).\n\n## 数学公式\n\n使用 **Latex** 的公式语法和 **VS Code** 强大的自动补全功能, 你可以很方便地写出非常整齐优雅地数学公式, 拿给别人看都觉得倍有面子.\n\n![](https://pic2.zhimg.com/80/v2-5a7a92c478035d6a08bd801f37363121_720w.png)\n\n## 方便管理\n\n用 VS Code 管理笔记就是在管理文件, 你可以很方便地将你的笔记放到不同的文件夹, 复制成好几份也是可以的, 你还可以把 PDF 文件和你的笔记文件放在一起, 反正就是怎么方便怎么来~ \n\n## 便于搜索\n\n因为笔记完全以文本的形式存储, 所以可以非常方便地进行搜索, 复习的时候再也不用担心啦!\n\n![](https://pic3.zhimg.com/80/v2-af446daddfeb07ad78ed3ac6a20e93ca_720w.png)\n\n## 版本管理\n\n通过引入 **Git** 这个工具, 我们可以很方便地进行版本回退. \n\n即, 你可以很方便地回退到以前你做的任意一个版本的笔记.\n\n## 云端存储\n\n你可以很容易地将你的笔记传上 GitHub 或 GitLab 这样的代码托管平台, 这样你就拥有了一份笔记的云备份.\n\n即使你本地的笔记不小心被删除了, 你也可以很方便地重新将其下载回来, 再也不用担心被别人删笔记了 (不是).\n\n![](https://pic3.zhimg.com/80/v2-17aca0c42944fc546df8bd378a8bc85a_720w.png)\n\n## 随心分享\n\n使用我写的这个网页应用, 你就可以随时随地查看你的笔记, 比如可以在走去食堂的时候, 用你的手机继续看笔记 (不要再卷了!).\n\n你也可以把你的笔记链接分享给别人, 让别人也可以看见你写的笔记, 毕竟笔记不就是用来给别人看的么 (不是).\n\n![](https://pic1.zhimg.com/80/v2-64a8fe27b9dc4a3e6c78ce51309a9c64_720w.png)\n\n![](https://pic2.zhimg.com/80/v2-b1c79c871655824b95d9292d9b508461_720w.png)\n\n## 发布知乎\n\n如果你用 VS Code 做笔记, 只要使用 `Zhihu On VS Code` 插件, 你就可以一键发布到知乎上!\n\n如果你搭建了自己的博客的话, 你也可以很简单地把你的笔记放到你的博客上面去, 就像这样:\n\n![](https://pic1.zhimg.com/80/v2-8a28cfa726b9977c06b80eaad21ef2c4_720w.png)\n\n## 提交作业\n\n我的作业几乎都是用 VS Code 写的.\n\n只要像记笔记一样, 写完作业, 保存成 PDF 版本, 用打印机打印出来就好, 多简单!\n\n![](https://pic2.zhimg.com/80/v2-613d2dd096c24a132e7b555f93653209_720w.png)\n\n别人甚至分辨不出来你用的是 Latex 还是 Markdown (不是).\n\n## 科学计算\n\n使用我开发的一个插件 `Latex Markdown Calculator` , 可以很方便地在 VS Code 中用 Latex 公式语法进行科学计算。\n\n即选中一段数学表达式, 按下一个快捷键就能帮你计算出结果, 一些简单的计算再也不用打开电脑自带的计算器和 Matlab. 因为是基于 Python Sympy 的, 已经有很多强大的功能了。\n\n比如说：符号运算, 求积分, 求微分, 基于矩阵的符号运算(如行列式, 点乘, 转置, 求逆等功能), 解方程...\n\n![](https://pic4.zhimg.com/80/v2-59abfbec7f2ac3d8d0c435cfc1c8551f_720w.jpg)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/Ud246889e25e84421a60a86435e693bfaJ.gif)\n\n## 自动补全\n\n也许你曾经看过这篇文章：\n\n[机器之心：世界上最好的编辑器Vim：1700多页数学笔记是如何实时完成的](https://zhuanlan.zhihu.com/p/61036165)\n​\n于是你很想试一下, 然后就被 Vim 和 Latex 给劝退了。\n\n但是实际上, VS Code 完全能够替代 Vim, Markdown 在记笔记方面也完全能够替代 Latex. 通过 VS Code 插件 HyperSnips for Math, 你就可以像用 UtliSnips 一样使用各种神奇的 Snippets.\n\n插件安装: [HyperSnips for Math - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=OrangeX4.hsnips)\n\n![](https://pic1.zhimg.com/80/v2-f9d96f22a34351d73eaa8cfe3447df68_720w.jpg)\n\n\n安装完成后, 按下快捷键 `Ctrl + Shift + P`, 输入命令 `Open Snippets Directory`, 就可以打开一个文件夹. 在该文件夹新建一个文件 `markdown.hsnips`, 并将 [这个网址](https://github.com/OrangeX4/OrangeX4-HyperSnips/blob/main/markdown.hsnips) 里面的内容输入进去, 保存, 就可以使用了.\n\n例如, 你可以在数学环境中输入: `(1+2)/`, 它会自动变为 `\\frac{1+2}{}`.\n\n我的 Snippets 改编自 [@独孤问道](https://www.zhihu.com/people/ren-zhe-81-65), 如果你想用 Latex 而不是 Markdown, 你也可以看看他的这篇文章:\n\n[【LaTeX 编辑环境搭建】TeX Live+VS code+HyperSnips（for math）插件](https://zhuanlan.zhihu.com/p/199268436)\n\n你也可以创建自己的 Snippets, 按照格式, 发挥想象来写就好!\n\n先看个 **普通例子**:\n\n```hsnips\nsnippet RR \"R\" iAm\n\\mathbb{R}\nendsnippet\n```\n\n这是一个在数学环境中自动展开的 Snippet, 它有三个标示符 `iAm`, 分别代表 \"在词语内部也会触发\", \"自动展开\" 和 \"数学环境\".\n\n这个例子会在数学环境内, 自动将 `RR` 展开成为 `\\mathbb{R}`, 代表 \"实数\".\n\n再看个 **正则表达式** 的例子:\n\n``` hsnips\nsnippet `((\\d+)|(\\d*)(\\\\)?([A-Za-z]+)((\\^|_)(\\{\\d+\\}|\\d))*)/` \"Fraction no ()\" Am\n\\frac{``rv = m[1]``}{$1}$0\nendsnippet\n```\n\n其中 `rv = m[1]` 是 JavaScript 代码, 表示将正则表达式的第一个组 `m[1]` 输出给 \"返回值\" `rv`, 然后输出出去.\n\n这是一个在数学环境中自动展开的 Snippet, 它有两个标示符 'Am', 分别代表 '自动展开' 和 '数学环境'. 用处是:\n\n```\n1/    --->    \\frac{1}{}\n```\n\n相比于原来的 HyperSnips, 最大特点是, 它只会在数学环境 `$...$`, `$$...$$`, `\\(...\\)` 和 `\\[...\\]` 中自动展开!\n\n**还有 `${VISUAL}` 语法:**\n\n```\nsnippet fr \"frac\" iAm\n\\\\frac{${1:${VISUAL}}}{$2}\nendsnippet\n```\n\n这个语法会保存最近选中的内容, 然后替换掉 `${VISUAL}` 部分.\n\n要开启在 markdown 下的 **自动补全提示**, 请使用 `Shift + Ctrl + P` 然后输入 `open settings json` 打开配置文件, 然后加入以下部分:\n\n```json\n\"[markdown]\": {\n    \"editor.quickSuggestions\": true\n},\n```\n\n## 马上学习!\n\n如果你也想学习怎么用 VS Code 做笔记, 快来看看 [相关教程](https://orangex4.cool/post/notes-in-markdown/) 吧!\n\n或者说你也可以看 [知乎专栏](https://zhuanlan.zhihu.com/p/366596107).\n\n","tags":["Study","VS Code","Notes"],"categories":["Study"]},{"title":"GitNotes - 一个在线的 Git 托管笔记浏览应用","url":"/post/gitnotes-a-notes-views-for-git/","content":"\n# 什么是 GitNotes?\n\n这是一个我开发的笔记浏览应用, 用于浏览以 **Markdown** 书写的, 存放在 **GitLab 或 GitHub** 上的笔记.\n\n优点: **数学公式支持和移动端适配**.\n\n笔记 Git Repo 参考: [NJUAI-Notes](https://github.com/OrangeX4/NJUAI-Notes)\n\n对应页面: [OrangeX's Notes](https://notes.orangex4.cool/?git=gitlab)\n\n## Demo\n\n### [OrangeX4's Notes](https://notes.orangex4.cool/)\n\n你可以**直接使用**这个网址查看你要查看的笔记 Repo, 并不需要挂载你自己的 GitNotes.\n\n## 原理\n\n* 界面: [React](https://zh-hans.reactjs.org/) + [Material UI](https://material-ui.com/zh/)\n* API: [GitHub API](https://docs.github.com/en/rest) + [GitLab API](https://docs.gitlab.com/ee/api/)\n* Markdown 支持: [Markdown-It](https://github.com/markdown-it/markdown-it)\n* 数学公式支持: [Katex](https://katex.org/)\n\n## 界面\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20210927180422.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20210927180448.png)\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20210927180516.png)\n\n<!-- more -->\n\n\n\n## 个人部署\n\n将代码 Clone 下来, 修改 `src/App.tsx` 文件对应的内容为以下形式:\n\n``` js\n// ---------------------------------------------------\n// const search = window.location.search\n// 请在这里更改你需要的 url 参数\nconst search = '?git=github&github=typoverflow/note'\n// ---------------------------------------------------\n```\n\n`search` 设为 URL 参数.\n\n要修改标题, 可以使用搜索功能搜索字符串并修改 `public/index.html` 和 `src\\App.tsx`.\n\n更换图标, 可以更换 `public/profile.ico` 和 `public/profile.jpg` 文件.\n\n进行完这些操作之后, 运行\n\n``` sh\nyarn start\n```\n\n便可实时浏览效果.\n\n确认无误后, 运行\n\n``` sh\nyarn build\n```\n\n便可生成 `build` 文件夹, 将该文件夹挂载到你的域名下, 你的专属 GitNotes 笔记便挂载好了!\n\n## 服务部署\n\n运行命令:\n\n``` sh\nyarn build\n```\n\n并将 `build` 目录下的静态文件挂载在你的域名中.\n\n","tags":["Study","Notes","GitHub","GitLab"],"categories":["Product"]},{"title":"GitHub 简易指南","url":"/post/github-tutorials-for-beginner/","content":"\n# GitHub 简易指南\n\n## 为什么要看这篇指南\n\n如果你是刚刚开始学习编程的学生, 想要了解和学习如何使用 GitHub, 那么, 你找对教程了!\n\n这就是你最应该看的 GitHub 指南.\n\n看完这篇指南, 你将会收获:\n\n* [对 GitHub 功能的基本了解](#什么是-github)\n* [对 GitHub 界面的基本了解](#github-repo-界面简易解释)\n* [版本控制工具 Git 的基础使用](#git-介绍)\n* [基础的 Markdown 写作](#github-文档)\n* [你的第一个 Pull Request 实践!](#实战-提交你的第一个-pull-request)\n* [了解如何使用 GitHub 进行团队协作](#团队协作)\n\n[这篇文章的 GitHub 地址](https://github.com/OrangeX4/GitHub-Tutorials), 欢迎 Star!\n\n[这篇文章的博客地址](https://orangex4.cool/post/github-tutorials-for-beginner/), 欢迎访问!\n\n封面图:\n\n![](https://pic4.zhimg.com/80/v2-b6c2a3ca328d995aa75ecfd6c560ccdf_720w.png)\n\n<!-- more -->\n\n## 什么是 GitHub\n\n先放上这张图镇楼:\n\n![](https://pic2.zhimg.com/80/7c9d3403bf922b1663f56975869c829b_720w.jpg?source=1940ef5c)\n\n(图片来源 [如何使用 GitHub](https://www.zhihu.com/question/20070065/answer/79557687))\n\n当然, 这只是开个玩笑, 虽然你在看过 [这个项目](https://github.com/komeiji-satori/Dress) 之后可能并不觉得这是一个玩笑.\n\n咳咳, 言归正传, 按照 Wiki 的定义, **GitHub** 应该是:\n\n> **GitHub** 是通过 **Git** 进行版本控制的软件源代码托管服务平台.\n\n听不懂？听不懂就对了, 这篇文章就是为你而写的！\n\n**GitHub** 其实是一个:\n\n* **全世界最大的代码托管平台**, 你可以在上面找到绝大多数的开源代码；\n* **团队协作开发平台**, GitHub 上有完善的协作功能(Fork, Issue, Pull Request 等功能)；\n* **文档**, GitHub 使用 Markdown 作为文档的书写语言, GitHub 上也存在许多技术文档.\n* **广告和简历**, GitHub 上聚集了世界上最多的程序员, 有许多人拿 GitHub 作为个人简历的亮点, 或者进行技术类相关的宣传；\n* **免费博客**, GitHub 提供了免费的静态网站托管服务 GitHub Page；\n* **自动集成**, 自动集成就是在你提交代码时或者定时进行类似的部署处理, 比如自动进行各种浪费时间的打卡任务(\n\n\n## 创建账号与创建仓库\n\n首先你要确保你能正常地访问 GitHub, 如果不能, 请自行寻找解决方法, 本指南不负责相关指导.\n\n1. 打开 GitHub, 你能看见一个炫酷的界面, 这时候你应该点 `Sign up`, 进入账号注册的流程.\n\n![](https://pic2.zhimg.com/80/v2-8013fffb78b29d184f480e96cd3be21d_720w.png)\n\n2. 紧接着, 填入你的用户名, 邮箱和密码, 再点击 `Create account`.\n\n![](https://pic1.zhimg.com/80/v2-d784b154194737aa4b9b2c909e95863c_720w.png)\n\n3. 经过一系列选择, 验证邮箱之后, 看见这个页面, 选择 `Create a repository`, 创建你的第一个仓库.\n\n![](https://pic3.zhimg.com/80/v2-081efaa7c1f10d6c1368e7d957860a22_720w.png)\n\n4. 填写仓库的名称, 介绍和其他配置.\n\n![](https://pic4.zhimg.com/80/v2-6ff1755492708b5f8bb483258f1b7f07_720w.png)\n\n5. 当你看见这样的提示, 他是在提醒你进行后续操作, 恭喜你, 你的第一个代码仓库创建成功了!\n\n![](https://pic4.zhimg.com/80/v2-261bfd442dddf0c645aba0a06ceb875f_720w.png)\n\n\n## Git 基础使用\n\n### Git 介绍\n\nQ: 什么是 **Git**？\n\nA: **Git** 是一种分布式版本控制工具, 换句话说, 是一种管理 \"代码历史记录\" 的工具.\n\nQ: Git 和 GitHub 又有什么关系呢?\n\nA: Git 先于 GitHub 出现, Git 是一种版本控制工具, 是一个在你电脑运行的工具. 而 GitHub 是依托于 Git 的代码托管平台, 是一个网站.\n\nQ: 使用 GitHub 一定要使用 Git 吗?\n\nA: 是的, 想要真正地使用 GitHub, 你必须得先学会 Git. 但这并不意味着你要称为 Git 专家, Git 只是一个工具, 你只需要学会基础地使用就行了.\n\n### Git 安装\n\n如果你是 Linux 用户, 请运行 `sudo apt-get install git` 命令安装 Git.\n\n如果你是 Mac 用户, 请参见 [brew.sh](https://brew.sh/).\n\n如果你是 Windows 用户, 请访问 [Git](https://pc.qq.com/detail/13/detail_22693.html) 下载与安装 Git.\n\n安装过程中不断点 `Next` 进行默认安装就好.\n\n![](https://pic2.zhimg.com/80/v2-1d68462aca1926f6c0e325f07c45c2d5_720w.png)\n\n安装完成后, 请打开你的命令行终端, 输入命令 `git`, 回车.\n\n(终端打开方式 Win 键, 输入 cmd, 或者 powershell, 回车)\n\n![](https://pic4.zhimg.com/80/v2-75a3f608362367bcd5f56825395bd12b_720w.png)\n\n如有如图的输出显示, 那么你就成功安装 Git 了.\n\n### Git 使用\n\n请参考 [廖雪峰的 Git 教程](https://www.liaoxuefeng.com/wiki/896043488029600).\n\n你不需要非常认真地将其全部记住, 只需要简单地浏览, 知道 Git 有些什么功能, 再将其当作工具书, 需要时再翻看即可.\n\n最基本, 你也需要掌握 Git 的这些内容:\n\n![](https://pic2.zhimg.com/80/v2-33f6c9791ac5abd328a981d5c80a278d_720w.png)\n\n简单来说, 你要学会:\n\n1. 使用 `git init` 命令建立版本库;\n2. 使用 `git add *` 命令将更新的文件加入版本库缓存区;\n3. 使用 `git commit -m \"更新内容\"` 命令进行 Commit, 每一次 Commit 就相当于保存一份备份, 作为时间线的一个节点;\n4. 使用 `git log` 命令查看完整时间线, 方便进行版本回退;\n5. 使用 `git reset --hard <commit_id>` 进行版本回退, 即返回你保存的某个备份, `<commit_id>` 是你使用 `git log` 看见的 ID 值;\n6. **如何使用 Git 将本地的版本库推送到 GitHub;**\n7. 使用 `git clone <url>` 命令将 GitHub 上的代码仓库给 Clone 下来.\n8. 使用 `git pull` 拉取远程分支(团队其他人可能修改了代码), 如果有冲突, 解决冲突;\n9. 使用 `git push` 推送分支到远程分支, 进行团队同步;\n\n### VS Code 与 Git\n\n如果你用的是宇宙第一文本编辑器 VS Code 的话, 你可以很便利地进行 Git 操作.\n\nVS Code 左端有一个版本控制面板, 如图, 你可以很简便地使用.\n\n![](https://pic4.zhimg.com/80/v2-f0f778cfee09eb9bb0e0008f57e640af_720w.png)\n\n\n## GitHub 文档\n\n不出所料的话, 你已经在 GitHub 成功创建了自己的第一个代码仓库了.\n\n接下来, 你要给你的仓库加一些介绍文档: `README.md`.\n\n如图, 在 GitHub 新建 Repo 后, 照着 GitHub 的说明执行:\n\n![](https://pic2.zhimg.com/80/v2-d4975102f1f08c67a0071511d4e40e8d_720w.png)\n\n``` sh\necho \"# first-repo\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/OrangeX5/first-repo.git\ngit push -u origin main\n```\n\nPS: 记得先按照 Git 教程里说的, 在 GitHub 加入你的 SSH key 噢.\n\n然后你的 `README.md` 文件将会以 Markdown 形式展示在你的仓库页面.\n\n![](https://pic2.zhimg.com/80/v2-18e9ca0fe4071670e7568d39feb154f1_720w.png)\n\n**Markdown** 的语法非常简单, 比如:\n\n\n``` markdown\n# 一级标题\n## 二级标题\n### 三级标题\n\n每写完一个段落要隔一行空行.\n\n就像这样, 隔了一行空行.\n\n---\n\n分割线\n\n**重点加粗**\n\n*斜体*\n\n~~删除线~~\n\n---\n\n列表:\n\n* 并列列表项\n  * 嵌套并列列表项\n  * 嵌套并列列表项\n* 并列列表项\n* 并列列表项\n\n1. 列表项 1\n   1. 并列列表项 1\n   2. 并列列表项 2\n2. 列表项 2\n3. 列表项 3\n\n---\n\n引用文本:\n\n> 引用别人说的话\n> 就这样写\n> By. OrangeX4\n\n---\n\n这是 `行内代码` 语法.\n\n代码块语法:\n\n''' python\nprint(\"Hello, World!\")\n'''\n\n请将 ' 替换成 `.\n\n---\n\n[超链接名称](链接地址)\n\n![图片提示语](图片地址)\n\n---\n\n表格:\n\n| 表头 | 表头 |\n|------|------|\n| 内容 | 内容 |\n| 内容 | 内容 | \n\n---\n\n数学公式:\n\n行内 $x^2+y^2=1$\n\n公式块\n\n$$\nx^2+y^2=1\n$$\n```\n\n你已经掌握了 Markdown 的写作方式了!\n\n实际上 Markdown 一般会被渲染成 HTML, 所以你也可以在里面使用 HTML 标签.\n\n\n## GitHub Repo 界面简易解释\n\n### Code 页面\n\n![](https://pic4.zhimg.com/80/v2-b6c2a3ca328d995aa75ecfd6c560ccdf_720w.png)\n\n### Issues 页面\n\n![](https://pic4.zhimg.com/80/v2-904f8cd0065be0e56c90cc879b3678c7_720w.png)\n\n### Pull requests 页面\n\n![](https://pic4.zhimg.com/80/v2-0200a5cd2f228d92ec4c6f0333c1916b_720w.png)\n\n一般来说, Pull Request 的流程是:\n1. 先 Fork 这个 Repo, 你就有了这个 Repo 的一个专属你的复制版 Repo;\n2. 用 Git Clone 克隆到本地, 进行你想进行的代码修改;\n3. Git Push 到你的复制版远程仓库;\n4. 提一个 Pull Request 给原来的 Repo.\n\n整个流程会在后续详细说明, 你可以体验到你的第一个 Pull Request.\n\n\n## 实战! 提交你的第一个 Pull Request\n\n### Fork 项目\n\nFork 一个你要提交 Pull Request 的项目.\n\n[First-Pull-Requests](https://github.com/OrangeX4/First-Pull-Requests) 是我创建的一个 Repo, 你可以在这里尝试提交你的第一个 Pull Request.\n\n![](https://pic3.zhimg.com/80/v2-1ec5d4220e95acffbd4d229f6b4c1d56_720w.png)\n\n点击右上方的 `Fork` 按钮, 你可以看见这个 Repo 已经被你 Fork 了下来, 即复制了一份.\n\n![](https://pic4.zhimg.com/80/v2-2c2a00667d1ad67ae54622e62b5dece3_720w.png)\n\n### 加入内容\n\n点击这个铅笔按钮, 进入编辑模式.\n\n![](https://pic1.zhimg.com/80/v2-0811a67202794eaf8f2cf3384273bc54_720w.png)\n\n按照格式加入你要加入的内容, 在这里是你的名字和评论.\n\n![](https://pic2.zhimg.com/80/v2-6e14941c1c261ce2eeade0868b844b15_720w.png)\n\n输入 Commit 信息, 点击下面的 Commit 按钮.\n\n![](https://pic1.zhimg.com/80/v2-32ec867a732c91c2a33948a88e675b6c_720w.png)\n\n可以看见, 在你 Fork 出来的 Repo 中, 内容已经发生了改变.\n\n![](https://pic3.zhimg.com/80/v2-e6eaee4be08e5f1893da6f67b3847cba_720w.png)\n\n### 发送 Pull Request\n\n点击你 Fork 的仓库中的 Pull request 按钮:\n\n![](https://pic2.zhimg.com/80/v2-cdb24afc8d624a00bd301b34d0651911_720w.png)\n\n接下来的页面会显示你修改的内容, 确实无误后点击 `Create pull request` 按钮.\n\n![](https://pic3.zhimg.com/80/v2-9081bf3f17ebdc5193a1061e1f49fe5e_720w.png)\n\n接下来是添加一些你的 Pull Request 的描述, 保证你的 Pull Request 能打动原 Repo, 让其同意接收.\n\n![](https://pic3.zhimg.com/80/v2-d1734e21e22fb6a104b79e96be977872_720w.png)\n\n然后原 Repo 就会出现你的 Pull Request, 你只需要静静等待对方回复即可!\n\n![](https://pic4.zhimg.com/80/v2-b921e322472f46a0e44e8f09c851fa2b_720w.png)\n\n### 同意 Pull Request\n\n如果你收到了一个 Pull Request, 经过代码审查后, 你可以 Merge 这个 Pull Request 到你的仓库中.\n\n![](https://pic3.zhimg.com/80/v2-e7bcaa5396fe84ee9d4a4fdcd7b9fb9e_720w.png)\n\n最后, 可以看见, Pull Request 的内容以及被合并到原 Repo 里了!\n\n![](https://pic1.zhimg.com/80/v2-0d72d797b38eac54daaed769c4dfd58c_720w.png)\n\n这就是一个 Pull Request 的完整流程.\n\n## GitHub 团队协作\n\n如果你是**队长**, 你需要了解创建组织和创建 Repo, 还要掌握基本的代码提交和代码审查;\n\n如果你是**团队成员**, 可以跳过创建组织和创建仓库步骤, **直接跳到团队协作部分**.\n\n### 创建组织\n\n1. 当你需要与团队进行团队协作时, 你可以在 GitHub 首页, 选择 `New organization` 新建一个组织.\n\n![](https://pic4.zhimg.com/80/v2-a36c03df37dab6cbadc48944ecd0f273_720w.png)\n\n2. 选择一个收费计划, 实际上, 对于小团队来说, 免费的 Free 计划已经完全足够.\n\n![](https://pic4.zhimg.com/80/v2-8adc58be1dcf368492a2fd9fe986d8a3_720w.png)\n\n3. 输入你们组织的名称, 联系邮件, 确认, 就可以创建一个你自己的组织了.\n\n![](https://pic4.zhimg.com/80/v2-675dde6e0274b55d6ad649819172f72b_720w.png)\n\n4. 再输入你要邀请的成员的用户名或者邮箱.\n\n![](https://pic3.zhimg.com/80/v2-c288e75e28a520649b768aecd432f752_720w.png)\n\n5. 填写一些你即将用 GitHub 的团队协作功能做些什么的信息, 就完成了组织的创建.\n\n![](https://pic2.zhimg.com/80/v2-ff241a2b1c82d346b67598ea9b8b8a59_720w.png)\n\n6. 最后, 你获得了一个你自己的组织, 可以写你们组织专属的 Repo 了!\n\n![](https://pic3.zhimg.com/80/v2-4ac863e463fab93e8c0778a9b0d0acde_720w.png)\n\n### 创建仓库\n\n创建一个你们团队的仓库:\n\n![](https://pic2.zhimg.com/80/v2-c2f6e1fc5216a661c3d34877aeb777a5_720w.png)\n\n默认来说, 组织的普通成员对 Repo 访问权限是只读, 即有浏览代码的权限, 没有修改的权限. 这样的权限管理是比较推荐的, 普通成员可以通过 Pull Request 来提交自己的代码, 团队所有者可以进行代码检查, 以防止出现不好的代码.\n\n但是如果你一定要修改权限, 也可以在组织的 `Setting` 中, 将团队成员的权限改为 `Write`.\n\n![](https://pic2.zhimg.com/80/v2-57a17fded860de863235be798ef59c3d_720w.png)\n\n### 团队协作\n\n1. 队长创建 dev 分支, 方便后续合并代码, 可选.\n\n![](https://pic4.zhimg.com/80/v2-5dd380866cfe2ff5cb22d99a76cb0efb_720w.png)\n\n2. 在当前 Fork 一个新 Repo 到你自己的账户.\n\n![](https://pic3.zhimg.com/80/v2-59c542d82e5d129b254af95bff44440e_720w.png)\n\n3. 克隆你自己的新 Repo 到本地.\n\n``` sh\ngit clone git@github.com:<Your-name>/Team-Test.git\ncd Team-Test\n```\n\n4. 和团队同步.\n\n使用命令\n\n``` sh\ngit remote -v\n```\n\n查看有没有 upstream, 如下图即是没有.\n\n![](https://pic3.zhimg.com/80/v2-5980f789ec90f2eb529a77223d4ad5de_720w.png)\n\n再输入命令\n\n``` sh\ngit remote add upstream git@github.com:<Team-name>/Team-Test.git\ngit remote -v\n```\n\n如图, 即加入成功了.\n\n![](https://pic2.zhimg.com/80/v2-824820b5362268cb178431118d58aa25_720w.png)\n\n使用命令与 upstream 同步:\n\n``` sh\ngit fetch upstream\ngit merge upstream/main\n```\n\n如果遇到代码冲突, 请处理冲突.\n\n5. 使用 push 推送到自己的 Repo\n\n再在本地进行一些代码修改(记得 `git commit`), 然后使用\n\n``` sh\ngit push\n```\n\n推送到自己的 Repo 里.\n\n![](https://pic1.zhimg.com/80/v2-932e6bc2d878f92f591e6127ab86f884_720w.png)\n\n6. 进行 Pull Request 合并到团队项目\n\n在你自己 Fork 的 Repo 里发起 Pull Request:\n\n![](https://pic4.zhimg.com/80/v2-c7ef3497f26f7b90be0281fad6fe5f37_720w.png)\n\n![](https://pic1.zhimg.com/80/v2-259021e946665479b6f61afdbfa9ef98_720w.png)\n\n![](https://pic4.zhimg.com/80/v2-409eefafb4dfad6b2f5d698467113fcf_720w.png)\n\n然后项目管理者就可以对代码进行 Merge.\n\n![](https://pic2.zhimg.com/80/v2-765e042c447c3c2a3d6a4eb44733a48d_720w.png)\n\n于是 README.md 文件就被更新了!\n\n![](https://pic1.zhimg.com/80/v2-2736ca012ec15142cebda716baa3bb1c_720w.png)\n\n\n### 解决冲突\n\n如果有其他人在主 Repo 做了某些修改, 你必须要同步这些修改.\n\n例如, 原来是 `A test for team` 的文本现在变成了 `A test repo for team`.\n\n![](https://pic2.zhimg.com/80/v2-d6098a9e3ca0d991b8cb4afda0ab6985_720w.png)\n\n这时候, 你 Fork 的 Repo 和你电脑本地的的仓库也应该及时更新与解决冲突.\n\n这时候, 你在你本地执行这三条命令, 处理冲突和更新代码.\n\n``` sh\ngit fetch upstream\ngit merge upstream/main\ngit push\n```\n\n![](https://pic2.zhimg.com/80/v2-b1c77bae9b902cc6f01dbee14cd5d685_720w.png)\n\n于是, 你的代码也被更新了, 恭喜, 你学会了团队协作的大部分流程了!\n","tags":["GitHub"],"categories":["Technology"]},{"title":"Presentation - The Three Body Problem","url":"/post/presentation/","content":"\n# Book We Enjoy\n\n## Prologue\n\nHello everyone. I am Fang Shengjun. Today I would like to talk with you a popular book.\n\nBefore the start, you can scan the QR code, and you will get the handout of my presentation. I'm worried that I can't express myself well, but I believe that you can know what I am saying with the handout.\n\nAre you ready? Let us start the presentation.\n\n![background](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedUaaabb59912a2467a8c8ecf99a442404fg.jpg)\n\n<!-- more -->\n\n## Outline\n\nI have divided my presentation into three parts.\n\nFirst of all, I will introduce you the basis of the book.\n\nSecondly, I will tell you some interesting plots about the book.\n\nFinally, I will talk about the influence of the book.\n\n## Introduction\n\n![Three](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU1ad8ece085ce4285beaa40e4e7d55c5aa.jpg)\n\nLook up this picture, what do you think about? Three stars move in chaotic trajectories. Yes, the book I want to introduce to you today is *The Three Body Problem*, a science fiction written by Liu Cixin.\n\n![Book](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU9aa96967a42d49a89fe4f3bbc8922797h.jpg)\n\n![QR Code](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedUf0a4c68a56f54ddcb83a2fe2eeadd6c74.jpg)\n\nI believe someone has already read the book, so let me do a survey. Again, scan the QR code, and answer the question: Have you read the science fiction *The Three Body Problem*?\n\nWe can wait a minutes.\n\nUmm, we get some data. There are XX people who have read the book. So there are still somebody who have read the science fiction.\n\nThere is your handout.\n\nAre you ready? Don't waste too much time on it, and let us go for next part: the interesting plots about the book.\n\n## Plots\n\nThere are many great ideas in *The Three Body Problem*, but I am afraid that it is impossible to describe even one plot in such a short moment. I will try my best to tell you some interesting plots as more as possible.\n\n![Red](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU561fdaae4fff4ac3abeb6ab8436146fcO.jpg)\n\n### Three Stars System\n\nThe main plot of *The Three Body Problem* is about aliens living in Alpha Centauri who are planning to invade the Earth and Human. We call the aliens Trisolaran.\n\nTrisolaran live in a solar system with three suns. You can imagine how hard it is to living with three suns.\n\n![Three Stars](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU5f1bf3781c70428ea9e9c7a0f0d75354K.jpg)\n\nWe all have learned physics, and we know that one planet with one sun move regularly, just like our planet, the Earth. One planet with two suns also move regularly, just like this. It is also predictable.\n\nBut three-stars system is a chaotic system. The trajectory of three-stars system is unpredictable. It is a three-stars system that Alien Trisolaran lives in.\n\nIn order to develop their civilization, Trisolaran must wait for Stable Era, the time when suns are relatively stable. In Chaotic Era, they will dehydrate. In Stable Era, they will rehydrate.\n\n### The Human-Formation Computer\n\nThere is a big problem in front of Trisolaran. How to predict the time of Stable Era?\n\nTrisolaran use many methods to predict the time of Stable Era. One way is simulating the three stars system with computer. So they also invent computer. But the component they use, is not circuit, but human, or themselves.\n\n![Computer](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU3ae040e5f12247b8a61466feafb629c6c.jpg)\n\nSome people form the AND gates, some people form the OR gates and some people form the NOT gates. We have learn the course *Fundamentals of Digital Circuits*, we know that we can form computer with AND, OR, NOT gates.\n\n### Sophon\n\nFinally, they find a more convenient way. It is to invade the Earth, a planet they discover recently.\n\n![Earth](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedUe16d5531cc2c40a5855ccd7b78d3f040k.jpg)\n\nBut Human are developing too fast, so they must use some way to lock the developing of Human in science.\n\nThey transformed a proton into 2-dimension and engraved circuit on 2D proton. Then, they transformed it back into 3-dimension and get a intelligent proton. They called she Sophon, or Zhizi.\n\nSophon can disturb Collider, which is necessary to research micro particles. Besides, Sophon can also monitor human's every movement and conversation.\n\nSometimes, Sophon appear in woman's appearance. Look at this picture. I believe many people have seen this picture. She is Sophon.\n\n![Sophon](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU14fbc42c6ffa4b6fba22d74194e973e94.jpg)\n\n## Influence\n\nFinally, let us talk about the influence of *The Three Body Problem*.\n\nObama, the former president of United States of American, ask for Liu's next book after he read *The Three Body Problem*. Finally he was given *The Wandering Earth*.\n\nZuckerberg, the CEO of Facebook, also recommend *The Three Body Problem* with others.\n\nIn Japan, *The Three Body Problem* also became best-seller. Many people recommend the book with others.\n\n![Influence](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU8e8827336a7242bfb692ddaae68b56280.jpg)\n\nI am sorry to cite *New York Times*. But I must say that *The Three Body Problem: Death's End* got into New York Times Bestseller list. Science fiction of China conquered American.\n\nIn the end, I want to recommend a fan work for you, *The Three-body problem in MC*. It is an anime, which possess the plots of *The Three Body Problem* and style of Minecraft.\n\nThat is all. Thank for your listening!","tags":["Study","NJU"],"categories":["Study"]},{"title":"论软件与互联网行业中的经济学现象","url":"/post/economy-of-software-and-internet/","content":"\n# 论软件与互联网行业中的经济学现象\n\n## 摘要\n\n软件行业和互联网行业作为新兴行业，是实现创新和推动经济发展的先锋力量。\n\n但软件和互联网市场与常规市场不同，软件和互联网行业不仅是不完全竞争市场，并且边际成本为零。软件行业的定价如同垄断竞争市场，又通过独特的方式进行价格歧视，以获取更大收益。\n\n互联网行业又与软件行业不同，受到网络效应“网络的价值为用户数的平方”影响，互联网行业通常采用免费策略，然后通过获取的流量变现盈利。流量变现的方式通常是广告，因为互联网天生适合广告，而广告可以让面向普通消费者的垄断竞争企业获取更大利润，让面向普通消费者的垄断竞争行业双方利益最大化。\n\n除了广告之外，互联网企业还有很多其他的流量变现方式，其中非常重要的一个是增值服务。增值服务与软件产品的销售方式非常类似，均是成本为零的垄断竞争产品，常见的增值服务类型有会员体系，网络游戏虚拟物品和打赏机制。增值服务和软件的区别，一般是娱乐与办公的区别。\n\n<!-- more -->\n\n## 一、竞争者与垄断者——软件行业垄断竞争下的价格制定\n\n从世界上第一台通用计算机“ENIAC”于1946年发明至如今2021年，已经有75年。而互联网的主体万维网自1990年发明至今，仅仅有31年，显得更为年轻。计算机的发明带来了软件行业，而万维网的发明带来了互联网行业。软件行业和互联网行业有许多相似之处，但又有不同的地方。\n\n软件行业和互联网行业都有同样一个显著的特点：开发一个软件或一种互联网服务需要许多的研发投入，但由于电子数据的复制成本几近于零和租用服务器的价格并不高昂，所以后续拷贝发行的成本极低，即两者的固定成本均较高，但边际成本极低，几近于零。\n\n软件行业和互联网行业也有许多不同之处。软件行业更接近于书籍行业，固定成本高边际成本低，且收入仅仅取决于书籍的价格和读者的数量。互联网行业更接近于媒体行业和服务行业，可以像部分报纸免费发放，通过报纸上的广告盈利；也可以通过提供不同的服务，通过服务费或手续费盈利。\n\n基于由浅入深的原则，这部分首先考虑盈利模式和结构更为简单的软件行业，通过对软件行业中显著的垄断竞争模式的分析，探究软件行业边际成本几近于零，却定价高昂的原因。\n\n软件行业，包括买断制电子游戏行业，均符合垄断竞争市场的特征。垄断竞争市场的三个特点是：\n\n1. 有着许多的销售者：世界上存在着许多软件公司和买断制电子游戏公司；\n2. 产品存在差别：由于专利制度和版权制度，还有编程代码和公司定位的差异性，每个公司开发的软件都不可能完全一样，会有较为显著的差别，但是不同软件之间却依然是可以相互代替的；\n3. 自由进入和退出：软件企业可以无限制地进入或退出这个市场。\n\n有了垄断竞争市场的设定，我们就可以分析一款软件应该如何定价。假设有一家软件公司名为 M，他们开发了一款软件叫 A，然后他们开始考虑应该如何对软件进行定价。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216084934.png)\n\n首先是成本，我们不妨认为，M 公司是通过互联网而不是光盘来分发软件的，拷贝成多份几乎不需要任何成本，即边际成本为零。但是软件的开发成本较大，M 公司投入了 1000000 美元进行了 A 的开发，那么软件的固定成本便是 1000000 元。由于边际成本（MC）为零，因此平均总成本（ATC）与销量的关系为简单的倒数函数关系。\n\n$$\nATC(n) = \\frac{1000000}{n}, \\text{其中} n \\text{为销量，单位为元}\n$$\n\n然后便是需求，在一般情况下，不同的人对软件价格的预期价格不同，所以需求量随着价格的升高而递减。例如定价在3500元时，销量为1000份；定价在500元时，销量是700份。在这里为简化运算起见，我们将价格与需求量的关系图像（DC）看作是倾斜向下的一次函数：\n\n$$\nDC(n) = 4000 - 0.5n, \\text{其中} n \\text{为销量，单位为元}\n$$\n\n我们可知，定价乘以销量，我们就能够得到总收入（TR）:\n\n$$\nTR(n) = n DC(n) = 4000n - 0.5n^2, \\text{其中} n \\text{为销量，单位为元}\n$$\n\n我们可以由总收入计算出边际收入（MR），即增加一份销量所增加的收入，我们可以通过对总收入（TR）求导求得边际收入（MR）：\n\n$$\n\\begin{aligned}\nMR(n) =&\\frac{TR(n)-TR(n-1)}{n-(n-1)} \\\\\n=&\\frac{ΔTR(n)}{Δn} \\\\\n=&TR'(n) \\\\\n=&4000 - n \\\\\n\\end{aligned}\n$$\n\n我们注意到，边际成本（MC）即x轴，只要边际收入（MR）在x轴下方，边际收益就为负数，此时增加销量反而会降低总收入，因此最佳销量应该是MC（x轴）与MR的交点，如图中的 A 点，4000 份销量。而 A 点的销量对应需求曲线（DC）上的一点B，这点 B 对应的价格 C，2000 元，即为 M 公司应该制定的价格。\n\n似乎平均总成本（ATC）在这里没有发挥任何作用？我们取 AB 与 ATC 曲线的交点D，我们就能够知道，成本为矩形 AOED 面积，收入为矩形 AOCB 面积，进而可知利润为矩形 DECB 面积。当利润小于零时，开发这个软件就是不合算的；利润大于等于零时，开发这个软件就是合算的。\n\n短期来看，定价 2000 元是合算的，因为需求曲线在短期内不会改变。但是长期来看，由于 M 公司开发的 A 获取了利润，甚至利润是成本的好几倍，引来了竞争者 Maple 公司的嫉妒，于是 Maple 公司也决定开发一款类似的软件 Wac。越来越多像 Maple 一样的公司加入，使得消费者对 A 软件的需求急剧下降。在长期的均衡中，需求曲线与平均成本曲线相切，此时利润为零，若需求曲线再降低，M 公司就会倒闭。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085000.png)\n\n## 二、获取最大利益——软件行业的价格歧视\n\n那么是否 2000 元就是 M 公司对于 A 软件所能制定的最好价格呢？我们观察图像，我们发现还有两块面积并不包括在收入里：三角形 BCG 所代表的消费者剩余和三角形 BAF 所代表的无谓损失。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085017.png)\n\n消费者剩余指的是消费者的预期价格与实际价格的差值。例如小明本来愿意以 3000 元购买 A 软件，但是实际价格是 2000 元，相当于小明还剩下 1000 元的消费者剩余，而这 1000 元本来小明是愿意付给 M 公司的。如果 M 公司有办法让小明这样的人出价3000元购买软件，那么将会增加图中的矩形CJIH的利润，又是一大笔收入。依次类推，M 公司能够通过进一步地划分市场，来将更多地消费者剩余转化为利润。在价格歧视的情况下，M 公司是有利的，而小明这类的消费者是不利的。\n\n无谓损失是指，因为软件价格过高，本来有购买意愿的消费者望而却步，没有达成购买软件交易所造成的双方的损失。例如小李只愿意以 1000 元的价格购买软件，但是软件价格是 2000 元，所以交易没有达成。如果 M 公司愿意以 1000 元的价格将 A 软件卖给小李这类用户，那么小李将会得到使用软件的好处，由于边际成本是零，M 公司也将增加图中矩形 AMLK 的利润，这对双方都是有利的。\n\n但是在实施价格歧视之前，我们要明确：用户可以通过“代购”的方式来规避价格歧视。例如小明可以让支付给小李 1500 元，让小李以 1000 元的价格购买软件再转交小明。这样的话，M 公司不仅没能以 3000 元卖给小明，而且最后只收到了 1000 元，比原先的 2000 元还少了 1000 元。软件行业还需要考虑盗版问题，如果软件价格过高，许多潜在的消费者就会转向盗版。\n那么常见的价格歧视手法有哪些呢？由上面分析我们可知，对小明这类高价格接受者进行价格歧视，对消费者不利，因此一般会被消费者市场谴责，反而导致消费者对 M 公司心生不满，降低购买意愿；而对于小李这样的低价格接收者进行价格歧视，对双方都有利，消费者市场就易于接受。虽然因为这里的高价格接收者和低价格接收者是相对而言的，所以两种方式在本质上是一样的，很多时候只是名义上的不同。\n\n这里列举一些收益较差的，或是不受消费者认可的价格歧视方法：\n\n1. 在售出软件时，对部分消费者收取比标准价格更高的价格。缺点是会使消费者心生不满，降低购买意愿。\n2. 一些电商平台进行大数据杀熟，偷偷增加熟客的商品购买价格，以赚取更多利益。缺点是消费者本来不知情，而事情一旦被揭露公司就会被反噬。\n3. 不标示标准价格，让消费者亲自询问，以制定专属价格。缺点是，低价格接受者会认为软件的价格一定会非常高，直接离开，寻找替代的软件；高价格接收者会派出专业的团队来协商，且一定会往低报价，不会暴露真正的预期价格，这样效果反不如固定价格。\n\n当然，世界上成功的价格歧视还是很多的：\n\n1. 不同书籍在不同的国家销售价格不同，在发达国家同样的书价格更贵。\n2. 对儿童和老年人来说，车票和门票一般都有优惠价格，这是因为他们没有稳定的收入来源，能够接受的价格更低，同时社会也较为认可对他们收取更低的价格。\n3. 通过不同的方式发放优惠卷，低价格接受者愿意花时间收集优惠卷，而高价格接收者不愿意花自己宝贵的时间来收集优惠卷；同理还有各种规则复杂的优惠活动，低价格接收者愿意花更多的时间来研究如何在这样复杂的活动中买到价格尽可能低的商品。\n\n而软件行业的价格歧视也同理，有着许多被证明有效的方式：\n\n1. 将一次性买断制转变为订阅制：不同的人对软件的使用时长是不一样的，一部分人可能要用一年，一部分人可能要用一个月，甚至有的人只需要用一天。如果是买断制，只使用一个月或者使用一天的人可能就会放弃购买软件；如果是订阅制，每个人都能选择自己需要使用的时长来购买软件，无谓损失就减少了。\n2. 给学生提供优惠价：学生对软件的需求量很大，但是却没有稳定收入来源，如果给学生提供学生优惠价格，学生就能买得起软件，在毕业工作之后也更倾向于购买自己熟悉的软件。\n3. 区分商业版和非商业版：允许非商业组织以较低价格甚至免费使用软件，可以增加软件知名度，与学生优惠价类似。\n4. 区分不同地区价格：例如，Steam平台在不同的国家销售相同的游戏，但是对发达国家地区的收费比发展中国家的收费要高。\n\n\n## 三、慈善家还是广告商——互联网行业的免费策略\n\n互联网从诞生到如今，仅仅过去了三十年，却成就了当今市值最高的几个公司，例如 Google 和 Facebook。而且大部分互联网公司都有相似的特点：向大众提供免费服务，通过获得的流量盈利。\n\n而这种互联网行业的免费策略，是从雅虎公司开始的。相较于当时美国在线AOL的低价月租模式，雅虎开创了更为大胆的免费模式：雅虎将自己看作是一个媒体公司，用户免费访问雅虎的网站，雅虎通过广告商投放在雅虎网站上的广告盈利。雅虎是世界上首个门户网站，借助这样的免费策略，雅虎公司成为了世界上首个市值突破千亿美元的公司，引领了一代互联网潮流。即便雅虎在今天已经没落，这种免费策略也依旧在互联网行业流传了下来。\n\n我们要研究的是，为什么互联网公司通常可以采取免费策略盈利，而软件行业等其他行业一般却不采取免费策略。互联网公司采用免费策略的主要原因是，免费策略可以带来庞大的流量，并且流量可以变现；而流量变现的最基本的方式，是广告。\n\n首先我们要清楚广告存在的原因：广告可以影响需求曲线。对于完全竞争市场，例如小麦、花生和原油市场，广告一般是没有用处的，因为完全竞争市场的需求曲线完全没有弹性，永远是一根水平直线，不会因广告而变动；对于工业用品这类面向大型企业的市场，例如车床、通信卫星市场，广告一般也很难发挥什么作用，因为大型企业会进行认真的市场调查，通过分析不同企业产品的参数来决定最终选择，很难受广告的影响。广告最常发挥作用的地方还是面向普通消费者的垄断竞争市场或寡头市场（不完全竞争市场），常见的有书籍，电影，饮料，软件和互联网市场等。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085036.png)\n\n再分析广告影响需求曲线的方式。面向消费者的不完全竞争市场下，消费者对于丰富多样的差异性产品的了解是很少的，毕竟消费者没有办法购买市场上的每一件物品，也难以进行详尽的市场调研和分析。\n\n我们来分析一款新上市的产品。例如有一款名为 Plane 的玩具，在一开始，消费者小明没有听说过 Plane 玩具，自然也不会有任何的购买意愿，即预期价格为零，如图中的A点；当小明第一次看见了广告，他会在心里将 Plane 玩具与他曾经买过的玩具相比来确定一个对 Plane 玩具的预期价格，并且此时小明没有购买过 Plane 玩具，所以预期价格一般在他买过的玩具价格之间，即图中的B点；随着广告接收次数增高，小明对 Plane 玩具的预期也逐渐升高；直到第5次看见 Plane 的广告，小明终于决定购买 Plane 玩具，购买之后，小明发现 Plane 玩具比他想象中的有意思，所以小明对 Plane 玩具的预期价格变高了，如图中的C点到D点；在D点之后，由于广告的品牌效应，小明看见广告次数越多，对 Plane 玩具的预期价格可能也就会越高。整个典型的图像如图。\n\n相应的，在没有广告的时候， Plane 玩具的供给曲线可能如图，最高价格为 10 元，最大销量为 5 万件：\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085556.png)\n\n在 Plane 玩具厂商投放了一次广告的时候，更多的人了解到了 Plane 玩具，那么供给曲线就会变宽，最高价格为 10 元不变，最大销量增加到了 10 万件。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085621.png)\n\n在 Plane 玩具厂商投放了多次的广告的时候，大部分消费者决定去买一个 Plane 玩具来试玩，如果消费者的觉得 Plane 玩具比他们想象中的好玩，那么消费者对 Plane 玩具的预期价格就会升高，表现在图像上即需求曲线变高，此时最高价格增加到了 15 元，而最大销量依然是 10 万件。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085642.png)\n\n至于为什么广告越多，消费者的预期一般会逐渐上升呢？我们想象一种场景，如果用户在尝试购买 Plane 玩具之后，发现根本不如心中预期那般好玩，于是下调了预期价格。或者是广告产生的利润还不如广告花费的成本，这种情况下，广告商就不会选择投放广告。这也就间接的说明了：在大多数情况下，广告投放越多的厂商的产品，往往比大部分竞争对手的商品更为优质，这种情况下广告是一个质量信号。用户会更偏向于溢价购买广告投放更多的品牌，因为这样的品牌是他们所熟悉的，且保证了一定的质量。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085158.png\n)\n\n就整个经济而言，企业的总收益平均有2%投入广告之中，且广告投放的方式往往是有限的，传统的广告方式有电视，报纸，杂志和广告牌等，现代广告往往依赖于互联网。对于互联网企业来说，就算采取免费策略，只要广告收入能够覆盖开发成本，就是有利可图的。\n\n互联网公司需要流量，即提供的互联网服务的使用人数，因为互联网公司通过流量变现。互联网公司流量变现的方式通常是广告，也可以是增值服务、手续费、第三方支付利息等方式，单位流量收入通常随着公司变大而增加，即随着总流量递增而递增。互联网服务在初期需要推广，成本较高；但是因为网络的马太效应（网络的价值是网络所拥有用户数的平方，强者恒强），所以后续推广成本逐渐降低；降低到一定程度，即使不花任何费用来推广，口碑效应也会让流量不断增长；流量增长到一定程度，剩余仍未使用过该互联网服务的用户，会因为学习成本等问题不自发加入该互联网服务，需要互联网企业再度投入成本，用新用户补贴等方式，来继续获取新流量。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085215.png)\n\n因此互联网企业总是以这样的模式发展：\n\n1. 确定相应的商业计划，吸引资本。\n2. 起始将一部分的资本投入互联网服务开发中。\n3. 前期使用广告营销或者用户补贴吸引用户。\n4. 长期利用互联网的马太效应扩张，获取利润。\n5. 增长停滞时，投入成本，采取新用户补贴、用户下沉等方式，来进一步扩大用户面。\n\n例如近些年腾讯阿里分别投资美团和饿了么，进行了疯狂的补贴大战，为的就是以最快的速度度过前期的发展，抢先进入长期的马太效应增长来击败对手，达成盈利的目的。\n\n腾讯公司在许多方面都能后发制人，战胜竞争对手，就是靠自身即时通讯软件 QQ 和微信的强大导流效应，快速度过前期的推广阶段，进入长期盈利阶段。\n\n在这些案例中我们可以知道，流量、推广以及单位流量盈利率是互联网的免费模式中最重要的几个成分，免费并不代表是慈善，免费也是有利可图的生意。\n\n\n## 四、提供增值服务——互联网行业的价格歧视\n\n相较于软件行业，互联网行业还有另一个优势：可以通过服务的差异化，来进行更优的价格歧视。这种价格歧视一般是在免费策略的基础上（因为网络总价值是用户数的平方）获取基本用户，然后给支付意愿高的用户提供一定的增值服务来实现的，增值服务一般是用于节约用户时间、满足支付意愿高的用户的差异心理或是让支付意愿高的用户表达认可与支持。\n\n这种互联网行业的价格歧视非常常见，如今已经成为了互联网企业收入的一大来源，常见例子如：\n\n1. 腾讯的会员体系，QQ秀等产品，用户通过会员与装扮表现自己与他人的差异心理，获得精神上的满足感，而腾讯收获了一定的收入；\n2. 网络游戏与手游往往采用道具、皮肤与抽卡等方式盈利，而不是像单机游戏行业一般采取买断制。道具节约了支付意愿高的玩家的时间，皮肤满足了玩家的差异心理和表达了玩家对相应人物的认可，抽卡更是加入了一定的赌博因素，可以让用户支付意愿变得更高；\n3. 打赏机制，在文化创作领域与直播行业极度发达，用户通过打赏满足自己的差异心理和对创作者的认可与支持。\n\n这种商业模式的本质就是在免费策略的基础下，通过网络效应和用户差异创造出一种新的垄断竞争市场商品：增值服务。增值服务成本—供需曲线也像软件行业一般，虽然成本几乎为零，但是也会根据供需曲线来确定最大化收益对应的价格。而且增值服务可以经过更丰富的划分，可以相对软件行业实现更成功的价格歧视。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/20220216085238.png)\n\n初看增值服务会很令人吃惊：为什么会有人愿意支付一大笔钱，来获取生产成本为零的名为增值服务的虚拟物品，而且这类虚拟物品往往看起来没有任何的价值。生产成本为零，这也是软件的特征，既然软件能够以一定的价格出售，那么增值服务当然也能以同样的理由以一定价格出售，这是因为软件和增值服务都是垄断竞争产品；增值服务看起没有任何价值的原因是，增值服务大部分时候只是提供消费者精神上的愉悦，而软件常常是生产力工具，可以让消费者获取更高的收入，增值服务就像是你家附近的游乐园，而软件则是你生产面包的面包机，所以人们往往会低估增值服务的价值。\n\n增值服务市场营业额正逐渐接近广告市场营业额，2019 年中国广告营业额为 8674.28 亿元，而2019年中国游戏市场营业额也已达到 3102.3 亿元，可以说，增值服务已经和广告行业一样，是互联网行业的重要收入来源之一。\n\n\n## 五、结语\n\n软件行业和互联网行业作为新兴行业，是创新和推动经济发展的先锋力量。但是软件和互联网市场又与常规市场不同，软件和互联网行业不仅是不完全竞争市场，而且边际成本为零。软件行业的定价如同垄断竞争市场，又通过独特的方式进行价格歧视，以获取更大收益。互联网行业又与软件行业不同，受到网络效应影响：“网络的价值为用户数的平方”，互联网行业通常采用免费策略，然后通过获取的流量变现盈利。流量变现的方式通常是广告，互联网天生就适合广告，广告可以让面向普通消费者的垄断竞争企业获取更大利润，让面向普通消费者的垄断竞争行业双方利益最大化。除了广告之外，互联网企业还有很多其他的流量变现方式，其中非常重要的一个是增值服务。增值服务与软件产品的销售方式非常类似，均是成本为零的垄断竞争产品，常见的类型有会员体系，网络游戏虚拟物品和打赏机制。增值服务和软件的区别，就像是游乐场与生产工具的区别。\n\n软件和互联网行业仍然在不断地发展，也诞生了许多独特的经济模式，让我们得以从一种新的角度看待经济市场。软件和互联网将传统的经济重组，虽然传统经济受到了冲击，但是软件和互联网这样的新兴经济却给社会带来了更大的经济利益，远远超过传统经济的损失。对这样的新兴产业进行经济学方面的研究是重要且迫切的。\n\n## 参考文献：\n\n1. 《经济发展理论》  ——  约瑟夫·阿洛伊斯·熊彼特\n2. 《经济学原理：微观经济学分册》第七版  ——  曼昆\n3. 《软件随想录》  ——  Joel Spolsky\n4. [雅虎 — 维基百科](https://zh.wikipedia.org/wiki/%E9%9B%85%E8%99%8E)  ——  https://zh.wikipedia.org/wiki/%E9%9B%85%E8%99%8E\n5. [2020年中国广告行业市场现状及发展趋势分析](https://bg.qianzhan.com/trends/detail/506/200528-75d04ec8.html)  ——  https://bg.qianzhan.com/trends/detail/506/200528-75d04ec8.html\n6. [2019中国游戏产业年度报告](https://www.zhitongcaijing.com/content/detail/260749.html)  ——  https://www.zhitongcaijing.com/content/detail/260749.html","tags":["Study","Economics","Software","Internet"],"categories":["Study"]},{"title":"经济学笔记","url":"/post/notes-of-economics/","content":"\n\n# 经济学笔记\n\n# 经济学十大原理\n\n## 人们如何做出决策\n\n1.  权衡取舍: 人们总是面临很多选择.\n2.  机会成本: 某样东西的成本是得到它所放弃的东西, 包括时间和金钱.\n3.  边际数量: 理性人考虑边际量, 包括边际成本和边际收益.\n4.  激励反应: 人们会对激励做出反应.\n\n## 人们如何相互影响\n\n5.  贸易共赢: 贸易可以使每个人状况都变得更好.\n6.  市场竞争: 市场在通常是组织经济活动的一种好方法.\n7.  政府调节: 政府有时候可以改善市场结果.\n\n## 整体经济如何运行\n\n8.  国家水平: 一个国家的生活水平取决于它生产物品与服务的能力.\n9.  货币膨胀: 政府发行了过多的货币时, 会导致通货膨胀.\n10. 失业矛盾: 社会面临通货膨胀与失业之间的短期权衡取舍.\n\n\n<!-- more -->\n\n# 因果关系之间的矛盾\n\n## 打火机致癌 --- 被忽略的变量\n\n大兄弟公司被政府委托去调查人们致癌的原因. 经过一番艰苦卓绝的室内详细调查, 大兄弟公司发现, 人们家里打火机的数量越多, 致癌的可能性就越高. \n\n得出了结论的大兄弟公司, 兴高采烈地找到政府, 希望政府对打火机增收高额的打火机税, 并在每一个打火机上面都印上一句话: \"打火机有害身体健康\". \n\n实际上, 政府委托大兄弟公司的调查带来的唯一\"好处\"就是, 大兄弟公司旗下的火柴公司的销售额迎来大额的增长, 虽然致癌的人数也并没有降下来.\n\n先不论大兄弟公司的做法是否是有意的. 他们犯了一个很明显的错误, 没有调查到吸烟与致癌的因果关系. 在一个因果网中, 打火机销售增加 ← 吸烟 → 致癌, 大兄弟公司只看见了因果链一部分, 没有考虑到还有其他的因素, 即吸烟因素被忽略了, 自然也不能得出正确的结论.\n\n## 警察带来犯罪 --- 反向因果关系\n\n无政府主义者经过调查发现, 一个城市的警察越多, 犯罪率也就越高. 于是他们得出结论: 警察的增加激发了人们的犯罪欲望, 应该大幅度减少警察的数量, 这样才能降低城市的犯罪率.\n\n我们可以轻易地找出这个结论的荒谬之处: 很有可能是因为犯罪率高, 所以政府才委派了更多的警察坐镇这个城市.\n\n**因此, 统计学上的相关关系并不代表着它们就有直接的因果关系, 就算有, 也很难判断哪个是因, 哪个是果.**\n\n\n# 贸易带来共赢\n\n有那么一个说法, 贸易就是互通有无, 简单来说就是出售对方没有, 或者是难以生产的东西.\n\n但是, 如果是一方拥有绝对优势, 在生产任何产品都有更高的生产率下, 贸易还能带来共赢吗?\n\n答案是能的. \n\n## 不进行贸易的小明小李\n\n假设小明能够在1小时生产6斤水稻, 或者1小时生产3斤牛肉. 小李能够在1小时生产4斤水稻, 或者1小时生产1斤牛肉. 很显然, 小明无论是生产牛肉还是生产水稻, 都要胜过小李.\n\n假设小明每天花4小时生产牛肉, 4小时生产土豆, 那么小明将会获得24斤水稻和12斤牛肉. 小李每天花4小时生产牛肉, 4小时生产土豆, 那么小李将会获得16斤水稻和4斤牛肉.\n\n列表如下:\n\n| 名字 | 水稻产率 | 牛肉产率 | 水稻用时 | 牛肉用时 | 水稻产量 | 牛肉产量 |\n| ---- | -------- | -------- | -------- | -------- | -------- | -------- |\n| 小明 | 6        | 3        | 4        | 4        | 24       | 12       |\n| 小李 | 4        | 1        | 4        | 4        | 16       | 4        |\n\n过了一段时间, 小明决定去跟小李进行贸易.\n\n## 小明与小李的谈话\n\n小明: 小李, 我有件事想跟你商量.\n\n小李: 嗯? 这有什么商量不商量的, 咱俩谁跟谁啊, 有事你就直接说吧!\n\n小明: 我有一个好想法, 可以让我们两个都生产出更多的粮食. 如果你每天都种8个小时的水稻, 你就每天就可以收获32斤的水稻, 你把其中15斤水稻给我, 我给你5斤牛肉, 这样你就能有17斤的水稻和5斤的牛肉, 这不比你之前16斤的水稻和4斤的牛肉好?\n\n小李: 听起来好像蛮不错的呀. 但是这只是让我赚了, 对你又有什么好处呢? 你看起来不像是一个做亏本生意的人啊.\n\n小明: 哎, 我这办法对我来说也是有好处的啊. 如果我每天用6小时养牛, 2小时种水稻, 我就有18斤的牛肉和12斤的水稻. 我用5斤牛肉换回来你的15斤水稻, 那我就还有13斤牛肉和27斤水稻, 也比我之前12斤牛肉和24斤水稻好啊. 这是双赢的事.\n\n小李: 啊这, 听起来真是一个两全其美的办法. 但是很奇怪啊, 为什么我们两个人都赚了呢? 真是一件难以置信的事.\n\n小明: 对你自己来说, 相对于养牛, 你更擅长种水稻, 而我则相反. 虽然我似乎在两个方面都比你强些许, 但是我们应该比较的是比较优势, 而不是绝对优势. 我们都做自己更擅长做的事, 我们就都能过得更好.\n\n列表如下:\n\n| 名字 | 水稻用时 | 牛肉用时 | 水稻交易 | 牛肉交易 | 水稻产量 | 牛肉产量 |\n| ---- | -------- | -------- | -------- | -------- | -------- | -------- |\n| 小明 | 2        | 6        | +15      | -5       | 27       | 14       |\n| 小李 | 8        | 0        | -15      | +5       | 17       | 5        |\n\n## 绝对优势和比较优势\n\n### 绝对优势\n\n**绝对优势**是生产者在生产一种物品上投入的成本相对他人来说更少, 就能称为绝对优势.\n\n小明在养牛和种水稻这两件事上都要比小李做的好, 说明小明在养牛和种水稻上都有着绝对优势. 但是是否因为小明有着各方面的绝对优势, 小明就没必要和小李进行贸易呢? 由上文我们可以看出, 在这种情况下进行贸易, 双方也还是会获益.\n\n我们可知: **贸易带来能否带来好处与绝对优势无关.**\n\n### 机会成本与相对优势\n\n如果我们考虑机会成本, 即我们为了得到一件物品而放弃的东西, 而不是所花费的单位时间, 我们就能算出相对优势.\n\n例如, 将上文小明和小李的产率转化为机会成本, 小明1小时生产了3斤牛肉, 那么就少生产了6斤水稻, 即1斤牛肉的机会成本是2斤水稻. 以这种方式列表:\n\n| 名字 | 1斤牛肉的机会成本 | 1斤水稻的机会成本 |\n| ---- | ----------------- | ----------------- |\n| 小明 | 2斤水稻           | 1/2斤牛肉         |\n| 小李 | 4斤水稻           | 1/4斤牛肉         |\n\n我们可以看出, 小明生产牛肉的机会成本是2斤水稻, 比小李的4斤水稻少, 说明小明更擅长养牛. 那么小明会不会在生产水稻方面也相对优势于小李呢? 并不会, 因为小明生产牛肉的机会成本和生产水稻的机会成本互为倒数, 所以在生产水稻方面, 小李必然相对优势于小明.\n\n### 相对优势带来的价格\n\n所以在小明和小李之间, 怎么定下牛肉和水稻交换的比例才能有益于双方呢? 我们可以看出, 只要价格在小明和小李的机会成本之间, 这次交易就是有利可图的.\n\n如上文小明与小李交易, 水稻比牛肉的比例是3, 3介于小明和小李生产1斤牛肉的机会成本2和4之间, 那么这就是一个合适的价格.\n\n我们可知:**价格介于双方的机会成本之间.**\n","tags":["Study","Economics"],"categories":["Study"]},{"title":"我用 Hexo 和 Cloudflare 重构了整个博客","url":"/post/refactor-my-blog/","content":"\n\n# 起因\n\n之前, 我的博客的技术栈是这样的: \n\n* 博客系统: [Jekyll](http://jekyllcn.com/)\n* 博客主题: [BY Blog](https://github.com/qiubaiying/qiubaiying.github.io)\n* 部署方式: [阿里云ECS](https://www.aliyun.com/)\n\n但是我受够 Jekyll 的种种不便之处了, 主要原因还是自己不懂 Ruby, 又不想多学一种语言, 而且最近我白嫖的阿里云服务器也快过期了. \n\n种种因素加起来, 导致我决定转向以 NodeJS 为开发语言的 Hexo. 事实证明,对我来说 Hexo 比 Jekyll 快乐多了, 那是一种本来在沙漠中数天没喝水, 突然发现了一片绿洲, 整个人精神焕发的奇妙感觉.\n\n于是, 我决定将技术栈转变为, 并将整个博客重构:\n\n* 博客系统: [Hexo](https://hexo.io/zh-cn/)\n* 博客主题: [Stun](https://theme-stun.github.io/docs/zh-CN/)\n* 部署方式: [Cloudflare](https://www.cloudflare.com/)\n\n本文参考了两篇博文:\n\n[Mexii](https://blog.mexii.one/2020/12/blog-on-cloud/) 和 [Sukka](https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/)\n\n我会较为详细地描述我构建博客的整个过程, 希望对你有所帮助 :-)\n\n<!-- more -->\n\n<!-- # Github\n\n想要查看博客源码?\n\n看这里:\n\n[Github Repo](https://github.com/OrangeX4/OrangeX4-Blog) -->\n\n# 本地搭建\n\n## Hexo 的基础使用\n\n### 安装\n\n首先你需要安装 NodeJS, 可以在网上找到相关的下载地址, 这里就不在赘述.\n\n然后你就可以在命令行执行下面的命令安装 Hexo.\n\n```sh\nnpm install -g hexo-cli\n```\n\n安装完成之后, 可以执行\n\n```sh\nhexo --version\n```\n\n来检查是否安装成功.\n\n### 创建项目\n\n安装好 Hexo 之后, 就要创建你的博客项目了.\n\n这里的 `blog` 是你的项目的目录名称, 可以改成任何你需要的名称.\n\n```sh\nhexo init blog\ncd blog\nnpm install\nhexo serve\n```\n\n不出所料的话, 你的浏览器会打开一个页面, 表明着你的博客诞生了:\n\n**『 Hello, World! 』**\n\n### 加入 Git 版本控制\n\n在这里, 我默认你已经知道 Git 的基本用法.\n\n若你还没用过 Git, 可以在 [腾讯软件中心](https://pc.qq.com/detail/13/detail_22693.html) 下载安装 Git. 想了解更多 Git 有关的内容, 可以看看 [廖雪峰的 Git 教程](https://www.liaoxuefeng.com/wiki/896043488029600).\n\n在博客根目录下执行:\n\n```sh\ngit init\ngit add *\ngit commit -m\"Init\"\n```\n\n并在 Github 上 [新建一个 Repo](https://github.com/new) 用于存储你的代码.\n\n### 详细用法\n\n请参照 [Hexo 官网](https://hexo.io/zh-cn/docs/)\n\n其中我认为比较重要的是:\n\n* 如何发布新博文\n  * `hexo new draft <title>`\n  * `hexo publish <title>`\n* 如何添加查看全文\n  * `<!-- more -->`\n* 本地热更新 Server (开发用)\n  * `hexo s`\n  * `hexo s --draft`\n* 生成静态文件\n  * `hexo g`\n  * 部署前请务必执行一次该命令\n* ...\n\n## Hexo 主题的选择\n\nHexo 知道默认主题不可能让挑剔的你满意, 所以在开源社区的帮助下, 向你提供了超过三百个不同的[主题](https://hexo.io/themes/)和[插件](https://hexo.io/plugins/).\n\n在这里, 我选择了一个界面相对美观且功能齐全的主题: **[Stun](https://github.com/liuyib/hexo-theme-stun)**.\n\n你也可以直接查阅它的[官方文档](https://theme-stun.github.io/docs/zh-CN/).\n\nStun 内置了许多功能, 你可以自由选择是否开启.\n\n我开启了 Stun 中的这些功能:\n\n* 国际化 (i18n)\n* 夜晚模式\n* 二级导航菜单\n* 文章目录\n* 文章阅读进度条\n* 文章置顶\n* 代码高亮\n* 标签云\n* 评论系统 (Gitalk)\n* 搜索系统\n* 数学公式支持 (KaTex)\n* Nest 特效\n\n### 安装主题的一个坑\n\n因为主题本身也是一个 Repo, 有着自己的 `.git`, 导致引发了 submodule 问题. 大概就是 git 提交不成功, 主题文件会被识别为 submodule.\n\n按照 [Mexii](https://blog.mexii.one/2020/12/blog-on-cloud/) 的说法, 似乎可以自己新建一个`.gitmodules`文件,填入:\n\n```\n[submodule \"hexo-theme-light\"]\n\tpath = themes/light\n\turl = https://github.com/tommy351/hexo-theme-light\n```\n\n我暂时没什么好的解决办法, 干脆把 `themes/stun` 目录下的 `.git` 目录给删除了. 虽然这会对后续的更新造成极大的困难, 但是好歹解决了一定的问题.\n\n## 部署到 Cloudflare\n\n### 安装 Wrangler CLI\n\n这里本来应该用 NPM 或者 Yarn 安装, 就像这样:\n\n```sh\nnpm i @cloudflare/wrangler -g\n# yarn global add @cloudflare/wrangler\n```\n\n但是不知道为什么我总是安装失败, 各种报错看得我头疼, 最终放弃这种方式.\n(也不知道是不是网络问题)\n\n我们可以直接去 [Github Release](https://github.com/cloudflare/wrangler/releases) 下载.\n\n如果你是 Windows 系统, 只需要选择 `pc-windows` 对应的包就好. 下载好了以后解压到 PATH 环境变量下, 即可在命令行通过 `wrangler` 命令调用.\n\n可以使用以下命令查看是否安装成功:\n\n```sh\nwrangler --version\n```\n\n### 开启 Workers\n\nWorkers 是 Cloudflare 开发的用于构建无服务器应用程序的服务, 其会部署到 Cloudflare 在全球数以百计, 而且支持续集成 CI, 可以说很适合 Hexo 这种静态博客网站的部署.\n\n前往 [Cloudflare Workers](https://dash.cloudflare.com/workers), 可以选择免费计划并开启一个 Worker, 免费计划可以支持一天最多10万次请求, 对小型博客来说完全足够, 如果请求量大, 可以选择升级套餐, 获得更好的支持.\n\n例如说我开启了一个名叫 `blog` 的 Worker, 那么在上传了网站内容之后, 我就能获得一个叫 `blog.orangex4.workers.dev` 的子域名, 这个子域名就是可以访问的 Workers 了.\n\n### 绑定域名\n\n如果你在其他服务商如阿里云那里买了一个域名, 你只需要给域名添加一个 CNAME 记录, 让它映射到你开启的 Workers 子域名便好.\n\n你也可以让 Cloudflare 托管你的域名, 即在你的域名服务商那里把 DNS 服务器更改为 Cloudflare 的服务器, 然后在 Cloudflare 那里也修改你域名的 CNAME 记录, 让它映射到你的 Workers.\n\n详细请见 [Cloudflare Add Site](https://dash.cloudflare.com/add-site)\n\n**接下来的内容绝大部分参考  [Sukka](https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/) 的博文.**\n\n### 创建 API Token\n\n使用 Wrangler CLI 前需要申请一个 [API Token](https://dash.cloudflare.com/profile/api-tokens). \n\nCloudflare 提供了包括「Edit Cloudflare Workers」在内的一系列 Token 模板, 直接选择 Workers 即可. 不过需要注意的是, 在下一步设置 Token 权限时将下图两个权限去掉, 因为部署 Cloudflare Workers Site 不需要用到这两个权限.\n\n![cfworkers-token-perm](https://cdn.jsdelivr.net/npm/sks@0.1.0/cfworkers-token-perm.png)\n\n其他配置同理, 按照默认即可.\n\n### 初始化项目\n\n在 Hexo 站点目录下执行命令:\n\n```sh\nwrangler init --site my-static-site\n# 其中 my-static-site 是 Worker 名称, 如我的就是 blog\n```\n\nWrangler CLI 会使用 Cloudflare Workers Site 的模板在项目里新生成一个 workers-site 目录和一个 wrangler.toml 文件. \n\n接着手动配置 `wrangler.toml`:\n\n```toml\naccount_id = \"\"                 # Cloudflare Account ID，去 Cloudflare 的控制面板找找\nworkers_dev = true              # 是否启用 workers.dev 子域名\nroute = \"blog.orangex4.cool/*\"  # Workers 所载的 Route\nzone_id = \"\"                    # 域名在 Cloudflare 的 Zone ID\n\n[site]\nbucket = \"./public\"             # 生成的 dist 路径，对于 Hexo 来说就是 public\nentry-point = \"workers-site\"    # Cloudflare Workers 相关代码存放处，默认就是 workers-site 目录\n```\n\n配置完了之后在命令行执行命令:\n\n```sh\nwrangler config\n```\n\n它会让你输入 API Token, 将上一步获取到的 Token 粘贴上去, 回车即可.\n\n若没有报错, 说明初始化成功了.\n\n### 预览和发布\n\n运行下述命令即可对 Cloudflare Workers Site 进行预览：\n\n```sh\nwrangler preview --watch\n# 将 bucket 中的文件上传到 Workers KV 中，浏览器会自动打开一个窗口进行预览\n```\n\n运行下述命令即可将网站发布到 Cloudflare Workers Site：\n\n```sh\nwrangler publish\n# 将 Workers Site 发布到生产环境\n```\n\n## 使用 GitHub Action 持续集成\n\n### 编写 Github Action 配置文件\n\n在目录下新建目录 `.github/workflows`, 并在该目录下新建任意名称的 YAML 文件(如 `deploy.yml`), 该文件将作为 GitHub Actions 的配置文件.\n\n```yaml\nname: Deploy\non:\n  push:\n    branches:\n      - main  # 这里填写你的主分支, 比如 Sukka 的是 master, 而我的是 main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version:\n          - 12.x\n    steps:\n    - name: Checkout  # 这里 Sukka 的博文上缩进错了, 导致不能运行成功, 我修改了这里的缩进\n      uses: actions/checkout@v2\n      with:\n        # 令 GitHub 在 git clone 和 git checkout 后「忘记」使用的 credentials。\n        # 如果之后需要以另外的身份（如你的 GitHub Bot）执行 git push 操作时（如部署到 GitHub Pages），必须设置为 false。\n        persist-credentials: false\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    # 缓存 node_modules，缓存机制参见 GitHub 文档：https://help.github.com/en/actions/configuring-and-managing-workflows/caching-dependencies-to-speed-up-workflows\n    - name: Cache node_modules\n      uses: actions/cache@v1 # 使用 GitHub 官方的缓存 Action。\n      env:\n        cache-name: hexo-node-modules\n      with:\n        path: node_modules\n        key: ${{ runner.os }}-${{ env.cache-name }}-${{ hashFiles('package-lock.json') }} # 使用 package-lock.json 的 Hash 作为缓存的 key。也可以使用 package.json 代替\n    # Wrangler 在构建时会在 workers-site 目录下执行 npm i，因此也要缓存这里的 node_modules\n    - name: Cache workers-site/node_modules\n      uses: actions/cache@v1\n      env:\n        cache-name: workers-site-node-modules\n      with:\n        path: workers-site/node_modules\n        key: ${{ runner.os }}-${{ env.cache-name }}-${{ hashFiles('workers-site/package-lock.json') }}\n    - run: npm i # 执行 Hexo 的依赖安装\n    # 完成 npm i 后，hexo 已经被链接到 node_modules 下的 bin 目录、并被注册在 Node.js 的 $PATH 中\n    # Hexo 博客的 package.json 中默认注册了这些 script：clean/build/deploy/server\n    # 因此，在目录下执行 npm run build 等同于执行 hexo g，但是不需要全局安装 hexo-cli\n    - run: npm run build\n```\n\n先将配置文件推到 GitHub 上, 如果 GitHub Action 自动触发开始构建, 且没有错误发生, 再添加部署到 Cloudflare Workers Site 的相关配置.\n\n### 通过 GitHub Action 将构建结果发布至 Cloudflare Workers Site\n\nCloudflare 推出了 [Wrangler CLI 的 GitHub Action](https://github.com/cloudflare/wrangler-action), 通过引入 wrangler-action 可以直接执行 wrangler publish. 先在 GitHub 仓库的设置页面添加 Secrets 环境变量, 名字叫做 `CF_WORKERS_TOKEN`, 内容为之前生成的 Cloudflare 的 API Token. 当然, 你也可以生成一个新的 Token.\n\n然后, 在之前的 GitHub Action 配置文件的结尾补充以下内容:\n\n```yaml\n    - name: Deploy to Cloudflare Workers\n      uses: cloudflare/wrangler-action@1.1.0\n      with:\n        apiToken: ${{ secrets.CF_WORKERS_TOKEN }}\n        # 前一步设置的 Secrets 的名称\n        # 注意代码的缩进\n```\n\n然后用 `git push` 进行推送. 如果 Github Action 执行成功了的话, 你的博客应该会自动更新.\n\n从此, 你只需要 `git push` 就能完成整个博客的更新, 简单快乐!\n\n## 添加搜索引擎优化 (SEO)\n\n参照这个文档 [hexo-submit-urls-to-search-engine 中文文档](https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine.html).\n\n我给我的博客加入了搜索引擎优化, 也正是因为这个原因, 我才把 Github 上的 Repo 改成了 Private.\n\n按照该文档进行配置, 我加入了百度, 必应和谷歌的 SEO.\n\n想要和 Github Action 使用, 得加上 `hexo d` 命令, 即在 `- run: npm run build` 下一行加一句 `- run: npm run deploy`.\n\n# 参考文献\n\n* [Hexo 文档](https://hexo.io/zh-cn/docs/)\n* [Stun 文档](https://theme-stun.github.io/docs/zh-CN/)\n* [用GitHub Action部署一个Workers站点](https://blog.mexii.one/2020/12/blog-on-cloud/)\n* [将 Hexo 部署到 Cloudflare Workers Site 上的趟坑记录](https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/)\n* [Github Action Docs](https://docs.github.com/cn/free-pro-team@latest/actions)\n* [Cloudflare Workers Docs](https://developers.cloudflare.com/workers/)\n* [hexo-submit-urls-to-search-engine 中文文档](https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine.html)","tags":["Blog","Hexo","Cloudflare","NodeJS","Github"],"categories":["Technology"]},{"title":"高等代数相关笔记","url":"/post/advanced-algebra/","content":"\n# 向量与行列式的几何意义\n\n### 向量几何意义\n\n令向量 $\\alpha=\\begin{pmatrix}a_1\\\\a_2\\\\\\vdots\\\\a_n\\end{pmatrix}$\n\n**则向量 $\\alpha$ 是从原点 $(0,0,\\cdots ,0)$ 指向另一点 $(a_1,a_2,\\cdots,a_n)$ 的有向线段**\n\n### 行列式几何意义\n\n对于二阶行列式 $\\begin{vmatrix}a_{11}&a_{21}\\\\a_{12}&a_{22}\\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}$\n\n向量 $\\alpha_1=\\begin{pmatrix}a_{11}\\\\a_{12}\\end{pmatrix}$ 和 $\\alpha_2=\\begin{pmatrix}a_{21}\\\\a_{22}\\end{pmatrix}$ 所形成的一个平行四边形面积\n\n$S=2\\times\\frac{1}{2}|\\alpha_1||\\alpha_2|\\sin\\langle \\alpha_1,\\alpha_2\\rangle=|\\alpha_1||\\alpha_2|\\sqrt{1-(\\frac{\\alpha_1\\cdot\\alpha_2}{|\\alpha_1||\\alpha_2|})^2}$\n\n$\\quad=\\sqrt{(|\\alpha_1||\\alpha_2|)^2-(\\alpha_1\\cdot\\alpha_2)^2}$\n\n$\\quad=\\sqrt{(a_{11}^2+a_{12}^2)(a_{21}^2+a_{22}^2)-(a_{11}a_{21}+a_{12}a_{22})^2}$\n\n$\\quad=\\sqrt{a_{12}^2a_{21}^2+a_{11}^2a_{22}^2-2a_{11}a_{21}a_{12}a_{22}}$\n\n$\\quad=|a_{11}a_{22}-a_{12}a_{21}|$\n\n我们可知,\n\n**二阶行列式是两个二维向量所围成的平行四边形的面积**\n\n依次类推, 我们同样有\n\n**三阶行列式是三个三维向量所围成的平行六面体的体积**\n\n**n阶行列式是n个n维向量所围成的平行超多面体的超体积**\n\n<!-- more -->\n\n### 线性相关性\n\n我们可以在多维空间中形象地想象,\n\n行列式等于零 $\\Leftrightarrow$ 超多面体体积为 $0\\Leftrightarrow$ 超多面体坍缩 $\\Leftrightarrow$ 向量线性相关\n\n**对于二阶行列式, $\\alpha_1$ 与 $\\alpha_2$ 线性相关, 说明 $\\alpha_1\\parallel\\alpha_2$, 即行列式 $|A|=0$**\n\n**对于三阶行列式,**\n\n**$\\alpha_1,\\alpha_2,\\alpha_3$ 线性相关, 说明 $\\alpha_3\\parallel \\alpha_1$ 与 $\\alpha_2$ 形成的平面, 即行列式 $|A|=0$**\n\n# 齐次线性方程组方阵与线性相关性\n\n\n对于齐次线性方程组(*)\n\n$\\begin{cases}\na_{11}x_1+a_{12}x_2+\\cdots +a_{1n}x_n=0 \\\\\na_{21}x_1+a_{22}x_2+\\cdots +a_{2n}x_n=0 \\\\\n\\cdots \\\\\na_{n1}x_1+a_{n2}x_2+\\cdots +a_{nn}x_n=0 \\\\\n\\end{cases}$\n\n\n方程组(*)必定有零解, 即 $\\vec{x}=\\begin{pmatrix}0\\\\0\\\\\\vdots\\\\0\\end{pmatrix},$ 那么有没有非零解呢?\n\n令 $\\alpha_i=\\begin{pmatrix}a_{i1}\\\\a_{i2}\\\\\\vdots \\\\a_{in}\\end{pmatrix}$, 则 $|A|=|A^T|=\\begin{vmatrix}a_{11}&a_{12}&\\cdots &a_{1n}\\\\a_{21}&a_{22}&\\cdots &a_{2n}\\\\\\vdots &\\vdots & &\\vdots \\\\a_{n1}&a_{n2}&\\cdots &a_{nn}\\end{vmatrix}$\n\n由 Cramer 法则可知,\n\n**方程组(*)仅有零解 $\\Leftrightarrow |A|\\neq 0\\Leftrightarrow \\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 线性无关**\n\n**方程组(*)有非零解 $\\Leftrightarrow |A|= 0\\Leftrightarrow \\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 线性相关**\n\n要注意到:\n\n* 此时向量维度与向量个数相等\n* 方程组参数或者说行列式是否转置与方程组是否仅有零解无关\n\n### Cramer法则\n\n$\\begin{cases}\na_{11}x_1+a_{21}x_2+\\cdots +a_{n1}x_n=b_1 \\\\\na_{12}x_1+a_{22}x_2+\\cdots +a_{n2}x_n=b_2 \\\\\n\\cdots \\\\\na_{1n}x_1+a_{2n}x_2+\\cdots +a_{nn}x_n=b_n \\\\\n\\end{cases}$\n\n\n令 $\\alpha_i=\\begin{pmatrix}a_{i1}\\\\a_{i2}\\\\\\vdots \\\\a_{in}\\end{pmatrix},\\beta=\\begin{pmatrix}b_{1}\\\\b_{2}\\\\\\vdots \\\\b_{n}\\end{pmatrix}, D=|\\alpha_1\\quad\\alpha_2\\quad\\cdots \\quad\\alpha_n|$\n\n将 $D$ 中的 $\\alpha_i$ 替换成 $\\beta$, 就得到 $D_i$\n\nCramer 法则: $x_i=\\displaystyle\\frac{D_i}{D}$\n\n证明:\n\n将 $x_i=\\displaystyle\\frac{D_i}{D}$ 带入方程组里,\n并将 $D_i$ 按 $i$ 列展开, 整理, 使用不同行展开为 $0$ 便可证\n\n### 线性相关性\n\n线性相关 $\\Leftrightarrow$ 存在不全为 $0$ 的 $k_i$ 使得 $k_1\\alpha_1+k_2\\alpha_2+\\cdots +k_n\\alpha_n=0$\n\n线性无关 $\\Leftrightarrow k_1\\alpha_1+k_2\\alpha_2+\\cdots +k_n\\alpha_n=0$ 只有零解\n\n\n# 非方阵形式的齐次方程组\n\n\n$\\begin{cases}\na_{11}x_1+a_{21}x_2+\\cdots +a_{n1}x_n=0 \\\\\na_{12}x_1+a_{22}x_2+\\cdots +a_{n2}x_n=0 \\\\\n\\cdots \\\\\na_{1s}x_1+a_{2s}x_2+\\cdots +a_{ns}x_n=0 \\\\\n\\end{cases}$\n\n\n齐次方程组(*)必定有零解, 即 $\\vec{x}=\\begin{pmatrix}0\\\\0\\\\\\vdots\\\\0\\end{pmatrix}_n$\n\n令 $\\alpha_i=\\begin{pmatrix}a_{i1}\\\\a_{i2}\\\\\\vdots \\\\a_{is}\\end{pmatrix}$, 则 $A=\\begin{bmatrix}a_{11}&a_{21}&\\cdots &a_{n1}\\\\a_{12}&a_{22}&\\cdots &a_{n2}\\\\\\vdots &\\vdots & &\\vdots \\\\a_{1s}&a_{2s}&\\cdots &a_{ns}\\end{bmatrix}_{n\\times s}$\n\n**当s<n时, 即向量维度小于向量个数, 矩阵的宽度小于长度**\n\n由解方程组的理论可知, 此时一定会有自由变量 $x_{s+1},\\cdots ,x_n$\n\n或者说给向量增加 $n-s$ 个维度, 就形成了一个 $n\\times n$ 的行列式 $|A|$,\n每个维度上的数为 $0$, 则易知行列式 $|A|=0$\n\n理论依据: 添加一些系数全为零的方程相当于加入 $0=0$, 是恒成立的\n\n**方程组(*)一定有非零解, 说明向量一定线性相关**\n\n**当 $s>n$ 时, 即向量维度大于向量个数, 矩阵的宽度大于长度**\n\n有三种选择,\n\n**一是减少维度, 最为常用**\n运用解方程理论必定可以让所有向量 $s-n$ 个维度变为 $0$\n进而降维到 $n\\times n$, 采用方阵相关理论即可解\n\n**二是增加线性无关向量,**\n增加 $s-n$ 个与前面向量线性无关的向量, 解 $x_i$的个数不会变\n进而升维到 $s\\times s$, 采用方阵相关理论即可解\n\n**这两种方式均不会改变 $|A|$ 的零性, 也就不会影响前 $n$ 个向量的线性相关性**\n\n**三是使用子式**\n一矩阵的秩是 $r⇔$ 矩阵中有一个 $r$ 级子式不为零,同时所有的 $r+1$ 级子式 (如果有的话) 全为零\n\n\n\n# 求和运算法则\n\n* **$\\displaystyle\\sum_{i=1}^nx_i=x_1+x_2+\\cdots +x_n$**\n* **$\\displaystyle\\sum_{i=1}^nkx_i=k\\sum_{i=1}^nx_i$**\n* **$\\displaystyle\\sum_{i=1}^n(x_i+y_i)=\\sum_{i=1}^nx_i+\\sum_{i=1}^ny_i$**\n* **$\\displaystyle\\sum_{i=1}^nx_i\\sum_{j=1}^my_j=\\sum_{j=1}^my_j\\sum_{i=1}^nx_i=\\sum_{i=1}^n\\sum_{j=1}^mx_iy_j=\\sum_{j=1}^m\\sum_{i=1}^nx_iy_j$**\n* **$\\displaystyle\\sum_{i=1}^nx_i\\sum_{j=1}^my_jz_{ij}=\\sum_{j=1}^my_j\\sum_{i=1}^nx_iz_{ij}=\\sum_{i=1}^n\\sum_{j=1}^mx_iy_jz_{ij}=\\sum_{j=1}^m\\sum_{i=1}^nx_iy_jz_{ij}$**\n\n常见的向量求和运算:\n\n定义符号 $\\displaystyle\\bigcap_{i=1}^nf_i(\\vec{x})=b_i$ 为方程组 $\\begin{cases}\nf_1(\\vec{x})=b_1 \\\\\nf_2(\\vec{x})=b_2 \\\\\n\\cdots \\\\\nf_n(\\vec{x})=b_n \\\\\n\\end{cases}, 设\\alpha_i=\\begin{pmatrix}a_{i1}\\\\a_{i2}\\\\\\vdots \\\\a_{im}\\end{pmatrix}$\n\n**线性相关性: $\\displaystyle\\bigcap_{p=1}^m\\sum_{i=1}^na_{ip}k_i=0\\rightarrow$ 是否 $\\forall k_i=0$**\n\n**若 $n=m$, 通过转置则有**\n**$\\displaystyle\\bigcap_{p=1}^n\\sum_{i=1}^na_{ip}k_i=0\\rightarrow 是否\\forall k_i=0$**\n\n**$\\Leftrightarrow$**\n\n**$\\displaystyle\\bigcap_{p=1}^n\\sum_{i=1}^na_{pi}k_i=0\\rightarrow 是否\\forall k_i=0$**\n\n\n# 分块矩阵和初等矩阵\n\n### 广义三角矩阵行列式\n\n$\\begin{vmatrix}A_1&\\cdots &\\cdots &\\cdots \\\\O&A_2&\\cdots &\\cdots \\\\\\vdots &\\vdots &\\ddots &\\vdots \\\\O&O&\\cdots &A_n\\end{vmatrix}=|A_1||A_2|\\cdots |A_n|$\n\n### 分块对角矩阵逆矩阵\n\n$\\begin{bmatrix}A_1&O &\\cdots  &O \\\\O&A_2&\\cdots &O \\\\\\vdots &\\vdots &\\ddots &\\vdots \\\\O&O&\\cdots &A_n\\end{bmatrix}^{-1}=\\begin{bmatrix}A_1^{-1}&O &\\cdots  &O \\\\O&A_2^{-1}&\\cdots &O \\\\\\vdots &\\vdots &\\ddots &\\vdots \\\\O&O&\\cdots &A_n^{-1}\\end{bmatrix}$\n\n### 初等矩阵\n\n对一个矩阵 $A$ 实施了初等行变换 $P$ 和初等列变换 $Q$ 即为矩阵乘法 $PAQ$\n\n其中 $P$ 和 $Q$ 均为对单位矩阵 $E$ 进行了初等行列变换的结果\n\n#### 初等行变换矩阵\n\n* 互换 $E$ 的 $i,j$ 两行, 记作 $P(i,j)$\n  * $|P(i,j)|=-1$\n  * $P(i,j)^{-1}=P(i,j)$\n*  $E$ 的第 $i$ 行乘以不等于零的数 $k$, 记作 $P(i(k))$\n  * $|P(i(k))|=k$\n  * $P(i(k))^{-1}=P(i(\\displaystyle\\frac{1}{k}))$\n*  $E$ 的第j行的k倍加到第i行上, 记作P(i,j)\n  * $|P(i,j(k))|=1$\n  * $P(i,j(k))^{-1}=P(i,j(-k))$\n\n$(A\\quad E)\\xrightarrow{\\text{初等行变换}}(E\\quad A^{-1})$\n\n$(A\\quad B)\\xrightarrow{\\text{初等行变换}}(E\\quad A^{-1}B)$\n\n#### 初等行变换矩阵\n\n* $P(i,j)=Q(i,j)$\n* $P(i(k))=Q(i(k))$\n* **$P(i,j(k))=Q(j,i(k))$**\n\n$\\begin{pmatrix}A\\\\E\\end{pmatrix}\\xrightarrow{初等列变换}\\begin{pmatrix}E\\\\A^{-1}\\end{pmatrix}$\n\n$\\begin{pmatrix}A\\\\B\\end{pmatrix}\\xrightarrow{初等列变换}\\begin{pmatrix}E\\\\BA^{-1}\\end{pmatrix}$\n\n### 分块矩阵运算\n\n若 $A$ 可逆\n\n$\\begin{bmatrix}E_m&O\\\\-CA^{-1}&E_n\\end{bmatrix}\\begin{bmatrix}A&B\\\\C&D\\end{bmatrix}=\\begin{bmatrix}A&B\\\\O&D-CA^{-1}B\\end{bmatrix}$\n","tags":["Study","Math","Advanced Algebra"],"categories":["Study"]},{"title":"Markdown和Latex也能变成方便好用的计算器--VS Code插件加入了用于计算的新功能","url":"/post/you-can-calculate-with-markdown-and-latex/","content":"\n# Markdown和Latex也能变成方便好用的计算器\n\n很多人都用过 VS Code 来写 Markdown 和 Latex，或许还会用它来记笔记、写作业和写论文。\n\n相信有人也碰到过这样的麻烦：用 Latex 输入了一个分式 \\frac{1}{2}，想要计算还得手动将它改成 1/2，再打开其他软件进行计算；又或是用 Latex 写了一个矩阵，想要计算它的行列式，还得打开 Matlab 重新输入一遍整个矩阵，得到结果还要重新改写成 Latex。\n\n有没有办法简化这一整个流程呢？当然是有的！\n\n我写的 VS Code 插件 Better Markdown & Latex Shortcuts 迎来了重大的升级，加入了计算器功能。以后用 VS Code 写 Markdown 或者 Latex 的时候，便可以随手进行一些四则运算或矩阵运算之类的运算了。\n\n<!-- more -->\n\n# Better Markdown & Latex Shortcuts 插件安装\n\n在这里，默认你已经安装了 VS Code 和相关的 Markdown 数学公式支持插件或是 Latex 编译环境。\n\n要使用这个插件，你只需要在vscode的插件市场搜索 “Better Markdown & Latex Shortcuts” 或 “Orangex4”，并安装名为 \"Better Markdown&Latex Shortcuts\" 的插件.\n\n![](https://p.pstatp.com/origin/fed1000264b9582ce562)\n\n### Github地址\n\n[Github](https://github.com/OrangeX4/Better-Markdown-Latex-Shortcuts)\n\n# 用法\n\n## 剪贴板图片自动上传图床\n\n使用快捷键 \"Shift + Ctrl + Alt + V\" 可以将剪贴板内的图片自动上传到头条图床, 并以 Markdown 形式粘贴在当前位置.\n\n代码参考 [vscode-paste-image](https://github.com/mushanshitiancai/vscode-paste-image) 和 [upimg](https://www.npmjs.com/package/upimg).\n\n![](https://p.pstatp.com/origin/137df0001b5db431ffb9f)\n\n## 行内复制与移动\n\n### 复制\n\n使用快捷键 \"Shift + Alt + ←\" 将选中内容在行内向左复制。\n\n使用快捷键 \"Shift + Alt + →\" 将选中内容在行内向右复制。\n\n![copy](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedUd043e489d79745469b7cca5bf59a45d63.jpg)\n\n\n### 多行复制\n\n![multicopy](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU8e2d3c2e81264cb4a52d9dd2bab65eb0z.jpg)\n\n### 移动\n\n使用快捷键 \"Alt + ←\" 将选中内容在行内向左移动。\n\n使用快捷键 \"Alt + →\" 将选中内容在行内向右移动。\n\n![move](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU03ce2e8b468c49d4b80f5399c2290ff72.jpg)\n\n### 单选\n\n使用快捷键 \"Ctrl + Alt + U\" 将光标变为一个。\n\n![single](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU9d8f4514fcbc4aa585e4ec98d177b8fb4.jpg)\n\n\n## 计算器功能\n\n计算器功能一共有三个快捷键，分别是：\n\n1. 定义（Define）：\"Shift + Ctrl + Alt + D\"\n2. 等于（Equal）：\"Shift + Ctrl + Alt + E\"\n3. 替换（Replace）：\"Shift + Ctrl + Alt + R\"\n\n这三个命令实际上效果相同，唯一区别是输出的内容。\n\n“定义”什么都不会输出，通常用来定义变量，如 “x=3”。\n\n“等于”会将计算结果加上等于号并接在当前选中区域之后，如 “1+2” 会变成 “1+2=3”。\n\n“等于”会用计算结果替换选中区域，如 “1+2” 会变成 “3”。\n\n目前计算器支持数值运算，函数运算，多项式运算，矩阵运算等诸多运算，并且是用 Latex 表达式直接计算，输出结果也会自动转换为 Latex 形式。\n\n![Calculator](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU775488c7dd0a4fa682ffed6b36ef12ab1.jpg)\n\nPS：运算相关支持使用的是 “Mathjs” 库，一切 Mathjs 表达式均可以正常使用。\n\n\n## 常用 Snippets \n\n插件还内置了许多的 Snippets，让你写 Latex 数学公式更为简单快捷。\n\n详细的 Snippets 请参考我的博客或者插件的介绍页面。\n\n![](https://picgo-1258602555.cos.ap-nanjing.myqcloud.com/undefinedU649466346e7a45368747001600b89921s.jpg)\n\n\n# 最后\n\n欢迎来我的博客，orangex4.cool，我的github，抑或是邮箱 318483724@qq.com 提交反馈！\n\n感谢！","tags":["Typescript","Javascript","VS Code","Extension","Calculator"],"categories":["Product"]},{"title":"思修重点笔记, 考前突击使用","url":"/post/notes-of-sixiu/","content":"\n# 思修重点笔记\n\n用来考前突击.\n\n<!-- more -->\n\n# 零. 绪论\n\n## 如何做有理想有本领有担当的时代新人\n\n1. 要有崇高的理想信念, 牢记使命, 自信自勉\n2. 要有高强的本领才干, 勤奋学习, 全面发展\n3. 要有天下兴亡匹夫有责的担当精神, 讲求奉献, 实干进取\n\n\n# 一. 人生的青春之间\n\n## 人生观的主要内容\n\n人生观的主要内容包括人生目的, 人生态度和人生价值.\n\n1. 人生目的是指生活在一定历史条件下的人在人生实践中关于自身行为的根本指向和人生追求.\n   1. 人生目的回答人为了什么活着.\n   2. 人生目的是人生观的核心.\n2. 人生态度是指人们通过生活实践形成的对人生问题的一种稳定的心理倾向和精神状态.\n   1. 人生态度回答人应当如何活着.\n   2. 人生态度是人生观的重要内容.\n3. 人生价值是指人的生命及其实践活动对于社会和个人所具有的作用和意义\n   1. 人生价值回答什么样的人生才有价值.\n\n## 个人与社会的辩证关系\n\n1. 个人与社会是对立统一的关系, 两者相互依存, 相互制约, 相互促进. 社会是由一个个具体的人组成的, 离开了人就没有社会, 社会是人的存在形式. 同时, 人是社会的人, 离开了社会人也无法生活.\n2. 个人利益的满足只能是在一定的社会条件下, 通过一定的社会方式来实现. 社会利益不是个人利益的简单相加, 而是所有人利益的统一. 社会利益体现了作为社会成员的个人的根本利益和长远利益.\n3. 人的社会性决定了人只有在推动社会进步的过程中, 才能实现自我的发展.\n\n## 如何评价人生价值\n\n评价人生价值的根本尺度, 是看一个人的实践活动是否符合社会发展的客观规律, 是否促进了历史的进步.\n\n1. 坚持能力有大小与贡献须尽力相统一.\n2. 坚持物质贡献与精神贡献相统一.\n3. 坚持完善自身与贡献社会相统一.\n\n## 如何树立正确的生死观\n\n1. 认识到生命的历程是一个从生到死的过程, 有生必有死, 这是恒常不变的自然现象.\n2. 要牢固树立生命可贵的意识, 倍加爱护自己和他人的生命, 理性面对生老病死的自然规律, 努力使自己的生命绽放人生应有的光彩.\n3. 人的生命是有限的, 而生命的价值却是无限的, 我们无法增加生命的长度, 却能追求生命应有的高度, 可以努力给有限的个体生命赋予更有价值的意义.\n\n\n# 二. 坚定理想信念\n\n## 什么是理想信念\n\n理想是人们在实践中形成的, 有实现可能性的, 对未来社会和自身发展目标的追求和向往.\n\n\n# 三. 弘扬中国精神\n\n## 中国精神的内容\n\n#### 以爱国主义为核心的民族精神\n\n1. 爱国主义是千百年来人们在社会实践中形成的对自己的祖国及其忠诚和热爱的深厚情感. 中华民族从来就有爱国主义的光荣传统.\n2. 中国人民在长期奋斗中培育, 继承, 发展起来的伟大民族精神, 为中国发展和人类文明进步提供了强大的精神动力.\n   1. 伟大创造精神\n   2. 伟大奋斗精神\n   3. 伟大团结精神\n   4. 伟大梦想精神\n\n#### 以改革创新为核心的时代精神\n\n1. 改革创新精神是时代精神的核心, 贯穿于改革开放的全部实践, 体现在时代精神的各个方面.\n2. 以改革创新为核心的时代精神, 是当代中国人民精神风貌的集中体现, 是激发社会创造活力的强大力量.\n\n## 爱国主义的内涵\n\n1. 爱国主义是人民对自己家园以及民族和文化的归属感, 认同感, 尊严感与荣誉感的统一.\n   1. 爱祖国的大好河山.\n   2. 爱自己的骨肉同胞.\n   3. 爱祖国的灿烂文化.\n   4. 爱自己的国家.\n2. 爱国主义是历史的, 具体的, 在不同的历史条件和文化背景下所形成的爱国主义.\n\n## 新时代的爱国主义\n\n1. 坚持爱国主义和社会主义相统一.\n2. 维护祖国统一和民族团结.\n3. 尊重和传承中华民族历史和文化.\n4. 必须坚持立足民族又面向世界.\n\n\n# 四. 践行社会主义核心价值观\n\n## 社会主义核心价值观的基本内容\n\n定义: 核心价值观是一定社会形态社会性质的集中体现, 在一个社会的思想观念体系中处于主导地位, 体现着社会制度, 社会运行的基本原则和社会发展的基本方向.\n\n1. 富强, 民主, 文明, 和谐.\n2. 自由, 平等, 公正, 法治.\n3. 爱国, 敬业, 诚信, 友善.\n\n\n# 五. 明大德守公德严私德\n\n## 什么是道德\n\n定义: 道德是以善恶为评价方式, 主要依靠社会舆论, 传统习俗和内心信念发挥作用的行为规范的总和.\n\n## 公众生活中的道德规范\n\n公众生活中的道德规范, 即社会公德, 是指人们在社会交往和公共生活中应该遵守的行为准则, 是维护公共利益, 公共秩序, 社会和谐稳定的起码的道德要求.\n\n## 如何树立正确的恋爱观与婚姻观\n\n重要性: 处理好恋爱中的各种关系, 是对爱情的祝福, 也是对自己的祝福, 更是对未来人生幸福的祝福.\n\n1. 不能误把友谊当爱情.\n2. 不能错置爱情的地位.\n3. 不能片面或功利化地对待恋爱.\n4. 不能只重过程不顾后果.\n5. 不能因失恋而迷失人生方向.\n\n## 什么是个人品德\n\n个人品德是通过社会道德教育和个人自觉的道德修养所形成的稳定的心理状态和行为习惯.\n\n## 掌握道德修养的正确方法\n\n道德修养是指个体自觉地将一定社会地道德规范, 准则及要求内化为内在地道德品质, 以促进人格的自我陶冶, 自我培育和自我完善的实践过程.\n\n1. 学思并重. 学思并重的方法, 即通过虚心学习, 积极思索, 辨别善恶, 学善戒恶, 以涵养良好的德性.\n2. 省察克治. 省察克治的方法, 即通过反省检验以发现和找出自己思想与行为中的不良倾向, 并及时对它们进行抑制和克服.\n3. 慎独自律. 慎独自律的方法, 即在无人知晓, 没有外在监督的情况下, 坚守自己的道德信念, 自觉按道德要求行事, 不因无人监督而恣意妄为.\n4. 知行合一. 知行合一的方法, 即把提高道德认识与躬行道德实践统一起来, 以促进道德要求内化为个人的道德品质, 外化为实际的道德行为.\n5. 积善成德. 积善成德的方法, 即通过积累善行或美德, 使之巩固强化, 以逐渐凝结成优良的品德.\n\n\n# 六. 尊法学法守法用法\n\n## 什么是法律\n\n法律是由国家制定或认可并以国家强制力保证实施的, 反映由特定社会物质生活条件所决定的统治阶级意志的规范体系.\n\n## 我国宪法的地位\n\n1. 我国宪法是国家的根本法, 是治国安邦的总章程.\n2. 我国宪法是国家各项制度和法律法规的总依据.\n3. 我国宪法规定了国家的根本制度.\n\n## 什么是民法\n\n民法是调整平等主体的自然人, 法人和非法人组织之间的人身关系和财产关系的法律规范.\n\n## 正确认识法治和德治的地位\n\n1. 法治是治国理政的基本方式, 依法治国是基本方略, 法治具有根本性, 决定性和统一性.\n2. 德治是治国理政的重要方式, 以德治国就是通过在全社会培育, 弘扬社会主义核心价值观和社会主义道德, 对不同人群提出有针对性的道德要求.\n\n## 正确认识法治和德治的作用\n\n1. 法治发挥作用要以国家强制力为后盾, 主要依靠法律的预测作用, 惩戒作用, 威慑作用和预防作用对公民和社会组织的行为进行约束, 并对违反法律的行为追究法律责任.\n2. 德治发挥作用主要通过人们的内心信念, 传统习俗, 社会舆论等进行道德教化, 并对违反道德的行为进行道德谴责.\n\n## 正确认识法治和德治的实现途径\n\n1. 法治体现的是规则之治.\n2. 德治主要依靠培育和弘扬道德等途径来推进和实施, 道德是内心的法律.\n\n## 法治和德治相互促进\n\n1. 强化道德对法治的支撑作用.\n2. 把道德要求贯彻到法治建设中.\n3. 运用法治手段解决道德领域突出的问题.\n\n## 法治思维的含义\n\n法治思维是指以法治价值和法治精神为导向, 运用法律原则, 法律规则, 法律方法思考和处理问题的思维模式.\n\n## 法治思维的基本内容\n\n1. 法律至上. 法律至上尤其指宪法至上, 因为宪法具有最高的法律效力, 是其他一切法律的依据.\n2. 权力制约. 权力制约是指国家机关的权力必须受到法律的规制和约束.\n3. 公平正义. 公平正义主要包括权利公平, 机会公平, 规则公平和救济公平.\n4. 权力保障. 权力保障具体包括公民权利的宪法保障, 立法保障, 行政保护和司法保障. \n5. 正当程序. 正当程序表现在程序的合法性, 中立性, 参与性, 公开性, 时限性等方面.","tags":["Study","NJU"],"categories":["Study"]},{"title":"深度学习炼丹术实践之姿态识别--开发一个能够识别用户动作的软件","url":"/post/try-to-use-deeplearning/","content":"\n# 深度学习炼丹术实践之姿态识别\n\n其实我一直都有一个神奇的想法: 通过炼丹术识别用户的动作, 我管它叫做姿态识别.\n\n要达到姿态识别的功能, 简单分析就可以知道, 需要用摄像头实时拍摄一个人的动作, 并把它传输去PC端, 然后用炼丹术把数据映射成为一个简单的动作.\n\n(可以看作是一个简单的分类器)\n\n<!-- more -->\n\n## 安卓端\n\n我发现华为的 MindSpore 有一个很适合的功能, PoseNet. 我可以通过 PoseNet 来简化输入的数据, 以达到数据集更小, 特征性更强的效果, 即用 PoseNet 来做特征工程.\n\n听了一次华为在南大的讲座之后, 我下载了 MindSpore 开放的源码, 找到了 PoseNet 的模块, 并顺利通过了编译.\n\n经过一系列的改造, 我给 PoseNet 加入了网络模块, 并将 PoseNet 获取到的数据转化成 Json, 并用 POST 方法传输到 PC 端中. 所以我们只要在 PC 端开一个服务器就能接受到数据.\n\n这个魔改版本的 PoseNet 被我更名为 PoseKey, 源码已经上传到 [GitHub](https://github.com/OrangeX4/PoseKey-Android).\n\n只要在同一个 WiFi 即同一个局域网下, 在里面写上你的 PC 的 IP 地址, 它在识别到用户的姿态之后, 就会自动传输数据到 PC 的 Server 上.\n\nJson 样例如下:\n\n```json\n{\n    \"test\": \"android\",\n    \"score\": 0.8146785497665405,\n    \"time\": 1608909337572,\n    \"keyPoints\": {\n        \"NOSE\": {\n            \"score\": 0.815959095954895,\n            \"position\": {\n                \"x\": 127,\n                \"y\": 88\n            }\n        },\n        \"LEFT_EYE\": {\n            \"score\": 0.7012987732887268,\n            \"position\": {\n                \"x\": 128,\n                \"y\": 85\n            }\n        },\n        \"RIGHT_EYE\": {\n            \"score\": 0.5838527679443359,\n            \"position\": {\n                \"x\": 127,\n                \"y\": 85\n            }\n        },\n        \"LEFT_EAR\": {\n            \"score\": 0.8103403449058533,\n            \"position\": {\n                \"x\": 131,\n                \"y\": 86\n            }\n        },\n        \"RIGHT_EAR\": {\n            \"score\": 0.5026875734329224,\n            \"position\": {\n                \"x\": 130,\n                \"y\": 85\n            }\n        },\n        \"LEFT_SHOULDER\": {\n            \"score\": 0.9689308404922485,\n            \"position\": {\n                \"x\": 127,\n                \"y\": 101\n            }\n        },\n        \"RIGHT_SHOULDER\": {\n            \"score\": 0.9753607511520386,\n            \"position\": {\n                \"x\": 131,\n                \"y\": 100\n            }\n        },\n        \"LEFT_ELBOW\": {\n            \"score\": 0.8243715167045593,\n            \"position\": {\n                \"x\": 111,\n                \"y\": 120\n            }\n        },\n        \"RIGHT_ELBOW\": {\n            \"score\": 0.6323183178901672,\n            \"position\": {\n                \"x\": 155,\n                \"y\": 119\n            }\n        },\n        \"LEFT_WRIST\": {\n            \"score\": 0.7550386190414429,\n            \"position\": {\n                \"x\": 110,\n                \"y\": 137\n            }\n        },\n        \"RIGHT_WRIST\": {\n            \"score\": 0.5845995545387268,\n            \"position\": {\n                \"x\": 126,\n                \"y\": 136\n            }\n        },\n        \"LEFT_HIP\": {\n            \"score\": 0.9933162927627563,\n            \"position\": {\n                \"x\": 124,\n                \"y\": 135\n            }\n        },\n        \"RIGHT_HIP\": {\n            \"score\": 0.9925392866134644,\n            \"position\": {\n                \"x\": 130,\n                \"y\": 136\n            }\n        },\n        \"LEFT_KNEE\": {\n            \"score\": 0.9693067073822021,\n            \"position\": {\n                \"x\": 131,\n                \"y\": 159\n            }\n        },\n        \"RIGHT_KNEE\": {\n            \"score\": 0.9470896124839783,\n            \"position\": {\n                \"x\": 126,\n                \"y\": 159\n            }\n        },\n        \"LEFT_ANKLE\": {\n            \"score\": 0.9394081234931946,\n            \"position\": {\n                \"x\": 128,\n                \"y\": 179\n            }\n        },\n        \"RIGHT_ANKLE\": {\n            \"score\": 0.853115975856781,\n            \"position\": {\n                \"x\": 123,\n                \"y\": 179\n            }\n        }\n    }\n}\n```\n\n\nAPP 效果如图:\n\n![](https://s3.ax1x.com/2020/12/27/r5M0O0.jpg)\n\n\n## PC端\n\n### 数据记录\n\n经过尝试, 我用 Python 开启了一个 Flask, 并将数据处理成一个 numpy 数组, 并尝试去做一个最简单的二分: 站立 (STAND) 或 跑步 (RUN).\n\n我自己记录和标注数据, 真就移动端+前端+后端+数据的全栈工具人呗.\n\n于是顶着被室友当傻子看的风险, 我在宿舍时而呆若木鸡, 时而动若疯兔, 录了接近十分钟的数据.\n\n对于这些数据的存储与处理, 我选择不使用数据库, 而是作为伪json文件保存下来, 最终结果大概是两万行的数据量. 经过一番处理, 变成了700×24×17×3的训练集和100×24×17×3的测试集.\n\n3是指其中一个点的分数, x坐标和y坐标.\n\n17是指一共17个的关键点 (手臂啊, 肩膀啊什么的).\n\n24是指24行的数据, 大概对应着一秒钟之内产生的数据, 即加入了一个类似时间变化的维度.\n\n(700+100)×24=19200, 即大概两万行的数据.\n\n记录数据的时候各种出 Bug, 特别是 Python 的 IO 操作还可能导致出现空行, 因此我不得不手动清除空行. 打算之后再写一个自动去除空行的小工具.\n\n### 数据处理\n\n头一次使用上了 Google 的 Colab, 体验还是蛮不错的, 用来跑一些简单的训练很快乐. (至少比我这个算力极弱还是 AMD 的弱鸡轻薄本好太多了)\n\n但结果并不一定完全如人所愿, 事实上就算是这个简单的二分, 效果也不是很好. 不知道是 Model 设计不佳还是过拟合的缘故, 在跑测试集的时候效果很好, 但是到真正实际用到的时候, 甚至跑不过随机!\n\n### 实际尝试\n\n跑好了模型之后, 我开始尝试实时识别我的动作. 但结果是, 我必须站在一个独特的位置效果才会好, 站在其他位置, 基本都被识别成了 RUN.\n\n看来就算是一个简单的二分, 也不是那么好做的啊.\n\n现在只是进行着想法论证, 还远远没到出成品的时候. 成品需要的是多分类, 而不是二分类, 想想就头疼, 唉.\n\n附一张勉强算是成功的截图:\n\n![](https://s3.ax1x.com/2020/12/27/r5Mwyq.png)\n\n[GitHub](https://github.com/OrangeX4/PoseKey-Desktop)","tags":["Python","Android","DeepLearning","Flask","tensorflow","keras"],"categories":["Technology"]},{"title":"从游戏行业看中国文化输出","url":"/post/thoughts-on-chinese-cultural-output-from-the-game-industry/","content":"\n# 从游戏行业看中国文化输出\n\n## 一、管中窥豹：认识文化输出\n\n我们总说中国要加强文化输出，所以到底什么是文化输出？文化输出泛指全球媒体输出者支配文化较弱势的国家的文化消费的趋势，将本身的文化及其他价值加诸在他国的接受者上，其中的输出内容包含了文化、科技、所有权、生产价值、专业意识形态等。\n\n但是相对于“文化输出”那么直白的名词，国家层面更偏向于称之为“文化软实力”。文化软实力是指文化的吸引力和感染力，其有助于帮助国家提高意识形态和政治价值观的吸引力。\n\n《长城上的喝可乐男孩》便是一个典型的例子。古代的长城在战争年代能防住外敌的入侵，在和平年代却无法阻拦大洋彼岸的一瓶可乐进入中国。我们可以从中粗略的看出，在如今和平年代，文化输出或者说文化软实力的重要性。\n\n![](https://pic3.zhimg.com/80/v2-81045ef16c6183ab9562cc549749d972_720w.jpg)\n\n<!-- more -->\n\n近年来，中国无论是在经济实力、军事实力或是科技实力，都已经能够在国际上名列前茅，也已早就成为了仅次于美国的世界第二大经济体。但是与之形成鲜明对比的是，我们的文化输出波澜不惊。对于世界文化的影响力，不要说与欧美相比，就连我们的邻国日韩，中国都仍与他们有一定差距。\n\n中国官方已经意识到了这个问题，开始大力向外国宣传中国文化，例如开展交流会，在世界各地开办孔子学院，引进留学生等等，却收效甚微。这很有可能是我们之前对文化输出的认识一直都是错的：我们总想把我们认为最好的中国文化输出出去，例如汉语，京剧。但是事实证明，这样做基本上是不可行的。\n\n## 二、海纳百川：有效的文化输出\n\n让我们抛开先前生硬的定义，认真思考一下文化输出的本质是什么。我们会发现，能够被文化输出的文化，往往不是我们认为的“优秀文化”，而被认为上不了台面的“流行文化”往往更容易向外输出。\n\n美国向我们输出了什么文化？是所谓民主自由的价值观吗？有，但是大众基本不会在意。美国真正输出成功的是可乐，快餐，牛仔裤，好莱坞大片和各种3A游戏大作。\n\n韩国向我们输出了什么文化？是韩服，韩国习俗，韩国历史吗？然而根本没有什么人会在意。韩国真正输出的是韩剧，偶像经济和三星电子产品。\n\n日本向我们输出了什么文化？是日本传统戏剧，和服和武士道精神？它们并不算主流。日本真正输出的是日本动漫，并在其中夹杂了日本的传统的妖怪文化，忍术和武士道。\n\n![](https://pic1.zhimg.com/80/v2-22f278778c8039670774568b95e3f410_720w.jpg)\n\n而且这些文化都有显著的特点，它们都是娱乐性的，是在自己的国家也会大规模流行的，被人民大众喜闻乐见的文化。我们不能拘泥于文化输出只能是中国优秀的传统文化这个完全没有实践性的观点。京剧在全国范围内都算不上流行，我国相当一部分人甚至都没有接触过京剧，那么我们凭什么让外国民众接受这种“咿咿呀呀”？我们绝不能被极小部分外国友人喜欢中国的书法和京剧的现象蒙蔽，就认为外国大部分人都能了解到其中的美。\n\n我国真正有效的文化输出，应该是输出大众喜闻乐见的流行文化。很多人看不起中国的流行的网络小说，认为网络小说根本就算不上文学，就是中国的文化糟粕，甚至还有人以网络小说祸害青少年的心理健康为由，提议封禁网络小说。但是实际上，正是这种“文化糟粕”网络小说，真正地输出到了外国。中国的网络小说在国外有着稳定的观众，真正打破中国文学在全球总是没有什么话语权的局面。进入外国文学界靠的不是经典文学而是网络文学，可以说是一种极大的讽刺。\n\n![](https://pic3.zhimg.com/80/v2-b0c4f0ca6ab5d5ee00de9c6549b5aa96_720w.jpg)\n\n真正做到了让绝大部分人都满意的中国文化输出，应该说是李子柒的中国传统乡村视频，既拥有大众喜闻乐见的美，且宣传了中国的传统乡村文化，让许多外国友人萌生到中国旅游的梦想。\n\n咳咳，回到正题，中国还有一类异军突起的文化输出，我们不容忽视，那便是游戏行业的文化输出。\n\n\n## 三、兼收并蓄：外国对中国的游戏文化输出\n\n有那么一种说法，游戏是第九艺术。而这种“艺术”，在国外已经非常发达了。如美国游戏公司R星的《荒野大镖客2》和《GTA》系列就分别向中国输出了美国西部文化和警匪文化。法国游戏公司育碧的《刺客信条系列》给人们展示了古希腊文化等欧洲传统文化。甚至是日本著名的《马里奥》游戏也同样输出了日本文化，虽然马里奥在设定上是一个意大利人，但是说到马里奥，人们总是会想起日本而不是意大利。马里奥没有宣扬太多的日本传统文化，但是实际上马里奥本身就变成了日本的一种文化。\n\n![](https://pic3.zhimg.com/80/v2-b4fd5fa851be60bbe6a441b074158f02_720w.jpg)\n\n这样的例子还有很多很多，外国向中国输出的游戏大部分都是所谓的3A大作。那么中国的文化输出呢？事实上，中国仍然没有一款真正算得上3A的游戏大作。中国没有像外国那样包容的社会环境，绝大部分家长仍然认为游戏是洪水猛兽；中国没有像外国那样发达的经济社会，对中国绝大部分人来说买一个数千块钱的游戏机和数百块钱的游戏仍然是不可思议的也不可能的事；中国对国产单机游戏的偏见，使得国产游戏的单机游戏不可能有太高的定价，游戏厂商也很难回本。\n\n那么我们是不是就不可能在游戏领域进行文化输出了呢？然而并不一定。\n\n\n## 四、另辟蹊径：网游手游行业的异军突起\n\n很多游戏玩家看不起网游和手游。相对于国外的3A游戏大作，网游和手游往往被看作是粗制滥造和骗氪的代名词。然而，如果说中国在文化领域有什么全球领先的行业的话，那么中国的网游手游行业必定有一席之地。\n\n世界上最大的游戏公司是哪家？动视暴雪，R星，育碧？然而都不是。就市值和收入综合来看，世界上最大的游戏公司是腾讯。腾讯游戏的2019年总收入达到了162.24亿美元，其中超过20%是由海外市场贡献的。其中《PUBG Mobile》，腾讯的一款吃鸡手游，在海外获得了极高的关注度。还有腾讯完全控股的拳头公司，旗下的游戏《LOL》在国内外都有着相当庞大的拥簇，而且相应的衍生的电子竞技行业，也以《LOL》作为主要的竞技游戏。还有腾讯半数控股的游戏公司Epic，旗下有着全球闻名的游戏引擎《虚幻》和在欧美爆火的游戏《堡垒之夜》。可以说，腾讯游戏在全球范围内都是闻名遐迩的。\n\n听起来很美好，是么？但是定睛一看，其实腾讯海外爆火的游戏大部分都是外国公司创作的，文化输出在哪呢？是的，腾讯与其说是一家游戏公司，不如说是一家游戏投资公司。腾讯投资了很多外国优秀的游戏公司，给予他们资本和流量，进而获取利益。导致腾讯真正能在国外流行的游戏，基本都是外国公司生产的，进而使得游戏中基本上没有任何的中国元素，甚至很多人都不知道这是中国游戏公司的游戏，就严格意义上来说，它对中国文化输出没有太大的贡献。\n\n![](https://pic2.zhimg.com/80/v2-638793bb64444dff21cbeb5c121f7ea5_720w.jpg)\n\n\n类似的，还有另外一款在日本爆火的中国游戏《碧蓝航线》，由弹幕视频网站Bilibili代理发行，在国内小有名气，在日本却能够大热。究其原因，《碧蓝航线》与日本游戏《舰队Collection》世界观相似，甚至说前者就是由后者衍生出来的。舰娘文化是一种二次元文化，发源于日本，而《碧蓝航线》在日本的火爆，也是因为他在日本有着相应的受众。虽然《碧蓝航线》中蕴涵的中国文化不算多，但是大部分碧蓝航线的玩家都知道这是一款中国的游戏，所以也能算是一种文化输出。\n\n![](https://pic2.zhimg.com/80/v2-15a4c668cf3663f18166b486740f4a09_720w.jpg)\n\n实际上，今年，也就是2020年，我们出现了一款在全球范围内都爆火的中国游戏。《原神》，一款异军突起的黑马游戏。即使网上对《原神》的风评很差，甚至一度成为全网公敌，但是这也并不妨碍《原神》在全球范围内爆火，成为一款称得上优秀的游戏。\n\n简单介绍《原神》的剧情。从异世界来的兄妹失散，去探访尘世七国的七神来寻找亲人。而游戏中的尘世七国，隐约对应着现实中的七个国家或地区。\n\n最开始的蒙德主城代表的是法国德国等欧洲文化，其中巨大的风车也有隐喻“风车之国”荷兰。\n\n另一个主城璃月，代表的是中国古代文化，其中的建筑充满了中国风，饮食文化也和中国相同，璃月港所展现出来的中国传统美景让外国玩家深深折服。\n\n接下来即将开放的主城是稻妻，代表的是幕府时期的日本文化，其中的主神将军长生不灭，进行幕府锁国严禁通航，歌舞伎和和服少女在古巷弄里生活。\n\n还有另一座主城须弥，须弥是梵文音译，这座主城代表着的是古埃及和古印度的传统文化，主题是对智慧的获取。\n\n枫丹主城是以意大利等以艺术闻名欧洲国家为蓝本，很典型的歌剧式音乐跟舞台背景，穿插着人权与神权的法学冲突。\n\n纳塔主城的文化奠基是拉丁美洲和西班牙文化，以宗教狂欢节和黑人与印加人的巫灵文化为特色。\n\n最后的是至东主城，很自然地，以俄国为蓝本，有着北境的特有气势，大气而磅礴。\n\n![](https://pic2.zhimg.com/80/v2-d3ed91660241403bdb3f41f2733cb769_720w.jpg)\n\n**蒙德城**\n\n![](https://pic2.zhimg.com/80/v2-3994f6bb443b57b1715edb03cf1d2e7d_720w.jpg)\n\n**璃月城**\n\n![](https://pic3.zhimg.com/80/v2-94ff0a8632a4f02a34446a76bebded7e_720w.jpg)\n\n**璃月海灯节（中国元宵节）**\n\n《原神》以各国文化为蓝本，自然也有着被各国玩家接纳的底蕴。事实上，《原神》在全球范围内广受好评。\n\n1. 璃月地区外国翻译使用的拼音，使得许多外国友人开始学习中国的拼音发音；\n2. 《原神》的音乐是由世界上最著名的几个交响乐团演奏的，既磅礴大气，又优美动听，世界范围内的许多音乐制作人都在讲解璃月地区的音乐，并表示非常喜欢中国民乐；\n3. 世界范围内对《原神》的二次创作和同人创作也非常多，包括许多中国风的图片；\n4. 游戏PV中出现了筷子，也让许多外国友人开始了对筷子文化的搜索和讨论；\n5. 并且《原神》与国内许多景区联动，如张家界，黄龙和桂林景区，在《原神》中都有对应的地图，从而也让许多外国友人梦想着有一天能够到中国来旅游。\n6. 甚至引发了对弓术的讨论\n\n![](https://pic4.zhimg.com/80/v2-bf384f77dcaae6c7033e154522df6b87_720w.jpg)\n\n**YouTube上教导璃月拼音发音的视频有着较高的播放量**\n\n![](https://pic2.zhimg.com/80/v2-b57c7fe8b9045d740c0b5b2228709ac5_720w.jpg)\n\n**璃月音乐和原神景区联动**\n\n![](https://pic2.zhimg.com/80/v2-2be852431d99ea0e8f2a065c4070d4a1_720w.jpg)\n\n**原神使外国友人有了来中国旅游的愿望**\n\n![](https://pic2.zhimg.com/80/v2-3a506f4d84c7d339ebfd380e3db9a78d_720w.jpg)\n\n**对于弓术的讨论**\n\n实际上，国家也是认可《原神》的文化输出成果的。《原神》中的角色「刻晴」登上央视新闻 2020 年度图鉴，与电影《姜子牙》中的姜子牙等人物排在一起。之前大使馆也为原神站台，因为《原神》在2020年带着中国文化出海狂割外汇，是中国的文化软实力，在年度图鉴中有一个位置实至名归。\n\n![](https://pic3.zhimg.com/80/v2-eca095ef2ced3414ac03d4478b4fe48e_720w.jpg)\n\n**红色框中的是原神璃月的一个游戏角色：刻晴**\n\n而刻晴能够被选中的原因，很有可能是因为她的价值观与官方不谋而合：神明的时代已经远去，而属于凡人的时代正在到来。敬神而不信神，认为人类的命运应当由人类自己决定，并且做事身先士卒。\n\n事实证明，《原神》在中国的文化输出方面，是合格的。但是原神也并非没有缺点。它是一款手游，虽然在PC端和主机端也可以玩，但是它仍然是个氪金手游，还很难与外国的3A单机大作相比。那么我们真的就不可能有一款能够让国人满意，又能吸引到外国友人的作品吗？我认为是有可能的。\n\n\n## 五、未来可期：中国游戏的未来\n\n你是否听说过一款仍未发售的游戏，《黑神话：悟空》？游戏科学在2020年8月20日发布了一个《黑神话：悟空》的演示视频，瞬间引爆了整个中国游戏圈。\n\n![](https://pic3.zhimg.com/80/v2-f11fc9510a44a9744e8ff58c55418f82_720w.jpg)\n\n**《黑神话：悟空》演示视频在B站达到了三千万的播放量**\n\n引用游戏科学运营总监蓝为一的一段话：\n\n> “17年底，我们意识到了Steam平台上，中国区用户数量已经超越美国成为第一。同时，《GTA5》在中国地区有着超过一百万的拥有者，像《森林》这样的游戏在中国也有数十万的拥有者。在这之前，我们对于国产单机大作的印象，还停留在《仙剑》和《古剑》。停留在游戏工委年度报告上1.4亿人民币的单机市场规模这样的数字上。而那时我们意识到了，国内单机市场在发生着变化。”\n\n国内单机市场正在发生变化，国内也确实需要一部3A大作为中国游戏开创一个新的时代了。这样的时代，国外已经到来了数十年之久，而我国还仍未开始。中国有着收入最高的游戏公司，却没有一部3A作品，这何尝不是一种讽刺。\n\n我们终将会生产出一部属于我们的3A游戏，一部以中国神话为底色，以中国玩家为主体，给中国玩家带来自豪感，给世界游戏界贡献新的体验的中国3A游戏大作。我们需要他来实现我们自己在游戏中的民族自豪感，需要他为我们输出本应被全球所熟知的中国神话文化。\n\n《黑神话：悟空》的文化输出潜力已经可以见微知著。外国友人已经开始关注起了这部由中国开发的单机游戏，开始看他的实机演示视频，感受到了中国游戏的潜力。\n\n![](https://pic2.zhimg.com/80/v2-89b27bc508658818f63e8033e8978b05_720w.jpg)\n\n**外国3A游戏开发者对黑悟空的惊叹**\n\n## 六、共飨盛宴：总结\n\n世界文化应该是多元的。每一个国家都应该向世界发出属于自己的声音，而不是让一两个国家的文化一家独大。现代的中国，需要向世界发出自己的声音。\n\n除了阳春白雪的孔子学院与戏剧，也不应该忽视下里巴人的游戏行业。游戏是第九艺术，也是一种能被世界上绝大部分人感知与接受的艺术。不论是网游手游，还是单机大作，我们都应该放下对他们的成见。只有被人民喜闻乐见的文化，才是真正的好文化。而我们要输出的，也应该可以是游戏文化。\n\n\n## 参考文献：\n\n1. [如今我风华正茂：游戏科学是如何制造《黑神话：悟空》的](https://www.chuapp.com/article/287425.html)\n2. [如何评价游戏科学放出的单机游戏《黑神话：悟空》实机演示？](https://www.zhihu.com/question/415822945)\n3. [旅人的弦歌——《原神》璃月音乐的幕后](https://www.bilibili.com/video/BV1xp4y16761)\n4. [《原神》海灯节活动实时过场动画-「汇成明霄」](https://www.bilibili.com/video/BV12A41187WG)\n5. [genshin pronunciation - YouTube](https://www.youtube.com/results?search_query=genshin+pronunciation)\n6. [原神和李子柒，哪个是更好的文化输出?](https://www.zhihu.com/question/430453280)\n7. [原神是不是中国第一个产生大范围文化输出的「手机游戏作品」？](https://www.zhihu.com/question/432183530)\n8. [《原神》的风评是如何“转变”的？](https://www.zhihu.com/question/420330765/answer/1544223050)\n9. [如何看待游戏《原神》中的角色「刻晴」登上某媒体 2020 年度图鉴？](https://www.zhihu.com/question/436689326)\n10. [腾讯游戏第四季度营收302.86亿元 海外收入占比23%](https://tech.sina.com.cn/i/2020-03-18/doc-iimxyqwa1429295.shtml)\n11. [2019年游戏公司收入排名 索尼第一腾讯第二老任第三](https://tech.sina.cn/2020-05-25/detail-iirczymk3504077.d.html)\n12. [都说美国进行文化输出，何为文化输出以及有什么影响？](https://www.zhihu.com/question/273568614)\n13. [与日本文化输出相比，中国文化输出差在哪里？](https://www.zhihu.com/question/26469593)","tags":["Game","Genshin"],"categories":["Thoughts"]},{"title":"自动安装Vscode和C++开发环境的程序","url":"/post/auto-install-the-environment-of-vscode-and-cpp/","content":"\n# 自动安装 VS Code 和 C++ 开发环境的程序\n\n闲着无聊, 觉得之前用别人的自动搭建 C++ 环境程序不太好用, 于是决定自己开发一个类似的程序.\n\n<!-- more -->\n\n# GitHub 地址\n\n[GitHub](https://github.com/OrangeX4/Auto-Vscode-Cpp)\n\n欢迎来点一个 Star 啊!\n\n# 使用\n\n## 下载\n\n请去 [下载](https://box.nju.edu.cn/f/5ac1a60d3cac46b78c0c/?dl=1) 该程序的 exe 可执行文件版本.\n\n或者你也可以尝试一下速度极慢的 [Github Release](https://github.com/OrangeX4/Auto-Vscode-Cpp/releases/download/1.0.0/auto-vscode-cpp.zip).\n\n## 运行\n\n解压后, 右键以管理员身份运行.\n\n如果没有出现问题, 你应该能看见这个界面:\n\n![](https://s3.ax1x.com/2020/12/25/rWjQl6.png)\n\n## 使用\n\n### Vscode的安装\n\n如果没有安装 Vscode, 请点击第一栏的下载安装, 下载将在后台运行, 请稍等一两分钟. 下载完成后将自动打开 Vscode 的安装程序, 请手动安装.\n\n安装过程中, 尽量选上将 Vscode 加入环境变量的选项.\n\n### MinGW\n\n如果你不想安装到默认目录, 请点击\"修改位置\"来更改你要将 MinGW 安装到的目录. MinGW 大概会占据两百兆的空间, 请确保磁盘有足够的空间.\n\n注意! 点击\"修改位置\"之后, 可能会没有任何反应, 这时候请最小化浏览器, 你会看见这样一个界面:\n\n![](https://s3.ax1x.com/2020/12/25/rWvRVe.png)\n\n请选择你需要安装到的目录.\n\n选择好之后, 点击\"下载安装\"按钮, 后台会自动下载和安装, 请等待一两分钟. 安装成功之后, 会弹窗提示安装成功.\n\n如果较长时间后仍无反应, 可能已经安装成功了, 但是出现 Bug 导致没有提示, 这时候请直接执行下一步操作.\n\n注意: MinGW安装好了之后, 会尝试自动添加到环境变量, 但是可能会失败, 这个时候请自行添加到环境变量!\n\n### 工程文件\n\n最为重要的一个文件夹. 请选择一个你希望放置的目录, 且要牢记这个目录的位置.\n\n还是要注意, 选择位置可能要最小化浏览器窗口才能看见浏览文件夹窗口.\n\n然后点击\"下载安装\"按钮, 因为工程文件非常小, 这个过程会迅速完成, 完成后会自动跳出安装目录的资源管理器界面.\n\n请在 Vscode 中打开这个文件夹.\n\n### 在 Vscode 中尝试运行测试代码\n\n用 Vscode 打开这个工程文件夹, 你会看见如下界面.\n\n点击 `test.cpp` 文件, 然后按下 `F5` 键, 如果没有出现问题, 你会成功地用 Vscode 编译出一个程序, 并会运行.\n\n![](https://s3.ax1x.com/2020/12/25/rWzW9A.png)\n\n甚至你可以进行多文件编译. 打开测试代码中的 `multifile/main.cpp`, 在调试面板中选择 `Multiple Files Compile & Run`, 再按下 `F5`, 如果成功运行, 恭喜你运行成功了!\n\n![](https://s3.ax1x.com/2020/12/25/rWz2hd.png)\n\n请注意, 以后你要运行的 C++ 或者 C 文件, 都应该放在这个文件夹里面. 因为 Vscode 依赖于 `.vscode` 目录来识别 C++ 的执行环境. 或者你也可以将这个 `.vscode` 目录复制到其他文件夹下, 来达到在其他文件夹下用 Vscode 调试运行代码的目的.\n\n# 最后\n\n这就是全部了. 感谢使用和反馈 :-)","tags":["C","VS Code","C++","HTML","Python"],"categories":["Product"]},{"title":"在Vscode中通过sftp上传论文","url":"/post/using-sftp-in-vscode/","content":"\n# 在Vscode中通过sftp上传论文\n\n南大的人工智能导引论文要通过sftp上传, 其中sftp的使用提供了两个参考方案. 第一个方案是用命令行上传, 另一个方案是使用一个叫做 File Zilla 的软件.\n\n但是本着一切能用命令行解决的事都可以通过万能的 Vscode 解决的思路, 做了一番尝试, 最后成果了, 决定在这里分享一下.\n\n<!-- more -->\n\n## 下载安装Vscode\n\n什么, 你还没有用过 Vscode? 这种程序员必备的宝藏级别的软件你怎么能不用?\n\n快! 去! 下! 载!\n\n[官方下载](https://code.visualstudio.com/)\n\n[腾讯软件中心](https://pc.qq.com/detail/16/detail_22856.html)\n\n## 下载上传论文的配置文件\n\n我用提供的用户名与密码写了一个开箱可用的配置文件, 你可以直接使用.\n\n(指上传人工智能导引的论文, 相关配置在 `.vscode/sftp.json` 里)\n\n为了限制仅有校内可以下载, 我将它上传到了 NJU Box, 链接看这里:\n\n[下载地址](https://box.nju.edu.cn/f/54c3171348614d2c9da5/)\n\n下载了 `SFTP.zip` 文件之后, 解压成一个叫 `SFTP` 的文件夹, 并用 Vscode 打开这个文件夹.\n\n你可以在资源管理器对这个文件夹右键, 选择 `通过 Code 打开`,\n\n也可以先打开 Vscode, 在菜单那选择 `File -> Open Folder` 打开这个文件夹. \n\n请确保 `.vscode` 文件夹在你的工作区根目录下.\n\n![](https://s3.ax1x.com/2020/12/25/rROTl8.png)\n\n## 安装 SFTP 插件\n\n如图,\n\n1. 打开vscode, 点击拓展面板\n2. 输入sftp, 搜索\n3. 看到第一个 `SFTP`, 点击 Install 安装\n\n![](https://s3.ax1x.com/2020/12/25/rROoSf.png)\n\n## 上传论文\n\n第一步, 先将你的文件拖入工作区:\n\n![](https://s3.ax1x.com/2020/12/25/rRO76S.png)\n\n第二步, 在工作区右键, 上传你的文件:\n\n![](https://s3.ax1x.com/2020/12/25/rRO4Yt.png)\n\n第三步, 你可以查看自己是否上传成功 (注意内容是无法查看的):\n\n![](https://s3.ax1x.com/2020/12/25/rRO5fP.png)\n\n于是, 现在你成功地上传了你的论文啦!\n","tags":["VS Code","Sftp"],"categories":["Technology"]},{"title":"VS Code的Better Markdown & Latex Shortcuts 插件--为Vscode打造更好的Markdown+Latex记笔记体验","url":"/post/better-experience-of-taking-notes-with-vscode-extension/","content":"\n# 中文\n\n## 这是什么?\n\n在我们用vscode做笔记的时候, 我们会用到很多快捷键, 比如向下复制一行的快捷键 `Shift + Alt + ↓` 和向下移动一行的快捷键 `Alt + ↓`\n\n但是很奇怪的是, vscode并没有我们本来以为会有的向右复制和向右移动功能, 本着没有内置功能就找插件, 没有现成的插件就自己写的心态, 我写了一个名为 **Better Markdown&Latex Shortcuts** 的插件.\n\n我将会持续更新这个插件, 来创造一个更好的vscode记笔记体验, 所以当前功能还不能让你满意的话, 不如来我 [Github](https://github.com/OrangeX4/Better-Markdown-Latex-Shortcuts) 点个 Star 或 Follow 来关注进展呢?\n\n快来看看对你有没有帮助吧!\n\n<!-- more -->\n\n## 如何使用?\n\n就像 `Shift + Alt + ↑↓` 快捷键一样, 你可以使用 `Shift + Alt + ← →` 来复制你选中的代码到左边或者右边.\n\n就像 `Alt + ↑↓` 快捷键一样, 你可以使用 `Alt + ← →` 来移动你选中的代码到左边或者右边.\n\n你也可以按下 `Ctrl + Alt + U` 快捷键, 这会让你的多选中变为单选中.\n\n## 安装\n\n在vscode的插件市场搜索 `Orangex4` 并安装名为 \"Better Markdown&Latex Shortcuts\" 的插件.\n\n![img](https://s3.ax1x.com/2020/12/02/DIW5mF.png)\n\n## Github地址\n\n[Github](https://github.com/OrangeX4/Better-Markdown-Latex-Shortcuts)\n\n## 展示\n\n### 复制\n\n![copy](https://s3.ax1x.com/2020/12/02/DIg8ds.gif)\n\n### 多行复制\n\n![multicopy](https://s3.ax1x.com/2020/12/02/DIgGon.gif)\n\n### 移动\n\n![move](https://s3.ax1x.com/2020/12/02/DIgYiq.gif)\n\n### 单选\n\n![single](https://s3.ax1x.com/2020/12/02/DIgtJ0.gif)\n\n# Snippets\n\n|Snippet|Name|Code|\n|---|---|---|\n|\\\\\\\\|\\\\\\\\|\\\\\\\\|\n|\\\\\\\\\\$|single line|\\$\\\\displaystyle \\$|\n|\\\\\\\\\\$|multiline|\\$\\$<br />...<br />\\$\\$|\n|\\\\\\\\-|subscript|_{ }|\n|\\\\\\\\6|superscript|^{ }|\n|\\\\\\\\...|prefix|\\\\cdots|\n|\\\\\\\\.|cdot|\\\\cdot|\n|\\\\\\\\d|partial sign 'd'|{\\\\rm d}|\n|\\\\\\\\dx|partial sign 'dx'|{\\\\rm d}x|\n|\\\\\\\\dy|partial sign 'dy'|{\\\\rm d}y|\n|\\\\\\\\set|set bracket|\\\\{ \\\\}|\n|\\\\\\\\angle|angle bracket|\\\\langle \\\\rangle|\n|\\\\\\\\comma|alpha with comma|\\\\alpha_1,\\\\alpha_2,\\\\cdots,\\\\alpha_n|\n|\\\\\\\\plus|alpha with plus|\\\\alpha_1+\\\\alpha_2+\\\\cdots+\\\\alpha_n|\n|\\\\\\\\multiply|alpha with multiply|\\\\alpha_1\\\\times \\\\alpha_2\\\\times \\\\cdots\\\\times \\\\alpha_n|\n|\\\\\\\\dotmultiply|alpha with dot multiply|\\\\alpha_1\\\\cdot \\\\alpha_2\\\\cdots \\\\alpha_n|\n|\\\\\\\\mline|A line of matrix|\\\\alpha &\\\\beta &\\\\cdots &\\\\lambda \\\\\\\\|\n|\\\\\\\\smline|A line of matrix with subscript|\\\\alpha_1 &\\\\alpha_2 &\\\\cdots &\\\\alpha_n \\\\\\\\|\n|\\\\\\\\vdots|A line of vdots|\\\\vdots &\\\\vdots & &\\\\vdots \\\\\\\\|\n|\\\\\\\\aligned|A scope of aligned|\\$\\$<br />\\\\begin{aligned} <br />...<br />\\\\end{aligned}<br />\\$\\$|\n|\\\\\\\\matrix|A scope of matrix|\\$\\$<br />\\\\begin{matrix} <br />...<br />\\\\end{matrix}<br />\\$\\$|\n|\\\\\\\\bmatrix|A scope of bmatrix|\\\\begin{bmatrix} <br />...<br />\\\\end{bmatrix}|\n|\\\\\\\\vmatrix|A scope of vmatrix|\\\\begin{vmatrix} <br />...<br />\\\\end{vmatrix}|\n|\\\\\\\\pmatrix|A scope of pmatrix|\\\\begin{pmatrix} <br />...<br />\\\\end{pmatrix}|\n|\\\\\\\\equations|Equations|...|\n|\\\\\\\\zeroequations|Zero equations|...|\n\n# Display\n\n## Plus & Multiply & Comma\n\n![](https://s3.ax1x.com/2020/12/03/D7Btm9.gif)\n\n## Matrix\n\n![](https://s3.ax1x.com/2020/12/03/D7BNwR.gif)\n\n## Equations\n\n![](https://s3.ax1x.com/2020/12/03/D7BJOJ.gif)\n\n\n# English\n\n## How to use it\n\nSimilarly to `Shift + Alt + ↑↓`, you can press `Shift + Alt + ← →` to copy what you select to left or right.\n\nSimilarly to `Alt + ↑↓`, you can press `Alt + ← →` to move what you select to left or right.\n\nYou can also press `Ctrl + Alt + U` to single the selections.\n\n## Install\n\nSearch `Orangex4` in vscode extensions market and install the one called \"Better Markdown&Latex Shortcuts\".\n\n![img](https://s3.ax1x.com/2020/12/02/DIW5mF.png)\n\n## Display\n\n### Copy\n\n![copy](https://s3.ax1x.com/2020/12/02/DIg8ds.gif)\n\n### Multicopy\n\n![multicopy](https://s3.ax1x.com/2020/12/02/DIgGon.gif)\n\n### Move\n\n![move](https://s3.ax1x.com/2020/12/02/DIgYiq.gif)\n\n### Single Selections\n\n![single](https://s3.ax1x.com/2020/12/02/DIgtJ0.gif)\n\n","tags":["Typescript","Javascript","VS Code","Notes","Markdown","Latex","Extension"],"categories":["Product"]},{"title":"NJUAI-Notes共享笔记计划!","url":"/post/sharing-my-notes-in-nju/","content":"\n# 介绍\n\n进入南大之后, 我决定从大一就开始尝试用 Vscode + Markdown + Latex 写相关课程的笔记.\n\n目前体验还不错, 而且为了更好的类似编程的记笔记体验, 我还加入了版本控制系统--Git, 当然也传上了Github.\n\n所以你可以很自由地看到我做的所有笔记, 想看的话, 按照下面的步骤做就好啦.\n\n<!-- more -->\n\n## 展示\n\n[![D4nceP.png](https://s3.ax1x.com/2020/12/01/D4nceP.png)](https://imgchr.com/i/D4nceP)\n\n# Github地址\n\n[Notes](https://github.com/OrangeX4/NJUAI-Notes)\n\n# 使用说明\n\n下载安装Vscode, git, 安装`Markdown Preview Enhance`插件.  \n\n使用命令\n\n```bash\ngit clone https://github.com/OrangeX4/Notes.git --depth=1\n```\n\n因为内含图片, 略大, \n耗时长, 请耐心等待.\n\nClone完成之后用Vscode打开该文件夹.\n\n点开一个你想看的markdown文件, 按下快捷键`Ctrl + K`, 再按下`V`键即可.\n\n# 博客数学公式测试\n\n$\\displaystyle \\frac{x^2}{16}+\\frac{y^2}{9}=1$","tags":["VS Code","Notes","Markdown","Latex"],"categories":["Study"]},{"title":"从零开始搭建VS Code和C++开发环境 (超简易)","url":"/post/a-simple-way-to-install-vscode-and-cpp-environment/","content":"\n# 从零开始搭建VS Code和C++开发环境\n\n我第一次尝试在 VS Code 中开发 C 和 C++, 这个教程记录了我搭建相关环境的过程.\n\n<!-- more -->\n\n# 安装 vscode\n\n搭开发环境的第一步, 当然是下载一个好用的编辑器.\n\nIDE (集成开发环境) 如VS对于初学者来说过于庞大, 而且也不一定好用.  \n而DevC++虽然对小白友好, 但是界面不够美观, 自动补全和代码调试的支持也很差.\n\n所以这里推荐vscode, 轻量, 美观, 方便, 十分适合有一定美观度要求的初学者.\n\n## vscode 下载地址\n\n[官网](https://code.visualstudio.com/)  \n[腾讯软件中心](https://pc.qq.com/detail/16/detail_22856.html)\n\n国内推荐从腾讯软件中心下载.\n\n# 使用 AutoVsCEnv_WPF 自动搭配 C++ 环境\n\n## 下载\n\n有两个下载地址, 国内同样推荐使用后者.\n\n[Github Release](https://github.com/SDchao/AutoVsCEnv_WPF/releases/tag/V1.991)  \n[蓝奏云](https://sdchao.lanzous.com/iPwgadc211e)\n\n## 安装\n\n### 选择 MinGW 安装位置\n\n只需要选择一个平常软件安装的地方就可以了.\n\n比如对我来说就是: `D:\\Program\\MinGW`\n\n### 选择项目文件夹位置\n\n这个很重要. 选择一个你容易找到的位置来存放.\n\n比如对我来说就是: `D:\\Project\\Cpp`\n\n以后写C++代码都要把文件放在这个文件夹里面, 否则 vscode 无法识别.\n\n如果你真的需要多个文件夹, 可以复制这个文件夹里面的 `.vscode` 文件夹到其他位置. `.vscode` 文件夹保存有相应的vscode配置.\n\n# 用 vscode 打开项目文件夹\n\n在 vscode 打开你的项目文件夹, vscode 就会自动提醒你安装插件, 比如 `C/C++` 之类的, 点确定就好.  \n\nvscode 推荐的插件一般直接安装就好, 不会出什么差错.\n\n## 运行 test.cpp\n\n在 vscode 点开 test.cpp, 按下 F5, 如果能正常运行的话, 恭喜你, 你配置好了!\n\n## 修改 launch.json 和 tasks.json\n\n但是先别急着高兴, 为了一个更好的开发体验, 你还需要替换一处文件: \n\n将 `.vscode/tasks.json` 里的内容替换为:\n\n```json\n{  \n  \"version\": \"2.0.0\",  \n  \"command\": \"g++\",  \n  \"type\": \"shell\",  \n  \"presentation\": {  \n    \"echo\": true,  \n    \"reveal\": \"always\",  \n    \"focus\": false,  \n    \"panel\": \"shared\",  \n    \"showReuseMessage\": true,  \n    \"clear\": false  \n  },  \n  \"args\": [\"-m32\",\"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}.exe\"],  \n  \"problemMatcher\": {  \n    \"owner\": \"cpp\",  \n    \"fileLocation\": [\"autoDetect\", \"${workspaceRoot}\"],  \n    \"pattern\": {  \n      \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",  \n      \"file\": 1,  \n      \"line\": 2,  \n      \"column\": 3,  \n      \"severity\": 4,  \n      \"message\": 5  \n    }  \n  }  \n}  \n```\n\n于是, 你现在就可以愉快地写代码了!","tags":["Cpp","C","VS Code"],"categories":["Technology"]},{"title":"尝试在手机上编程--Orangex和Termux配置教程","url":"/post/coding-with-your-mobile-phone/","content":"\n# 开始Orangex项目的起因（可忽略）\n\n在19年的时候，偶然了解到Termux这个安卓手机上终端模拟器，惊叹于它的麻雀虽小五脏俱全，却也对它没有图形界面而感到遗憾。\n\n没有图形界面，就难以流畅地在手机上写代码。\n\n因此我去网上找了找相关的图形解决方案，发现无一不是巨大的，有的方案甚至接近一G多，并且对手机端屏幕的适配都不是很好。\n\n于是我开始思考起了手机中的终端中再内置一个图形界面的必要性，发现这种想法完全是多余的--手机本身就有图形界面啊！\n\n于是就下定决心通过浏览器，采取前后端传输数据的方案来实现对termux的操控，进而实现一个用户友好的图形界面。\n\n**经过三周的秃头肝代码，我终于完成了Orangex。**\n\n**Orangex中内置：文件管理器，编辑器，简易的终端控制器。**\n\n**足够用来开发简单的cpp，python，web程序。**\n\n<!-- more -->\n\n## Github地址\n\n[Github](https://github.com/OrangeX4/Orangex-Mobile)\n\n欢迎Star, Pull Request!\n\n## Orangex用户反馈交流群\n\nQQ群: 1158193208\n\n![](https://s1.ax1x.com/2020/10/11/0gBfwq.png)\n\n# Termux的安装与配置\n\n以下内容从**国光大大的Termux配置教程**中摘抄, 详细请见:\n\n[国光Termux配置教程](https://www.sqlsec.com/2018/05/termux.html)\n\n提醒:  \n安装配置Termux需要稳定的网络环境, 甚至在必要的时候还需要使用代理, 否则极易失败.\n\n## 下载Termux\n\nF-Droid下载: [https://f-droid.org/packages/com.termux/](https://f-droid.org/packages/com.termux/)\n\n百度云下载(推荐): [https://pan.baidu.com/s/1nrWb05hDfSp6TDVC4HXpVA](https://pan.baidu.com/s/1nrWb05hDfSp6TDVC4HXpVA)  \n提取码: term  \n![地址](https://s1.ax1x.com/2020/10/11/0gJSMV.jpg)\n\n## 初始化\n\n运行你安装好的Termux.\n\n### 问题\n\n第一次启动Termux的时候需要从远程服务器加载数据，然而可能会遇到这种问题：\n\n![](https://image.3001.net/images/20200418/15871943464391.png)\n\n目前解决方法有两种：\n\nVPN 全局代理 （成功率很高）\n如果你是 WiFi 的话尝试切换到运营商流量 （有一定成功率）\n① Google Play ② F-Droid 根据这个顺序重复1、2操作\n\n## Pkg更换国内源\n使用pkg update 更新一下的时候发现默认的官方源网速有点慢，在这个喧嚣浮躁的时代，我们难以静下心等待，这个时候就得更换成国内的Termux清华大学源了，加快软件包下载速度.\n\npkg update 卡住的话多按几次'y'和回车,不要傻乎乎的等.\n\n请复制以下代码, 粘贴到终端处.  \n(注意 pkg update 下面的换行符也要复制)\n\n```bash\nsed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/termux-packages-24 stable main@' $PREFIX/etc/apt/sources.list\n\nsed -i 's@^\\(deb.*games stable\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/game-packages-24 games stable@' $PREFIX/etc/apt/sources.list.d/game.list\n\nsed -i 's@^\\(deb.*science stable\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/science-packages-24 science stable@' $PREFIX/etc/apt/sources.list.d/science.list\n\npkg update\n\n```\n\n卡住就按回车, 比如\n\n![](https://s1.ax1x.com/2020/10/11/0gNuLV.jpg)\n\n![](https://s1.ax1x.com/2020/10/11/0gNns0.jpg)\n\n## 安装基础工具与环境 (重要!!!)\n\n复制粘贴运行下列代码: \n\n```bash\npkg install vim curl wget git tree nodejs python clang -y\n```\n\n该操作耗时较长, 请确保拥有良好的网络环境, 并且常常看一下需不需要按回车键.\n\n## NPM设置淘宝镜像\n\n执行下列命令: \n```bash\nnpm config set registry https://registry.npm.taobao.org\n```\n\n## 安装Orangex (重要!!! 关键步骤)\n\n执行下列命令: \n```bash\nnpm install -g orangex\n```\n\n# 运行Orangex\n\n## 执行命令\n\n**以上配置环境的代码只用执行一次，**\n\n**配置好环境之后，运行Orangex都只需要使用下面的代码就好。**\n\n执行下列命令: \n```bash\norangex\n```\n\n![](https://s1.ax1x.com/2020/10/11/0gdhTK.jpg)\n\n## 浏览器打开\n\n然后在手机的浏览器中打开: [http://127.0.0.1:8080/](http://127.0.0.1:8080/)\n\n这里推荐使用**Firefox**浏览器，能有较好的体验。\n\n**至此，你就能愉快地写代码了！**\n\n## 界面UI\n\n![](https://s1.ax1x.com/2020/10/11/0gdfw6.jpg)\n\n![](https://s1.ax1x.com/2020/10/11/0gdWex.jpg)\n\n![](https://s1.ax1x.com/2020/10/11/0gd2O1.jpg)\n\n# 终端界面优化 (选做)\n\n该脚本主要使用了zsh来替代bash作为默认 shell，并且支持色彩和字体样式，同时也激活了外置存储，可以直接访问SD卡下的目录。主题默认为 agnoster，颜色样式默认为 Tango，字体默认为 Ubuntu。\n\n复制粘贴回车执行下面代码:  \n(注意不要漏了双引号!!! 否则将进入 > 类似的输入状态, 再输入一个双引号即可) \n\n```bash\nsh -c \"$(curl -fsSL https://html.sqlsec.com/termux-install.sh)\"\n```\n\n执行, 等它下载安装完, 界面不动的时候多按几次回车.\n\n该过程耗时较长, 请耐心等待.  \n(可以切换成后台, 但请不要关闭Termux)\n\nAndroid6.0 以上会弹框确认是否授权访问文件,点击始终允许授权后 Termux 可以方便的访问SD卡文件.\n\n![](https://image.3001.net/images/20200418/1587207468173.png)\n\n手机 App 默认只能访问自己的数据，如果要访问手机的存储，需要请求权限，如果你刚刚不小心点了拒绝的话，那么可以执行以下命令来重新获取访问权限:\n\n```bash\ntermux-setup-storage\n```\n\n脚本允许后先后有如下两个选项:\n\n```Bash\nEnter a number, leave blank to not to change: 14\nEnter a number, leave blank to not to change: 6\n```\n\n分别选择色彩样式和字体样式，重启Termux app后生效配置。不满意刚刚的效果，想要继续更改配色方案的话，可以根据下面命令来更改对应的色彩配色方案：\n\n设置色彩样式：\n\n输入`chcolor`命令更换色彩样式，或者：`~/.termux/colors.sh`命令\n\n设置字体\n\n运行`chfont`更换字体，或者：`~/.termux/fonts.sh`命令\n\n# 其他\n\nTermux配置教程详见：\n\n[国光Termux配置教程](https://www.sqlsec.com/2018/05/termux.html)","tags":["Orangex","Nodejs","Typescript","Javascript","Cpp","Python","Finux","Termux","Linux"],"categories":["Product"]},{"title":"Finux--为Termux设计的文件管理器","url":"/post/finux-a-file-manager-designed-for-termux/","content":"\n# Finux\nFinux是一个为移动端的Linux系统或模拟器(如 Termux)设计的文件管理器.  \n你也可以把它当作你的电脑或服务器的手机操控的远程文件管理器, 只要你有正确的IP地址(如公网ip)和端口.\n\n<!-- more -->\n\n# Github地址\n\n[github](https://github.com/OrangeX4/Termux-Finux/edit/master/README.md)\n\n欢迎Star!\n\n## 安装\n```bash\nnpm install -g finux\n```\n\n## 运行\n```bash\nfinux\n```\n\n在手机中的浏览器打开\"http://127.0.0.1:8080/\"\n\n# Screenshot (屏幕截图)\n![Pic1](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5acd1cdada8d4614a103ccb048e8b9f5~tplv-k3u1fbpfcp-zoom-1.image)\n\n---\n\n![Pic2](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de9903bcd71d40ee9f4b73593b1e0ee7~tplv-k3u1fbpfcp-zoom-1.image)\n\n---\n\n![Pic3](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d90a65d4514e402eb6c339b85ffc4519~tplv-k3u1fbpfcp-zoom-1.image)\n","tags":["Orangex","Nodejs","Typescript","Javascript","Finux","Termux","Linux"],"categories":["Product"]},{"title":"Orangex | 橙式 —— 手机编程的最佳选择","url":"/post/orangex-code-editor-for-termux/","content":"\n# [Orangex](https://orangex.orangex4.cool/)\n\nOrangex 是一个专为智能手机设计的, 基于 Termux 的代码编辑器。\n\n详见: [Orangex 说明文档](https://orangex.orangex4.cool/)\n\nRepo: [Orangex-Mobile](https://github.com/OrangeX4/Orangex-Mobile)\n\n## Orangex 特点\n\n### 手机编程\n\n借助 Termux 搭建手机上的 Linux 环境，提供几近于电脑的多语言通用编程体验, 支持 Python, C++, JavaScript, Java 等多种语言。\n\n### 图形界面\n\n提供专门为手机设计的、移动端友好的文件资源管理器、代码编辑器和终端快速执行界面。\n\n### 体积较小\n\nTermux 通过 Android 底层的 Linux 系统执行命令，不额外安装其他 Linux 系统；Orangex 以 Web 方式渲染界面，不需要额外安装图形界面，占用手机内存较少。\n\n### 从零开始\n\n为初学者精心设计的编程教程，无需电脑，只需要一台智能手机就能开始你的编程学习之旅。你好，新世界！\n\n\n![](https://p.pstatp.com/origin/138450001d52bb2b7662d)\n\n<!-- more -->\n\n## 安装\n\n### 下载 APP\n\n**下载 [Termux 的安装包](https://box.nju.edu.cn/f/0065095f93504ba5831c/?dl=1) 和 [Orangex 的安装包](https://box.nju.edu.cn/f/340effcc1ddb4419be93/?dl=1) 并安装.**\n\n![](https://p.pstatp.com/origin/138660001fd41ced655eb)\n\n### 执行自动化安装脚本\n\n\n**请确保在这个过程中你有一个稳定的网络!**  \n**执行安装脚本过程大概会持续 15 ~ 30 分钟. 消耗约 100 MiB 的流量.**  \n\n复制下列代码, 粘贴到 `Termux` APP:\n\n```sh\nsh -c \"$(curl -fsSL https://blog.orangex4.cool/demo/orangex/install.sh)\"\n```\n\n![](https://p.pstatp.com/origin/137460001e3cc839196ee)\n\n\n**按下回车, 静静等待十几秒, 界面开始输出文本则说明安装脚本已经开始执行.**  \n**并且会提示 \"Termux 正在获取访问存储权限\", 选择允许即可.**\n\n\n![](https://p.pstatp.com/origin/13896000227d13b372c95)\n\n\n**当界面变成如图所示时, 说明安装脚本已经执行完毕了, 恭喜你!**\n\n**成功界面要点: 1.不同的配色. 2.左下角绿色的波浪线 '~'.**\n\n![](https://p.pstatp.com/origin/137a80002b37a51c84df5)\n\n\n### 开始使用 Orangex\n\n**重启 Termux, 如果安装完成, 你会看见这样的界面:**\n\n![](https://p.pstatp.com/origin/1383a0001ff5041be632e)\n\n**说明你已经安装成功了, 可以使用 Orangex 了!**\n\n**打开 `Orangex` APP:**\n\n![](https://p.pstatp.com/origin/137ae00035592c6b1cfd9)\n\n![](https://p.pstatp.com/origin/138450001d52bb2b7662d)\n\n![](https://p.pstatp.com/origin/1389a0001253a2a1b9f98)\n\n**恭喜你, 可以开始使用 Orangex 编程了!**\n","tags":["Orangex","橙式","Termux","手机编程"],"categories":["Product"]}]